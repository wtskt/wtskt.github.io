<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>rabbitMQ学习笔记</title>
      <link href="/posts/cec52606.html"/>
      <url>/posts/cec52606.html</url>
      
        <content type="html"><![CDATA[<p>微服务一旦拆分，必然涉及到服务之间的相互调用，目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要<strong>等待</strong>服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们成这种调用方式为<strong>同步调用</strong>，也可以叫<strong>同步通讯</strong>。但在很多场景下，我们可能需要采用<strong>异步通讯</strong>的方式，为什么呢？</p><p>我们先来看看什么是同步通讯和异步通讯。如图：<br><img src="../assets/rabbitmq/1686983181054-f2bcce85-1fce-412f-95cd-1ae829f8406f_1.png" alt="image.png"><br>解读：</p><ul><li>同步通讯：就如同打视频电话，双方的交互都是实时的。因此同一时刻你只能跟一个人打视频电话。</li><li>异步通讯：就如同发微信聊天，双方的交互不是实时的，你不需要立刻给对方回应。因此你可以多线操作，同时跟多人聊天。</li></ul><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发微信可以同时与多个人收发微信，但是往往响应会有延迟。</p><p>所以，如果我们的业务需要实时得到服务提供方的响应，则应该选择同步通讯（同步调用）。而如果我们追求更高的效率，并且不需要实时响应，则应该选择异步通讯（异步调用）。</p><p>同步调用的方式我们已经学过了，之前的OpenFeign调用就是。但是：</p><ul><li>异步调用又该如何实现？</li><li>哪些业务适合用异步调用来实现呢？</li></ul><p>通过今天的学习你就能明白这些问题了。</p><h1>1.初识MQ</h1><h2 id="1-1-同步调用">1.1.同步调用</h2><p>之前说过，我们现在基于OpenFeign的调用都属于是同步调用，那么这种方式存在哪些问题呢？<br>举个例子，我们以昨天留给大家作为作业的<strong>余额支付功能</strong>为例来分析，首先看下整个流程：<br><img src="../assets/rabbitmq/1686989758652-29a64761-c029-4ec4-91aa-f1fc85de086c_1.jpeg" alt=""><br>目前我们采用的是基于OpenFeign的同步调用，也就是说业务执行流程是这样的：</p><ul><li>支付服务需要先调用用户服务完成余额扣减</li><li>然后支付服务自己要更新支付流水单的状态</li><li>然后支付服务调用交易服务，更新业务订单状态为已支付</li></ul><p>三个步骤依次执行。<br>这其中就存在3个问题：<br><strong>第一</strong>，<strong>拓展性差</strong><br>我们目前的业务相对简单，但是随着业务规模扩大，产品的功能也在不断完善。<br>在大多数电商业务中，用户支付成功后都会以短信或者其它方式通知用户，告知支付成功。假如后期产品经理提出这样新的需求，你怎么办？是不是要在上述业务中再加入通知用户的业务？<br>某些电商项目中，还会有积分或金币的概念。假如产品经理提出需求，用户支付成功后，给用户以积分奖励或者返还金币，你怎么办？是不是要在上述业务中再加入积分业务、返还金币业务？<br>。。。<br>最终你的支付业务会越来越臃肿：<br><img src="../assets/rabbitmq/1686984472076-c05b2155-3346-40f5-b85e-5961caa998ab_1.jpeg" alt=""><br>也就是说每次有新的需求，现有支付逻辑都要跟着变化，代码经常变动，不符合开闭原则，拓展性不好。</p><p><strong>第二</strong>，<strong>性能下降</strong><br>由于我们采用了同步调用，调用者需要等待服务提供者执行完返回结果后，才能继续向下执行，也就是说每次远程调用，调用者都是阻塞等待状态。最终整个业务的响应时长就是每次远程调用的执行时长之和：<br><img src="../assets/rabbitmq/1686989760653-42e1ae3e-677b-4f27-b55a-eaa259f03ad3_1.jpeg" alt=""><br>假如每个微服务的执行时长都是50ms，则最终整个业务的耗时可能高达300ms，性能太差了。</p><p><strong>第三，级联失败</strong><br>由于我们是基于OpenFeign调用交易服务、通知服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。<br>这其实就是同步调用的<strong>级联失败</strong>问题。</p><p>但是大家思考一下，我们假设用户余额充足，扣款已经成功，此时我们应该确保支付流水单更新为已支付，确保交易成功。毕竟收到手里的钱没道理再退回去吧<img src="../assets/rabbitmq/1686986652875-9e2924a9-e0f3-4de2-ae41-8b39ef6345bc_1.png" alt="image.png">。</p><p>因此，这里不能因为短信通知、更新订单状态失败而回滚整个事务。</p><p>综上，同步调用的方式存在下列问题：</p><ul><li>拓展性差</li><li>性能下降</li><li>级联失败</li></ul><p>而要解决这些问题，我们就必须用<strong>异步调用</strong>的方式来代替<strong>同步调用</strong>。</p><h2 id="1-2-异步调用">1.2.异步调用</h2><p>异步调用方式其实就是基于消息通知的方式，一般包含三个角色：</p><ul><li>消息发送者：投递消息的人，就是原来的调用方</li><li>消息Broker：管理、暂存、转发消息，你可以把它理解成微信服务器</li><li>消息接收者：接收和处理消息的人，就是原来的服务提供方</li></ul><p><img src="../assets/rabbitmq/1686990662733-65b0eac8-f65f-4024-a581-6d5761c4c5a4_1.jpeg" alt=""></p><p>在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息Broker。然后接收者根据自己的需求从消息Broker那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。<br>这样，发送消息的人和接收消息的人就完全解耦了。</p><p>还是以余额支付业务为例：<br><img src="../assets/rabbitmq/1686990257816-4f0b5ddd-7618-4095-b797-25b92f0bf2a5_1.jpeg" alt=""><br>除了扣减余额、更新支付流水单状态以外，其它调用逻辑全部取消。而是改为发送一条消息到Broker。而相关的微服务都可以订阅消息通知，一旦消息到达Broker，则会分发给每一个订阅了的微服务，处理各自的业务。</p><p>假如产品经理提出了新的需求，比如要在支付成功后更新用户积分。支付代码完全不用变更，而仅仅是让积分服务也订阅消息即可：<br><img src="../assets/rabbitmq/1686989956210-7c1f451c-0368-4602-b02e-a66f2c0f6deb_1.jpeg" alt=""><br>不管后期增加了多少消息订阅者，作为支付服务来讲，执行问扣减余额、更新支付流水状态后，发送消息即可。业务耗时仅仅是这三部分业务耗时，仅仅100ms，大大提高了业务性能。</p><p>另外，不管是交易服务、通知服务，还是积分服务，他们的业务与支付关联度低。现在采用了异步调用，解除了耦合，他们即便执行过程中出现了故障，也不会影响到支付服务。</p><p>综上，异步调用的优势包括：</p><ul><li>耦合度更低</li><li>性能更好</li><li>业务拓展性强</li><li>故障隔离，避免级联失败</li></ul><p>当然，异步通信也并非完美无缺，它存在下列缺点：</p><ul><li>完全依赖于Broker的可靠性、安全性和性能</li><li>架构复杂，后期维护和调试麻烦</li></ul><h2 id="1-3-技术选型">1.3.技术选型</h2><p>消息Broker，目前常见的实现方案就是消息队列（MessageQueue），简称为MQ.<br>目比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种常见MQ的对比：</p><table><thead><tr><th></th><th><strong>RabbitMQ</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>公司/社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ<br>追求可靠性：RabbitMQ、RocketMQ<br>追求吞吐能力：RocketMQ、Kafka<br>追求消息低延迟：RabbitMQ、Kafka</p><p>据统计，目前国内消息队列使用最多的还是RabbitMQ，再加上其各方面都比较均衡，稳定性也好，因此我们课堂上选择RabbitMQ来学习。</p><h1>2.RabbitMQ</h1><p>RabbitMQ是基于Erlang语言开发的开源消息通信中间件，官网地址：<br><a href="https://www.rabbitmq.com/">Messaging that just works — RabbitMQ</a><br>接下来，我们就学习它的基本概念和基础用法。</p><h2 id="2-1-安装">2.1.安装</h2><p>我们同样基于Docker来安装RabbitMQ，使用下面的命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=itheima \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line"> -v mq-plugins:/plugins \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> --network hmall \</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><p>如果拉取镜像困难的话，可以使用课前资料给大家准备的镜像，利用docker load命令加载：<br><img src="../assets/rabbitmq/1689939432832-7ee45271-f96c-43fa-b0f5-8c01bcdf289f_1.png" alt="image.png"></p><p>可以看到在安装命令中有两个映射的端口：</p><ul><li>15672：RabbitMQ提供的管理控制台的端口</li><li>5672：RabbitMQ的消息发送处理接口</li></ul><p>安装完成后，我们访问 http://192.168.150.101:15672即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。<br>登录后即可看到管理控制台总览页面：<br><img src="../assets/rabbitmq/1687137883587-56417f79-a649-43a5-be88-2ff777d3cd25_1.png" alt="image.png"></p><p>RabbitMQ对应的架构如图：<br><img src="../assets/rabbitmq/1687136827222-52374724-79c9-4738-b53f-653cc0805d22_1.png" alt="image.png"><br>其中包含几个概念：</p><ul><li><code>**publisher**</code>：生产者，也就是发送消息的一方</li><li><code>**consumer**</code>：消费者，也就是消费消息的一方</li><li><code>**queue**</code>：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li><code>**exchange**</code>：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li><code>**virtual host**</code>：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue</li></ul><p>上述这些东西都可以在RabbitMQ的管理控制台来管理，下一节我们就一起来学习控制台的使用。</p><h2 id="2-2-收发消息">2.2.收发消息</h2><h3 id="2-2-1-交换机">2.2.1.交换机</h3><p>我们打开Exchanges选项卡，可以看到已经存在很多交换机：<br><img src="../assets/rabbitmq/1687137953880-08aa9694-6a1e-4337-8bde-5757ec3c33f8_1.png" alt="image.png"><br>我们点击任意交换机，即可进入交换机详情页面。仍然会利用控制台中的publish message 发送一条消息：<br><img src="../assets/rabbitmq/1687138031622-ccce4612-954f-42c0-9291-73cf19915e39_1.png" alt="image.png"><br><img src="../assets/rabbitmq/1687138163403-839087fe-66f7-4710-a866-210aa0282be8_2.png" alt="image.png"><br>这里是由控制台模拟了生产者发送的消息。由于没有消费者存在，最终消息丢失了，这样说明交换机没有存储消息的能力。</p><h3 id="2-2-2-队列">2.2.2.队列</h3><p>我们打开<code>Queues</code>选项卡，新建一个队列：<br><img src="../assets/rabbitmq/1687138308409-be6e1649-af03-4ee7-bee3-8518fd0dca03_1.png" alt="image.png"><br>命名为<code>hello.queue1</code>：<br><img src="../assets/rabbitmq/1687255044231-4b0e0339-c1ab-468a-8a72-9ae1b184594c_1.png" alt="image.png"><br>再以相同的方式，创建一个队列，密码为<code>hello.queue2</code>，最终队列列表如下：<br><img src="../assets/rabbitmq/1687255204405-523f8053-e414-45f3-99c3-b66de152f79e_1.png" alt="image.png"><br>此时，我们再次向<code>amq.fanout</code>交换机发送一条消息。会发现消息依然没有到达队列！！<br>怎么回事呢？<br>发送到交换机的消息，只会路由到与其绑定的队列，因此仅仅创建队列是不够的，我们还需要将其与交换机绑定。</p><h3 id="2-2-3-绑定关系">2.2.3.绑定关系</h3><p>点击<code>Exchanges</code>选项卡，点击<code>amq.fanout</code>交换机，进入交换机详情页，然后点击<code>Bindings</code>菜单，在表单中填写要绑定的队列名称：<br><img src="../assets/rabbitmq/1687255547460-d87943cd-4309-4778-8e9e-374167a97e45_1.png" alt="image.png"><br>相同的方式，将hello.queue2也绑定到改交换机。<br>最终，绑定结果如下：<br><img src="../assets/rabbitmq/1687255624712-7bd850b1-95fd-4d98-8243-57d1779de935_1.png" alt="image.png"></p><h3 id="2-2-4-发送消息">2.2.4.发送消息</h3><p>再次回到exchange页面，找到刚刚绑定的<code>amq.fanout</code>，点击进入详情页，再次发送一条消息：<br><img src="../assets/rabbitmq/1687138163403-839087fe-66f7-4710-a866-210aa0282be8_1_1.png" alt="image.png"><br>回到<code>Queues</code>页面，可以发现<code>hello.queue</code>中已经有一条消息了：<br><img src="../assets/rabbitmq/1687255725782-fd5e2550-3572-48c0-9ec0-60786e33a3b1_1.png" alt="image.png"><br>点击队列名称，进入详情页，查看队列详情，这次我们点击get message：<br><img src="../assets/rabbitmq/1687255765034-69e67460-1535-48b3-8537-da383c498141_1.png" alt="image.png"><br>可以看到消息到达队列了：<br><img src="../assets/rabbitmq/1687255798153-dda9b729-a3a0-415c-9167-48c525c75800_1.png" alt="image.png"><br>这个时候如果有消费者监听了MQ的<code>hello.queue1</code>或<code>hello.queue2</code>队列，自然就能接收到消息了。</p><h2 id="2-3-数据隔离">2.3.数据隔离</h2><h3 id="2-3-1-用户管理">2.3.1.用户管理</h3><p>点击<code>Admin</code>选项卡，首先会看到RabbitMQ控制台的用户管理界面：<br><img src="../assets/rabbitmq/1687151143347-f7e2aaff-0a14-4022-8d50-582ee75e2998_1.png" alt="image.png"><br>这里的用户都是RabbitMQ的管理或运维人员。目前只有安装RabbitMQ时添加的<code>itheima</code>这个用户。仔细观察用户表格中的字段，如下：</p><ul><li><code>Name</code>：<code>itheima</code>，也就是用户名</li><li><code>Tags</code>：<code>administrator</code>，说明<code>itheima</code>用户是超级管理员，拥有所有权限</li><li><code>Can access virtual host</code>： <code>/</code>，可以访问的<code>virtual host</code>，这里的<code>/</code>是默认的<code>virtual host</code></li></ul><p>对于小型企业而言，出于成本考虑，我们通常只会搭建一套MQ集群，公司内的多个不同项目同时使用。这个时候为了避免互相干扰， 我们会利用<code>virtual host</code>的隔离特性，将不同项目隔离。一般会做两件事情：</p><ul><li>给每个项目创建独立的运维账号，将管理权限分离。</li><li>给每个项目创建不同的<code>virtual host</code>，将每个项目的数据隔离。</li></ul><p>比如，我们给黑马商城创建一个新的用户，命名为<code>hmall</code>：<br><img src="../assets/rabbitmq/1687151725993-05fe9bd1-8f8b-468d-8456-eac36278bea2_1.png" alt="image.png"><br>你会发现此时hmall用户没有任何<code>virtual host</code>的访问权限：<br><img src="../assets/rabbitmq/1687151853554-e671a696-e9c0-4ff5-9caf-31b39e1a17f5_1.png" alt="image.png"><br>别急，接下来我们就来授权。</p><h3 id="2-3-2-virtual-host">2.3.2.virtual host</h3><p>我们先退出登录：<br><img src="../assets/rabbitmq/1687152245922-8438490f-d094-4db1-88fa-a2d916d46a97_1.png" alt="image.png"><br>切换到刚刚创建的hmall用户登录，然后点击<code>Virtual Hosts</code>菜单，进入<code>virtual host</code>管理页：<br><img src="../assets/rabbitmq/1687152310566-2531b1c8-b362-47c7-ba81-1b7c1880c18b_1.png" alt="image.png"><br>可以看到目前只有一个默认的<code>virtual host</code>，名字为 <code>/</code>。<br>我们可以给黑马商城项目创建一个单独的<code>virtual host</code>，而不是使用默认的<code>/</code>。<br><img src="../assets/rabbitmq/1687152363999-edb47263-f303-4ee8-a80d-be55d6b0ed37_1.png" alt="image.png"><br>创建完成后如图：<br><img src="../assets/rabbitmq/1687152448758-d0a05827-10ac-459b-a92f-495304dddf89_1.png" alt="image.png"><br>由于我们是登录<code>hmall</code>账户后创建的<code>virtual host</code>，因此回到<code>users</code>菜单，你会发现当前用户已经具备了对<code>/hmall</code>这个<code>virtual host</code>的访问权限了：<br><img src="../assets/rabbitmq/1687152695194-6c2dda94-43c4-4ee9-b95c-ca9d8504cd0c_1.png" alt="image.png"></p><p>此时，点击页面右上角的<code>virtual host</code>下拉菜单，切换<code>virtual host</code>为 <code>/hmall</code>：<br><img src="../assets/rabbitmq/1687153236457-ca138f25-b351-4095-8855-aa0df42fae65_1.png" alt="image.png"><br>然后再次查看queues选项卡，会发现之前的队列已经看不到了：<br><img src="../assets/rabbitmq/1687153307085-0157ac47-2d89-4f32-ab9a-d513b0e19f25_1.png" alt="image.png"><br>这就是基于<code>virtual host </code>的隔离效果。</p><h1>3.SpringAMQP</h1><p>将来我们开发业务功能的时候，肯定不会在控制台收发消息，而是应该基于编程的方式。由于<code>RabbitMQ</code>采用了AMQP协议，因此它具备跨语言的特性。任何语言只要遵循AMQP协议收发消息，都可以与<code>RabbitMQ</code>交互。并且<code>RabbitMQ</code>官方也提供了各种不同语言的客户端。<br>但是，RabbitMQ官方提供的Java客户端编码相对复杂，一般生产环境下我们更多会结合Spring来使用。而Spring的官方刚好基于RabbitMQ提供了这样一套消息收发的模板工具：SpringAMQP。并且还基于SpringBoot对其实现了自动装配，使用起来非常方便。</p><p>SpringAmqp的官方地址：<br><a href="https://spring.io/projects/spring-amqp">Spring AMQP</a><br>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息</li></ul><p>这一章我们就一起学习一下，如何利用SpringAMQP实现对RabbitMQ的消息收发。</p><h2 id="3-1-导入Demo工程">3.1.导入Demo工程</h2><p>在课前资料给大家提供了一个Demo工程，方便我们学习SpringAMQP的使用：<br><img src="../assets/rabbitmq/1689939402093-e0e0a3d4-84ed-40b5-bedc-0884fcb4ae64_1.png" alt="image.png"><br>将其复制到你的工作空间，然后用Idea打开，项目结构如图：<br><img src="../assets/rabbitmq/1687156248415-3fe7ae5b-302b-4a35-a520-b2419e616862_1.png" alt="image.png"><br>包括三部分：</p><ul><li>mq-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><p>在mq-demo这个父工程中，已经配置好了SpringAMQP相关的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mq-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>publisher<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>consumer<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--单元测试--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因此，子工程中就可以直接使用SpringAMQP了。</p><h2 id="3-2-快速入门">3.2.快速入门</h2><p>在之前的案例中，我们都是经过交换机发送消息到队列，不过有时候为了测试方便，我们也可以直接向队列发送消息，跳过交换机。<br>在入门案例中，我们就演示这样的简单模型，如图：<br><img src="../assets/rabbitmq/1687261777988-23fff732-dcfa-499a-a8a1-a66328fe05e7_1.jpeg" alt=""><br>也就是：</p><ul><li>publisher直接发送消息到队列</li><li>消费者监听并处理队列中的消息</li></ul><p>:::warning<br><strong>注意</strong>：这种模式一般测试使用，很少在生产中使用。<br>:::</p><p>为了方便测试，我们现在控制台新建一个队列：simple.queue<br><img src="../assets/rabbitmq/1687171932026-33eace5d-c0f2-4070-8742-fe8b34c6c749_1.png" alt="image.png"><br>添加成功：<br><img src="../assets/rabbitmq/1687172012283-e19d8da6-8944-4f51-a40b-a15f0814b015_1.png" alt="image.png"><br>接下来，我们就可以利用Java代码收发消息了。</p><h3 id="3-1-1-消息发送">3.1.1.消息发送</h3><p>首先配置MQ地址，在<code>publisher</code>服务的<code>application.yml</code>中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在<code>publisher</code>服务中编写测试类<code>SpringAmqpTest</code>，并利用<code>RabbitTemplate</code>实现消息发送：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.publisher.amqp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开控制台，可以看到消息已经发送到队列中：<br><img src="../assets/rabbitmq/1687173164620-51a78ccb-b2a1-474b-8147-076f4b8cee12_1.png" alt="image.png"><br>接下来，我们再来实现消息接收。</p><h3 id="3-1-2-消息接收">3.1.2.消息接收</h3><p>首先配置MQ地址，在<code>consumer</code>服务的<code>application.yml</code>中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><p>然后在<code>consumer</code>服务的<code>com.itheima.consumer.listener</code>包中新建一个类<code>SpringRabbitListener</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line"><span class="comment">// 利用RabbitListener来声明要监听的队列信息</span></span><br><span class="line">    <span class="comment">// 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</span></span><br><span class="line">    <span class="comment">// 可以看到方法体中接收的就是消息体的内容</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-3-测试">3.1.3.测试</h3><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息。最终consumer收到消息：<br><img src="../assets/rabbitmq/1687173574481-792b9a3c-bcab-4f96-9d09-206cccdd1456_1.png" alt="image.png"></p><h2 id="3-3-WorkQueues模型">3.3.WorkQueues模型</h2><p>Work queues，任务模型。简单来说就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong>。<br><img src="../assets/rabbitmq/1687261956699-4b3c9999-ee86-4dda-a795-1ea5f4f9eef3_1.jpeg" alt=""></p><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。<br>此时就可以使用work 模型，<strong>多个消费者共同处理消息处理，消息处理的速度就能大大提高</strong>了。</p><p>接下来，我们就来模拟这样的场景。<br>首先，我们在控制台创建一个新的队列，命名为<code>work.queue</code>：<br><img src="../assets/rabbitmq/1687179664222-3e226588-63e3-4275-a9e2-cce5c8e93d4c_1.png" alt="image.png"></p><h3 id="3-3-1-消息发送">3.3.1.消息发送</h3><p>这次我们循环发送，模拟大量消息堆积现象。<br>在publisher服务中的SpringAmqpTest类中添加一个测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * workQueue</span></span><br><span class="line"><span class="comment">     * 向队列中不停发送消息，模拟消息堆积。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWorkQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 队列名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, message_&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 发送消息，每20毫秒发送一次，相当于每秒发送50条消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message + i);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-消息接收">3.3.2.消息接收</h3><p>要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());</span><br><span class="line">    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这两消费者，都设置了<code>Thead.sleep</code>，模拟任务耗时：</p><ul><li>消费者1 sleep了20毫秒，相当于每秒钟处理50个消息</li><li>消费者2 sleep了200毫秒，相当于每秒处理5个消息</li></ul><h3 id="3-3-3-测试">3.3.3.测试</h3><p>启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。<br>最终结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_0】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.869555300</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_1】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.884518</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_2】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.907454400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_4】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.953332100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_6】<span class="number">21</span>:<span class="number">06</span>:<span class="number">00.997867300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_8】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.042178700</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_3】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.086478800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_10】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.087476600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_12】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.132578300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_14】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.175851200</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_16】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.218533400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_18】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.261322900</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_5】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.287003700</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_20】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.304412400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_22】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.349950100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_24】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.394533900</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_26】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.439876500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_28】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.482937800</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_7】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.488977100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_30】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.526409300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_32】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.572148</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_34】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.618264800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_36】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.660780600</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_9】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.689189300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_38】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.705261</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_40】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.746927300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_42】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.789835</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_44】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.834393100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_46】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.875312100</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_11】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.889969500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_48】<span class="number">21</span>:<span class="number">06</span>:<span class="number">01.920702500</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_13】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.090725900</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_15】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.293060600</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_17】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.493748</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_19】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.696635100</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_21】<span class="number">21</span>:<span class="number">06</span>:<span class="number">02.896809700</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_23】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.099533400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_25】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.301446400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_27】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.504999100</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_29】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.705702500</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_31】<span class="number">21</span>:<span class="number">06</span>:<span class="number">03.906601200</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_33】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.108118500</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_35】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.308945400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_37】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.511547700</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_39】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.714038400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_41】<span class="number">21</span>:<span class="number">06</span>:<span class="number">04.916192700</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_43】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.116286400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_45】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.318055100</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_47】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.520656400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_49】<span class="number">21</span>:<span class="number">06</span>:<span class="number">05.723106700</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到消费者1和消费者2竟然每人消费了25条消息：</p><ul><li>消费者1很快完成了自己的25条消息</li><li>消费者2却在缓慢的处理自己的25条消息。</li></ul><p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。导致1个消费者空闲，另一个消费者忙的不可开交。没有充分利用每一个消费者的能力，最终消息处理的耗时远远超过了1秒。这样显然是有问题的。</p><h3 id="3-3-4-能者多劳">3.3.4.能者多劳</h3><p>在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p>再次测试，发现结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_0】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.659664200</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_1】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.680610</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_2】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.703625</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_3】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.724330100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_4】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.746651100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_5】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.768401400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_6】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.790511400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_7】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.812559800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_8】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.834500600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_9】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.857438800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_10】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.880379600</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_11】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.899327100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_12】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.922828400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_13】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.945617400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_14】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.968942500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_15】<span class="number">21</span>:<span class="number">12</span>:<span class="number">51.992215400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_16】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.013325600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_17】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.035687100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_18】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.058188</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_19】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.081208400</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_20】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.103406200</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_21】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.123827300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_22】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.146165100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_23】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.168828300</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_24】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.191769500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_25】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.214839100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_26】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.238998700</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_27】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.259772600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_28】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.284131800</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_29】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.306190600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_30】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.325315800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_31】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.347012500</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_32】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.368508600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_33】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.391785100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_34】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.416383800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_35】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.439019</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_36】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.461733900</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_37】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.485990</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_38】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.509219900</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_39】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.523683400</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_40】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.547412100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_41】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.571191800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_42】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.593024600</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_43】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.616731800</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_44】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.640317</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_45】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.663111100</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_46】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.686727</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_47】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.709266500</span></span><br><span class="line">消费者<span class="number">2.</span>.......接收到消息：【hello, message_48】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.725884900</span></span><br><span class="line">消费者<span class="number">1</span>接收到消息：【hello, message_49】<span class="number">21</span>:<span class="number">12</span>:<span class="number">52.746299900</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以发现，由于消费者1处理速度较快，所以处理了更多的消息；消费者2处理速度较慢，只处理了6条消息。而最终总的执行耗时也在1秒左右，大大提升。<br>正所谓能者多劳，这样充分利用了每一个消费者的处理能力，可以有效避免消息积压问题。</p><h3 id="3-3-5-总结">3.3.5.总结</h3><p>Work模型的使用：</p><ul><li>多个消费者绑定到一个队列，同一条消息只会被一个消费者处理</li><li>通过设置prefetch来控制消费者预取的消息数量</li></ul><h2 id="3-4-交换机类型">3.4.交换机类型</h2><p>在之前的两个测试案例中，都没有交换机，生产者直接发送消息到队列。而一旦引入交换机，消息发送的模式会有很大变化：<br><img src="../assets/rabbitmq/1687264784359-de7cbc4a-ec60-461d-a6a4-3474ba52e0d0_1.jpeg" alt=""><br>可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：</p><ul><li><strong>Publisher</strong>：生产者，不再发送消息到队列中，而是发给交换机</li><li><strong>Exchange</strong>：交换机，一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</li><li><strong>Queue</strong>：消息队列也与以前一样，接收消息、缓存消息。不过队列一定要与交换机绑定。</li><li><strong>Consumer</strong>：消费者，与以前一样，订阅队列，没有变化</li></ul><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p><p>交换机的类型有四种：</p><ul><li><strong>Fanout</strong>：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机</li><li><strong>Direct</strong>：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</li><li><strong>Topic</strong>：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</li><li><strong>Headers</strong>：头匹配，基于MQ的消息头匹配，用的较少。</li></ul><p>课堂中，我们讲解前面的三种交换机模式。</p><h2 id="3-5-Fanout交换机">3.5.Fanout交换机</h2><p>Fanout，英文翻译是扇出，我觉得在MQ中叫广播更合适。<br>在广播模式下，消息发送流程是这样的：<br><img src="../assets/rabbitmq/1687181415478-ea4bb17b-48bf-4303-9242-27703efb39d8_1.png" alt="image.png"></p><ul><li>1）  可以有多个队列</li><li>2）  每个队列都要绑定到Exchange（交换机）</li><li>3）  生产者发送的消息，只能发送到交换机</li><li>4）  交换机把消息发送给绑定过的所有队列</li><li>5）  订阅队列的消费者都能拿到消息</li></ul><p>我们的计划是这样的：<br><img src="../assets/rabbitmq/1687182474076-2b479229-56a6-4163-93c4-a6a7187f3dbe_1.png" alt="image.png"></p><ul><li>创建一个名为<code> hmall.fanout</code>的交换机，类型是<code>Fanout</code></li><li>创建两个队列<code>fanout.queue1</code>和<code>fanout.queue2</code>，绑定到交换机<code>hmall.fanout</code></li></ul><h3 id="3-5-1-声明队列和交换机">3.5.1.声明队列和交换机</h3><p>在控制台创建队列<code>fanout.queue1</code>:<br><img src="../assets/rabbitmq/1689946886137-0bcb8641-faf1-4bea-b553-4b3bb96d224c_1.png" alt="image.png"><br>在创建一个队列<code>fanout.queue2</code>：<br><img src="../assets/rabbitmq/1689946949922-c4e442c3-568b-4164-a327-74e30aa9b9d0_1.png" alt="image.png"><br>然后再创建一个交换机：<br><img src="../assets/rabbitmq/1689948003779-ea99bac6-6b84-48f3-9760-a719ba5f0c2e_1.png" alt="image.png"><br>然后绑定两个队列到交换机：<br><img src="../assets/rabbitmq/1689947064113-23e123ec-a601-4af4-a44f-70f7b4ef4063_1.png" alt="image.png"><br><img src="../assets/rabbitmq/1689947695506-5346b816-61c7-4bfe-a28d-db261b3598c5_1.png" alt="image.png"></p><h3 id="3-5-2-消息发送">3.5.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.fanout&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, everyone!&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-3-消息接收">3.5.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenFanoutQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到Fanout消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-4-总结">3.5.4.总结</h3><p>交换机的作用是什么？</p><ul><li>接收publisher发送的消息</li><li>将消息按照规则路由到与之绑定的队列</li><li>不能缓存消息，路由失败，消息丢失</li><li>FanoutExchange的会将消息路由到每个绑定的队列</li></ul><h2 id="3-6-Direct交换机">3.6.Direct交换机</h2><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。<br><img src="../assets/rabbitmq/1687182404437-027a5191-b037-4033-baab-6bafd998161d_1.png" alt="image.png"><br>在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li><li>消息的发送方在 向 Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li></ul><p><strong>案例需求如图</strong>：<br><img src="../assets/rabbitmq/1687182519270-885589ec-7f4a-492a-ab78-cddf109121cc_1.png" alt="image.png"></p><ol><li>声明一个名为<code>hmall.direct</code>的交换机</li><li>声明队列<code>direct.queue1</code>，绑定<code>hmall.direct</code>，<code>bindingKey</code>为<code>blud</code>和<code>red</code></li><li>声明队列<code>direct.queue2</code>，绑定<code>hmall.direct</code>，<code>bindingKey</code>为<code>yellow</code>和<code>red</code></li><li>在<code>consumer</code>服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2</li><li>在publisher中编写测试方法，向<code>hmall.direct</code>发送消息</li></ol><h3 id="3-6-1-声明队列和交换机">3.6.1.声明队列和交换机</h3><p>首先在控制台声明两个队列<code>direct.queue1</code>和<code>direct.queue2</code>，这里不再展示过程：<br><img src="../assets/rabbitmq/1689947864231-5ace5d74-fdac-4a2a-9f92-180df06fe4ad_1.png" alt="image.png"><br>然后声明一个direct类型的交换机，命名为<code>hmall.direct</code>:<br><img src="../assets/rabbitmq/1689948033525-e6ea1134-c2ef-4b80-86b2-b364c1301335_1.png" alt="image.png"><br>然后使用<code>red</code>和<code>blue</code>作为key，绑定<code>direct.queue1</code>到<code>hmall.direct</code>：<br><img src="../assets/rabbitmq/1689948151280-bed1019d-7d60-455b-95b8-754e266edf50_1.png" alt="image.png"><br><img src="../assets/rabbitmq/1689948181033-6b1e6556-0110-4ed8-a2cb-8bc2dd388903_1.png" alt="image.png"></p><p>同理，使用<code>red</code>和<code>yellow</code>作为key，绑定<code>direct.queue2</code>到<code>hmall.direct</code>，步骤略，最终结果：<br><img src="../assets/rabbitmq/1689948243879-c97a0e6f-807a-4bc3-ad53-032c378008f3_1.png" alt="image.png"></p><h3 id="3-6-2-消息接收">3.6.2.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-3-消息发送">3.6.3.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于使用的red这个key，所以两个消费者都收到了消息：<br><img src="../assets/rabbitmq/1687182883516-906024ce-6ade-4dcd-8b4e-2b0cfc1bd03a_1.png" alt="image.png"><br>我们再切换为blue这个key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;最新报道，哥斯拉是居民自治巨型气球，虚惊一场！&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;blue&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现，只有消费者1收到了消息：<br><img src="../assets/rabbitmq/1687182898732-afba28a8-c57e-4ccb-a330-9e3315879b31_1.png" alt="image.png"></p><h3 id="3-6-4-总结">3.6.4.总结</h3><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><h2 id="3-7-Topic交换机">3.7.Topic交换机</h2><h3 id="3-7-1-说明">3.7.1.说明</h3><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。<br>只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>BindingKey</code> 的时候使用通配符！</p><p><code>BindingKey</code> 一般都是有一个或多个单词组成，多个单词之间以<code>.</code>分割，例如： <code>item.insert</code></p><p>通配符规则：</p><ul><li><code>#</code>：匹配一个或多个词</li><li><code>*</code>：匹配不多不少恰好1个词</li></ul><p>举例：</p><ul><li><code>item.#</code>：能够匹配<code>item.spu.insert</code> 或者 <code>item.spu</code></li><li><code>item.*</code>：只能匹配<code>item.spu</code></li></ul><p>图示：<br><img src="../assets/rabbitmq/1687183148068-ad50ba76-0024-460b-9b24-3cf7a0fe172e_1.png" alt="image.png"><br>假如此时publisher发送的消息使用的<code>RoutingKey</code>共有四种：</p><ul><li><code>china.news </code>代表有中国的新闻消息；</li><li><code>china.weather</code> 代表中国的天气消息；</li><li><code>japan.news</code> 则代表日本新闻</li><li><code>japan.weather</code> 代表日本的天气消息；</li></ul><p>解释：</p><ul><li><code>topic.queue1</code>：绑定的是<code>china.#</code> ，凡是以 <code>china.</code>开头的<code>routing key</code> 都会被匹配到，包括：<ul><li><code>china.news</code></li><li><code>china.weather</code></li></ul></li><li><code>topic.queue2</code>：绑定的是<code>#.news</code> ，凡是以 <code>.news</code>结尾的 <code>routing key</code> 都会被匹配。包括:<ul><li><code>china.news</code></li><li><code>japan.news</code></li></ul></li></ul><p>接下来，我们就按照上图所示，来演示一下Topic交换机的用法。<br>首先，在控制台按照图示例子创建队列、交换机，并利用通配符绑定队列和交换机。此处步骤略。最终结果如下：<br><img src="../assets/rabbitmq/1689948475987-05bab459-43b6-47ad-bbfc-faf9f50d776e_1.png" alt="image.png"></p><h3 id="3-7-2-消息发送">3.7.2.消息发送</h3><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * topicExchange</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendTopicExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.topic&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-3-消息接收">3.7.3.消息接收</h3><p>在consumer服务的SpringRabbitListener中添加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-4-总结">3.7.4.总结</h3><p>描述下Direct交换机与Topic交换机的差异？</p><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><code>#</code>：代表0个或多个词</li><li><code>*</code>：代表1个词</li></ul><h2 id="3-8-声明队列和交换机">3.8.声明队列和交换机</h2><p>在之前我们都是基于RabbitMQ控制台来创建队列、交换机。但是在实际开发时，队列和交换机是程序员定义的，将来项目上线，又要交给运维去创建。那么程序员就需要把程序中运行的所有队列和交换机都写下来，交给运维。在这个过程中是很容易出现错误的。<br>因此推荐的做法是由程序启动时检查队列和交换机是否存在，如果不存在自动创建。</p><h3 id="3-8-1-基本API">3.8.1.基本API</h3><p>SpringAMQP提供了一个Queue类，用来创建队列：<br><img src="../assets/rabbitmq/1689945200636-5f4a823f-6f36-4088-9b67-7b9b3ae48079_1.png" alt="image.png"></p><p>SpringAMQP还提供了一个Exchange接口，来表示所有不同类型的交换机：<br><img src="../assets/rabbitmq/1687181804385-c500bc13-9f81-4071-ad8a-598fa5f57d97_1.png" alt="image.png"><br><img src="D:/desktop/4%E3%80%81%E6%96%B0%E7%89%88RabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/01.MQ%E5%9F%BA%E7%A1%80/assets/image-20210717165552676.png" alt="">我们可以自己创建队列和交换机，不过SpringAMQP还提供了ExchangeBuilder来简化这个过程：<br><img src="../assets/rabbitmq/1689945421476-fe44bf9a-d6eb-4f51-af02-374359c8e70b_1.png" alt="image.png"><br>而在绑定队列和交换机时，则需要使用BindingBuilder来创建Binding对象：<br><img src="../assets/rabbitmq/1689945503733-13d2179c-f586-4de5-b18c-d3b5749f1f96_1.png" alt="image.png"></p><h3 id="3-8-2-fanout示例">3.8.2.fanout示例</h3><p>在consumer中创建一个类，声明队列和交换机：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;hmall.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-2-direct示例">3.8.2.direct示例</h3><p>direct模式由于要绑定多个KEY，会非常麻烦，每一个Key都要编写一个binding：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Direct类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">&quot;hmall.direct&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1WithRed</span><span class="params">(Queue directQueue1, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue1).to(directExchange).with(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1WithBlue</span><span class="params">(Queue directQueue1, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue1).to(directExchange).with(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2WithRed</span><span class="params">(Queue directQueue2, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue2).to(directExchange).with(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2WithYellow</span><span class="params">(Queue directQueue2, DirectExchange directExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(directQueue2).to(directExchange).with(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-8-4-基于注解声明">3.8.4.基于注解声明</h3><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>例如，我们同样声明Direct模式的交换机和队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是简单多了。<br>再试试Topic模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-9-消息转换器">3.9.消息转换器</h2><p>Spring的消息发送代码接收的消息体是一个Object：<br><img src="../assets/rabbitmq/1687183652317-82b0319b-03aa-46ed-afbc-373e7a6fa0f1_1.png" alt="image.png"><br>而在数据传输时，它会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。<br>只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>我们来测试一下。</p><h3 id="3-9-1-测试默认转换器">3.9.1.测试默认转换器</h3><p>1）创建测试队列<br>首先，我们在consumer服务中声明一个新的配置类：<br><img src="../assets/rabbitmq/1687183868403-242aa812-a07f-4748-8863-dc5d1e161dc1_1.png" alt="image.png"><br>利用@Bean的方式创建一个队列，<img src="D:/desktop/4%E3%80%81%E6%96%B0%E7%89%88RabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/01.MQ%E5%9F%BA%E7%A1%80/assets/image-20211104102144275.png" alt="">具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">objectQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;object.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里我们先不要给这个队列添加消费者，我们要查看消息体的格式。</p><p>重启consumer服务以后，该队列就会被自动创建出来了：<br><img src="../assets/rabbitmq/1687184033157-c4c8e59e-a2b3-4b2b-9c20-ca3c597e556c_1.png" alt="image.png"><br><img src="../assets/image-20211104102409347.png" alt=""></p><p>2）发送消息<br>我们在publisher模块的SpringAmqpTest中新增一个消息发送的代码，发送一个Map对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendMap</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 准备消息</span></span><br><span class="line">    Map&lt;String,Object&gt; msg = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    msg.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line">    msg.put(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;object.queue&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送消息后查看控制台：<br><img src="../assets/rabbitmq/1687184206574-69117533-5b4e-4172-b254-23130023f711_1.png" alt="image.png"><br>可以看到消息格式非常不友好。</p><h3 id="3-9-2-配置JSON转换器">3.9.2.配置JSON转换器</h3><p>显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><p>在<code>publisher</code>和<code>consumer</code>两个服务中都引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，如果项目中引入了<code>spring-boot-starter-web</code>依赖，则无需再次引入<code>Jackson</code>依赖。</p><p>配置消息转换器，在<code>publisher</code>和<code>consumer</code>两个服务的启动类中添加一个Bean即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jackson2JsonMessageConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jackson2JsonMessageConverter.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jackson2JsonMessageConverter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息转换器中添加的messageId可以便于我们将来做幂等性判断。</p><p>此时，我们到MQ控制台<strong>删除</strong><code>object.queue</code>中的旧的消息。然后再次执行刚才的消息发送的代码，到MQ的控制台查看消息结构：<br><img src="../assets/rabbitmq/1687245684217-8b401cc5-29e6-4d08-9a9b-4fbe0dffd486_1.png" alt="image.png"><br><img src="D:/desktop/4%E3%80%81%E6%96%B0%E7%89%88RabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/01.MQ%E5%9F%BA%E7%A1%80/assets/image-20211104102831385.png" alt=""></p><h3 id="3-9-3-消费者接收Object">3.9.3.消费者接收Object</h3><p>我们在consumer服务中定义一个新的消费者，publisher是用Map发送，那么消费者也一定要用Map接收，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;object.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(Map&lt;String, Object&gt; msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到object.queue消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:/desktop/4%E3%80%81%E6%96%B0%E7%89%88RabbitMQ%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/01.MQ%E5%9F%BA%E7%A1%80/assets/image-20211104103017170.png" alt=""></p><h1>4.业务改造</h1><p>案例需求：改造余额支付功能，将支付成功后基于OpenFeign的交易服务的更新订单状态接口的同步调用，改为基于RabbitMQ的异步通知。<br>如图：<br><img src="../assets/rabbitmq/1690336853591-c874697b-688c-464e-8797-8162a02701e8_1.png" alt="image.png"><br>说明，我们只关注交易服务，步骤如下：</p><ul><li>定义topic类型交换机，命名为<code>pay.topic</code></li><li>定义消息队列，命名为<code>mark.order.pay.queue</code></li><li>将<code>mark.order.pay.queue</code>与<code>pay.topic</code>绑定，<code>BindingKey</code>为<code>pay.success</code></li><li>支付成功时不再调用交易服务更新订单状态的接口，而是发送一条消息到<code>pay.topic</code>，发送消息的<code>RoutingKey</code>  为<code>pay.success</code>，消息内容是订单id</li><li>交易服务监听<code>mark.order.pay.queue</code>队列，接收到消息后更新订单状态为已支付</li></ul><h2 id="4-1-配置MQ">4.1.配置MQ</h2><p>不管是生产者还是消费者，都需要配置MQ的基本信息。分为两步：<br>1）添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--消息发送--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）配置MQ地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 你的虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><h2 id="4-1-接收消息">4.1.接收消息</h2><p>在trade-service服务中定义一个消息监听类：<br><img src="../assets/rabbitmq/1690339169409-cf6a9ad7-c364-4a26-992d-dd678f53e910_1.png" alt="image.png"><br>其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.trade.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.service.IOrderService;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ExchangeTypes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayStatusListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IOrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;mark.order.pay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;pay.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">            key = &quot;pay.success&quot;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenPaySuccess</span><span class="params">(Long orderId)</span>&#123;</span><br><span class="line">        orderService.markOrderPaySuccess(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-发送消息">4.2.发送消息</h2><p>修改<code>pay-service</code>服务下的<code>com.hmall.pay.service.impl.PayOrderServiceImpl</code>类中的<code>tryPayOrderByBalance</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPayOrderByBalance</span><span class="params">(PayOrderDTO payOrderDTO)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询支付单</span></span><br><span class="line">    <span class="type">PayOrder</span> <span class="variable">po</span> <span class="operator">=</span> getById(payOrderDTO.getId());</span><br><span class="line">    <span class="comment">// 2.判断状态</span></span><br><span class="line">    <span class="keyword">if</span>(!PayStatus.WAIT_BUYER_PAY.equalsValue(po.getStatus()))&#123;</span><br><span class="line">        <span class="comment">// 订单不是未支付，状态异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;交易已支付或关闭！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.尝试扣减余额</span></span><br><span class="line">    userClient.deductMoney(payOrderDTO.getPw(), po.getAmount());</span><br><span class="line">    <span class="comment">// 4.修改支付单状态</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> markPayOrderSuccess(payOrderDTO.getId(), LocalDateTime.now());</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(<span class="string">&quot;交易已支付或关闭！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.修改订单状态</span></span><br><span class="line">    <span class="comment">// tradeClient.markOrderPaySuccess(po.getBizOrderNo());</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;pay.topic&quot;</span>, <span class="string">&quot;pay.success&quot;</span>, po.getBizOrderNo());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;支付成功的消息发送失败，支付单id：&#123;&#125;， 交易单id：&#123;&#125;&quot;</span>, po.getId(), po.getBizOrderNo(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>5.练习</h1><h2 id="5-1-抽取共享的MQ配置">5.1.抽取共享的MQ配置</h2><p>将MQ配置抽取到Nacos中管理，微服务中直接使用共享配置。</p><h2 id="5-2-改造下单功能">5.2.改造下单功能</h2><p>改造下单功能，将基于OpenFeign的清理购物车同步调用，改为基于RabbitMQ的异步通知：</p><ul><li>定义topic类型交换机，命名为<code>trade.topic</code></li><li>定义消息队列，命名为<code>cart.clear.queue</code></li><li>将<code>cart.clear.queue</code>与<code>trade.topic</code>绑定，<code>BindingKey</code>为<code>order.create</code></li><li>下单成功时不再调用清理购物车接口，而是发送一条消息到<code>trade.topic</code>，发送消息的<code>RoutingKey</code>  为<code>order.create</code>，消息内容是下单的具体商品、当前登录用户信息</li><li>购物车服务监听<code>cart.clear.queue</code>队列，接收到消息后清理指定用户的购物车中的指定商品</li></ul><h2 id="5-3-登录信息传递优化">5.3.登录信息传递优化</h2><p>某些业务中，需要根据登录用户信息处理业务，而基于MQ的异步调用并不会传递登录用户信息。前面我们的做法比较麻烦，至少要做两件事：</p><ul><li>消息发送者在消息体中传递登录用户</li><li>消费者获取消息体中的登录用户，处理业务</li></ul><p>这样做不仅麻烦，而且编程体验也不统一，毕竟我们之前都是使用UserContext来获取用户。</p><p>大家思考一下：有没有更优雅的办法传输登录用户信息，让使用MQ的人无感知，依然采用UserContext来随时获取用户。</p><p>参考资料：<br><a href="https://docs.spring.io/spring-amqp/docs/2.4.14/reference/html/#post-processing">Spring AMQP</a></p><h2 id="5-4-改造项目一">5.4.改造项目一</h2><p>思考一下，项目一中的哪些业务可以由同步方式改为异步方式调用？试着改造一下。<br>举例：短信发送</p><p>在昨天的练习作业中，我们改造了余额支付功能，在支付成功后利用RabbitMQ通知交易服务，更新业务订单状态为已支付。<br>但是大家思考一下，如果这里MQ通知失败，支付服务中支付流水显示支付成功，而交易服务中的订单状态却显示未支付，数据出现了不一致。<br>此时前端发送请求查询支付状态时，肯定是查询交易服务状态，会发现业务订单未支付，而用户自己知道已经支付成功，这就导致用户体验不一致。</p><p>因此，这里我们必须尽可能确保MQ消息的可靠性，即：消息应该至少被消费者处理1次<br>那么问题来了：</p><ul><li><strong>我们该如何确保MQ消息的可靠性</strong>？</li><li><strong>如果真的发送失败，有没有其它的兜底方案？</strong></li></ul><p>这些问题，在今天的学习中都会找到答案。</p><h1>6.发送者的可靠性</h1><p>首先，我们一起分析一下消息丢失的可能性有哪些。<br>消息从发送者发送消息，到消费者处理消息，需要经过的流程是这样的：<br><img src="../assets/rabbitmq/1687334552247-cab38ab5-ae63-4f06-9ece-e9f244e3c170_1.jpeg" alt=""><br>消息从生产者到消费者的每一步都可能导致消息丢失：</p><ul><li>发送消息时丢失：<ul><li>生产者发送消息时连接MQ失败</li><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code></li><li>消息到达MQ后，处理消息的进程发生异常</li></ul></li><li>MQ导致消息丢失：<ul><li>消息到达MQ，保存到队列后，尚未消费就突然宕机</li></ul></li><li>消费者处理消息时：<ul><li>消息接收后尚未处理突然宕机</li><li>消息接收后处理过程中抛出异常</li></ul></li></ul><p>综上，我们要解决消息丢失问题，保证MQ的可靠性，就必须从3个方面入手：</p><ul><li>确保生产者一定把消息发送到MQ</li><li>确保MQ不会将消息弄丢</li><li>确保消费者一定要处理消息</li></ul><p>这一章我们先来看如何确保生产者一定能把消息发送到MQ。</p><h2 id="6-1-生产者重试机制">6.1.生产者重试机制</h2><p>首先第一种情况，就是生产者发送消息时，出现了网络故障，导致与MQ的连接中断。</p><p>为了解决这个问题，SpringAMQP提供的消息发送时的重试机制。即：当<code>RabbitTemplate</code>与MQ连接超时后，多次重试。</p><p>修改<code>publisher</code>模块的<code>application.yaml</code>文件，添加下面的内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="string">1s</span> <span class="comment"># 设置MQ的连接超时时间</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启超时重试机制</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 失败后的初始等待时间</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br></pre></td></tr></table></figure><p>我们利用命令停掉RabbitMQ服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop mq</span><br></pre></td></tr></table></figure><p>然后测试发送一条消息，会发现会每隔1秒重试1次，总共重试了3次。消息发送的超时重试机制配置成功了！</p><p>:::warning<br><strong>注意</strong>：当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。不过SpringAMQP提供的重试机制是<strong>阻塞式</strong>的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的。<br>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。<br>:::</p><h2 id="6-2-生产者确认机制">6.2.生产者确认机制</h2><p>一般情况下，只要生产者与MQ之间的网路连接顺畅，基本不会出现发送消息丢失的情况，因此大多数情况下我们无需考虑这种问题。<br>不过，在少数情况下，也会出现消息发送到MQ之后丢失的现象，比如：</p><ul><li>MQ内部处理消息的进程发生了异常</li><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code>，因此无法路由</li></ul><p>针对上述情况，RabbitMQ提供了生产者消息确认机制，包括<code>Publisher Confirm</code>和<code>Publisher Return</code>两种。在开启确认机制的情况下，当生产者发送消息给MQ后，MQ会根据消息处理的情况返回不同的<strong>回执</strong>。<br>具体如图所示：<br><img src="../assets/rabbitmq/1690366611659-d5c7f355-7ab1-4eb8-8488-13e1d98843ce_1.png" alt="image.png"><br>总结如下：</p><ul><li>当消息投递到MQ，但是路由失败时，通过<strong>Publisher Return</strong>返回异常信息，同时返回ack的确认信息，代表投递成功</li><li>临时消息投递到了MQ，并且入队成功，返回ACK，告知投递成功</li><li>持久消息投递到了MQ，并且入队完成持久化，返回ACK ，告知投递成功</li><li>其它情况都会返回NACK，告知投递失败</li></ul><p>其中<code>ack</code>和<code>nack</code>属于<strong>Publisher Confirm</strong>机制，<code>ack</code>是投递成功；<code>nack</code>是投递失败。而<code>return</code>则属于<strong>Publisher Return</strong>机制。<br>默认两种机制都是关闭状态，需要通过配置文件来开启。</p><h2 id="6-3-实现生产者确认">6.3.实现生产者确认</h2><h3 id="6-3-1-开启生产者确认">6.3.1.开启生产者确认</h3><p>在publisher模块的<code>application.yaml</code>中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启publisher confirm机制，并设置confirm类型</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启publisher return机制</span></span><br></pre></td></tr></table></figure><p>这里<code>publisher-confirm-type</code>有三种模式可选：</p><ul><li><code>none</code>：关闭confirm机制</li><li><code>simple</code>：同步阻塞等待MQ的回执</li><li><code>correlated</code>：MQ异步回调返回回执</li></ul><p>一般我们推荐使用<code>correlated</code>，回调机制。</p><h3 id="6-3-2-定义ReturnCallback">6.3.2.定义ReturnCallback</h3><p>每个<code>RabbitTemplate</code>只能配置一个<code>ReturnCallback</code>，因此我们可以在配置类中统一设置。我们在publisher模块定义一个配置类：<br><img src="../assets/rabbitmq/1687341529298-150b401d-67f9-4958-acdb-0d3147b0532b_1.png" alt="image.png"><br>内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.publisher.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ReturnedMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;触发return callback,&quot;</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;exchange: &#123;&#125;&quot;</span>, returned.getExchange());</span><br><span class="line">                log.debug(<span class="string">&quot;routingKey: &#123;&#125;&quot;</span>, returned.getRoutingKey());</span><br><span class="line">                log.debug(<span class="string">&quot;message: &#123;&#125;&quot;</span>, returned.getMessage());</span><br><span class="line">                log.debug(<span class="string">&quot;replyCode: &#123;&#125;&quot;</span>, returned.getReplyCode());</span><br><span class="line">                log.debug(<span class="string">&quot;replyText: &#123;&#125;&quot;</span>, returned.getReplyText());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-3-定义ConfirmCallback">6.3.3.定义ConfirmCallback</h3><p>由于每个消息发送时的处理逻辑不一定相同，因此ConfirmCallback需要在每次发消息时定义。具体来说，是在调用RabbitTemplate中的convertAndSend方法时，多传递一个参数：<br><img src="../assets/rabbitmq/1687348187394-21a3698a-277a-478b-8cb8-2ee5bc79207f_1.png" alt="image.png"><br>这里的CorrelationData中包含两个核心的东西：</p><ul><li><code>id</code>：消息的唯一标示，MQ对不同的消息的回执以此做判断，避免混淆</li><li><code>SettableListenableFuture</code>：回执结果的Future对象</li></ul><p>将来MQ的回执就会通过这个<code>Future</code>来返回，我们可以提前给<code>CorrelationData</code>中的<code>Future</code>添加回调函数来处理消息回执：<br><img src="../assets/rabbitmq/1687348449866-dee08277-6bc9-4463-9cb8-95013e05a6a2_1.png" alt="image.png"></p><p>我们新建一个测试，向系统自带的交换机发送消息，并且添加<code>ConfirmCallback</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherConfirm</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建CorrelationData</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>();</span><br><span class="line">    <span class="comment">// 2.给Future添加ConfirmCallback</span></span><br><span class="line">    cd.getFuture().addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">            <span class="comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span></span><br><span class="line">            log.error(<span class="string">&quot;send message fail&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(CorrelationData.Confirm result)</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span></span><br><span class="line">            <span class="keyword">if</span>(result.isAck())&#123; <span class="comment">// result.isAck()，boolean类型，true代表ack回执，false 代表 nack回执</span></span><br><span class="line">                log.debug(<span class="string">&quot;发送消息成功，收到 ack!&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// result.getReason()，String类型，返回nack时的异常描述</span></span><br><span class="line">                log.error(<span class="string">&quot;发送消息失败，收到 nack, reason : &#123;&#125;&quot;</span>, result.getReason());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 3.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;hmall.direct&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;hello&quot;</span>, cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：<br><img src="../assets/rabbitmq/1687351726363-c27337c1-cd6e-497e-96ad-ac55fe4cb9e4_1.png" alt="image.png"><br>可以看到，由于传递的<code>RoutingKey</code>是错误的，路由失败后，触发了<code>return callback</code>，同时也收到了ack。<br>当我们修改为正确的<code>RoutingKey</code>以后，就不会触发<code>return callback</code>了，只收到ack。<br>而如果连交换机都是错误的，则只会收到nack。</p><p>:::warning<br><strong>注意</strong>：<br>开启生产者确认比较消耗MQ性能，一般不建议开启。而且大家思考一下触发确认的几种情况：</p><ul><li>路由失败：一般是因为RoutingKey错误导致，往往是编程导致</li><li>交换机名称错误：同样是编程错误导致</li><li>MQ内部故障：这种需要处理，但概率往往较低。因此只有对消息可靠性要求非常高的业务才需要开启，而且仅仅需要开启ConfirmCallback处理nack就可以了。<br>:::</li></ul><h1>7.MQ的可靠性</h1><p>消息到达MQ以后，如果MQ不能及时保存，也会导致消息丢失，所以MQ的可靠性也非常重要。</p><h2 id="7-1-数据持久化">7.1.数据持久化</h2><p>为了提升性能，默认情况下MQ的数据都是在内存存储的临时数据，重启后就会消失。为了保证数据的可靠性，必须配置数据持久化，包括：</p><ul><li>交换机持久化</li><li>队列持久化</li><li>消息持久化</li></ul><p>我们以控制台界面为例来说明。</p><h3 id="7-1-1-交换机持久化">7.1.1.交换机持久化</h3><p>在控制台的<code>Exchanges</code>页面，添加交换机时可以配置交换机的<code>Durability</code>参数：<br><img src="../assets/rabbitmq/1687353601905-9b09c0df-1b03-49e1-95c8-437ef9f3cd81_1.png" alt="image.png"><br>设置为<code>Durable</code>就是持久化模式，<code>Transient</code>就是临时模式。</p><h3 id="7-1-2-队列持久化">7.1.2.队列持久化</h3><p>在控制台的Queues页面，添加队列时，同样可以配置队列的<code>Durability</code>参数：<br><img src="../assets/rabbitmq/1687353771968-5c560b86-a1ae-4649-8597-c7ebfeffa9a5_1.png" alt="image.png"><br>除了持久化以外，你可以看到队列还有很多其它参数，有一些我们会在后期学习。</p><h3 id="7-1-3-消息持久化">7.1.3.消息持久化</h3><p>在控制台发送消息的时候，可以添加很多参数，而消息的持久化是要配置一个<code>properties</code>：<br><img src="../assets/rabbitmq/1687354083723-84971642-712d-42bc-ba65-6e3b3b33758c_1.png" alt="image.png"></p><p>:::warning<br><strong>说明</strong>：在开启持久化机制以后，如果同时还开启了生产者确认，那么MQ会在消息持久化以后才发送ACK回执，进一步确保消息的可靠性。<br>不过出于性能考虑，为了减少IO次数，发送到MQ的消息并不是逐条持久化到数据库的，而是每隔一段时间批量持久化。一般间隔在100毫秒左右，这就会导致ACK有一定的延迟，因此建议生产者确认全部采用异步方式。<br>:::</p><h2 id="7-2-LazyQueue">7.2.LazyQueue</h2><p>在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟。但在某些特殊情况下，这会导致消息积压，比如：</p><ul><li>消费者宕机或出现网络故障</li><li>消息发送量激增，超过了消费者处理速度</li><li>消费者处理业务发生阻塞</li></ul><p>一旦出现消息堆积问题，RabbitMQ的内存占用就会越来越高，直到触发内存预警上限。此时RabbitMQ会将内存消息刷到磁盘上，这个行为成为<code>PageOut</code>. <code>PageOut</code>会耗费一段时间，并且会阻塞队列进程。因此在这个过程中RabbitMQ不会再处理新的消息，生产者的所有请求都会被阻塞。</p><p>为了解决这个问题，从RabbitMQ的3.6.0版本开始，就增加了Lazy Queues的模式，也就是惰性队列。惰性队列的特征如下：</p><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载）</li><li>支持数百万条的消息存储</li></ul><p>而在3.12版本之后，LazyQueue已经成为所有队列的默认格式。因此官方推荐升级MQ为3.12版本或者所有队列都设置为LazyQueue模式。</p><h3 id="7-2-1-控制台配置Lazy模式">7.2.1.控制台配置Lazy模式</h3><p>在添加队列的时候，添加<code>x-queue-mod=lazy</code>参数即可设置队列为Lazy模式：<br><img src="../assets/rabbitmq/1687421366634-1dfca4a6-2407-43c2-8e65-fd7ba9e660dc_1.png" alt="image.png"></p><h3 id="7-2-2-代码配置Lazy模式">7.2.2.代码配置Lazy模式</h3><p>在利用SpringAMQP声明队列的时候，添加<code>x-queue-mod=lazy</code>参数也可设置队列为Lazy模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(<span class="string">&quot;lazy.queue&quot;</span>)</span><br><span class="line">            .lazy() <span class="comment">// 开启Lazy模式</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是通过<code>QueueBuilder</code>的<code>lazy()</code>函数配置Lazy模式，底层源码如下：<br><img src="../assets/rabbitmq/1687421880071-2a21369f-00b3-481d-a9bb-ce69a346ccc3_1.png" alt="image.png"></p><p>当然，我们也可以基于注解来声明队列并设置为Lazy模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class="line"><span class="meta">        name = &quot;lazy.queue&quot;,</span></span><br><span class="line"><span class="meta">        durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">        arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 lazy.queue的消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-3-更新已有队列为lazy模式">7.2.3.更新已有队列为lazy模式</h3><p>对于已经存在的队列，也可以配置为lazy模式，但是要通过设置policy实现。<br>可以基于命令行设置policy：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_policy Lazy &quot;^lazy-queue$&quot; &#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27; --apply-to queues  </span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li><code>rabbitmqctl</code> ：RabbitMQ的命令行工具</li><li><code>set_policy</code> ：添加一个策略</li><li><code>Lazy</code> ：策略名称，可以自定义</li><li><code>&quot;^lazy-queue$&quot;</code> ：用正则表达式匹配队列的名字</li><li><code>'&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;'</code> ：设置队列模式为lazy模式</li><li><code>--apply-to queues</code>：策略的作用对象，是所有的队列</li></ul><p>当然，也可以在控制台配置policy，进入在控制台的<code>Admin</code>页面，点击<code>Policies</code>，即可添加配置：<br><img src="../assets/rabbitmq/1687422619364-b0e414b9-55fc-49f2-b7b5-de52b72a9f56_1.png" alt="image.png"></p><h1>8.消费者的可靠性</h1><p>当RabbitMQ向消费者投递消息以后，需要知道消费者的处理状态如何。因为消息投递给消费者并不代表就一定被正确消费了，可能出现的故障有很多，比如：</p><ul><li>消息投递的过程中出现了网络故障</li><li>消费者接收到消息后突然宕机</li><li>消费者接收到消息后，因处理不当导致异常</li><li>…</li></ul><p>一旦发生上述情况，消息也会丢失。因此，RabbitMQ必须知道消费者的处理状态，一旦消息处理失败才能重新投递消息。<br>但问题来了：RabbitMQ如何得知消费者的处理状态呢？</p><p>本章我们就一起研究一下消费者处理消息时的可靠性解决方案。</p><h2 id="8-1-消费者确认机制">8.1.消费者确认机制</h2><p>为了确认消费者是否成功处理消息，RabbitMQ提供了消费者确认机制（<strong>Consumer Acknowledgement</strong>）。即：当消费者处理消息结束后，应该向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态。回执有三种可选值：</p><ul><li>ack：成功处理消息，RabbitMQ从队列中删除该消息</li><li>nack：消息处理失败，RabbitMQ需要再次投递消息</li><li>reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息</li></ul><p>一般reject方式用的较少，除非是消息格式有问题，那就是开发问题了。因此大多数情况下我们需要将消息处理的代码通过<code>try catch</code>机制捕获，消息处理成功时返回ack，处理失败时返回nack.</p><p>由于消息回执的处理代码比较统一，因此SpringAMQP帮我们实现了消息确认。并允许我们通过配置文件设置ACK处理方式，有三种模式：</p><ul><li><code>**none**</code>：不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。非常不安全，不建议使用</li><li><code>**manual**</code>：手动模式。需要自己在业务代码中调用api，发送<code>ack</code>或<code>reject</code>，存在业务入侵，但更灵活</li><li><code>**auto**</code>：自动模式。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回<code>ack</code>.  当业务出现异常时，根据异常判断返回不同结果：<ul><li>如果是<strong>业务异常</strong>，会自动返回<code>nack</code>；</li><li>如果是<strong>消息处理或校验异常</strong>，自动返回<code>reject</code>;</li></ul></li></ul><p>返回Reject的常见异常有：</p><blockquote><p>Starting with version 1.3.2, the default ErrorHandler is now a ConditionalRejectingErrorHandler that rejects (and does not requeue) messages that fail with an irrecoverable error. Specifically, it rejects messages that fail with the following errors:</p><ul><li>o.s.amqp…MessageConversionException: Can be thrown when converting the incoming message payload using a MessageConverter.</li><li>o.s.messaging…MessageConversionException: Can be thrown by the conversion service if additional conversion is required when mapping to a @RabbitListener method.</li><li>o.s.messaging…MethodArgumentNotValidException: Can be thrown if validation (for example, @Valid) is used in the listener and the validation fails.</li><li>o.s.messaging…MethodArgumentTypeMismatchException: Can be thrown if the inbound message was converted to a type that is not correct for the target method. For example, the parameter is declared as Message<Foo> but Message<Bar> is received.</li><li>java.lang.NoSuchMethodException: Added in version 1.6.3.</li><li>java.lang.ClassCastException: Added in version 1.6.3.</li></ul></blockquote><p>通过下面的配置可以修改SpringAMQP的ACK处理方式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">none</span> <span class="comment"># 不做处理</span></span><br></pre></td></tr></table></figure><p>修改consumer服务的SpringRabbitListener类中的方法，模拟一个消息处理的异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MessageConversionException</span>(<span class="string">&quot;故意的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;消息处理完成&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试可以发现：当消息处理发生异常时，消息依然被RabbitMQ删除了。</p><p>我们再次把确认机制修改为auto：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span> <span class="comment"># 自动ack</span></span><br></pre></td></tr></table></figure><p>在异常位置打断点，再次发送消息，程序卡在断点时，可以发现此时消息状态为<code>unacked</code>（未确定状态）：<br><img src="../assets/rabbitmq/1687489262801-36725872-cc98-470a-ab6b-85cfd9c1b0ce_2.png" alt="image.png"><br>放行以后，由于抛出的是<strong>消息转换异常</strong>，因此Spring会自动返回<code>reject</code>，所以消息依然会被删除：<br><img src="../assets/rabbitmq/1687490335196-66d14c99-45c2-4113-8a36-94e33c3ce7d5_1.png" alt="image.png"></p><p>我们将异常改为RuntimeException类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.info(<span class="string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;故意的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;消息处理完成&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在异常位置打断点，然后再次发送消息测试，程序卡在断点时，可以发现此时消息状态为<code>unacked</code>（未确定状态）：<br><img src="../assets/rabbitmq/1687489262801-36725872-cc98-470a-ab6b-85cfd9c1b0ce_1_1.png" alt="image.png">放行以后，由于抛出的是业务异常，所以Spring返回<code>ack</code>，最终消息恢复至<code>Ready</code>状态，并且没有被RabbitMQ删除：<br><img src="../assets/rabbitmq/1687490819965-f638194b-f956-4ad3-8cd4-2e03f5e43674_1.png" alt="image.png"><br>当我们把配置改为<code>auto</code>时，消息处理失败后，会回到RabbitMQ，并重新投递到消费者。</p><h2 id="8-2-失败重试机制">8.2.失败重试机制</h2><p>当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次requeue到队列，再次投递，直到消息处理成功为止。<br>极端情况就是消费者一直无法执行成功，那么消息requeue就会无限循环，导致mq的消息处理飙升，带来不必要的压力：<br><img src="../assets/rabbitmq/1687490923673-6eca30c4-4cd0-4a92-b6d4-2766c0ad1746_1.png" alt="image.png"></p><p>当然，上述极端情况发生的概率还是非常低的，不过不怕一万就怕万一。为了应对上述情况Spring又提供了消费者失败重试机制：在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列。</p><p>修改consumer服务的application.yml文件，添加内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure><p>重启consumer服务，重复之前的测试。可以发现：</p><ul><li>消费者在失败后消息没有重新回到MQ无限重新投递，而是在本地重试了3次</li><li>本地重试3次以后，抛出了<code>AmqpRejectAndDontRequeueException</code>异常。查看RabbitMQ控制台，发现消息被删除了，说明最后SpringAMQP返回的是<code>reject</code></li></ul><p>结论：</p><ul><li>开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试</li><li>重试达到最大次数后，Spring会返回reject，消息会被丢弃</li></ul><h2 id="8-3-失败处理策略">8.3.失败处理策略</h2><p>在之前的测试中，本地测试达到最大重试次数后，消息会被丢弃。这在某些对于消息可靠性要求较高的业务场景下，显然不太合适了。<br>因此Spring允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由<code>MessageRecovery</code>接口来定义的，它有3个不同实现：</p><ul><li><code>RejectAndDontRequeueRecoverer</code>：重试耗尽后，直接<code>reject</code>，丢弃消息。默认就是这种方式</li><li><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，返回<code>nack</code>，消息重新入队</li><li><code>RepublishMessageRecoverer</code>：重试耗尽后，将失败消息投递到指定的交换机</li></ul><p>比较优雅的一种处理方案是<code>RepublishMessageRecoverer</code>，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。</p><p>1）在consumer服务中定义处理失败消息的交换机和队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）定义一个RepublishMessageRecoverer，关联队列和交换机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.DirectExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.retry.MessageRecoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.retry.RepublishMessageRecoverer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;spring.rabbitmq.listener.simple.retry.enabled&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorMessageConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-4-业务幂等性">8.4.业务幂等性</h2><p>何为幂等性？<br><strong>幂等</strong>是一个数学概念，用函数表达式来描述是这样的：<code>f(x) = f(f(x))</code>，例如求绝对值函数。<br>在程序开发中，则是指同一个业务，执行一次或多次对业务状态的影响是一致的。例如：</p><ul><li>根据id删除数据</li><li>查询数据</li><li>新增数据</li></ul><p>但数据的更新往往不是幂等的，如果重复执行可能造成不一样的后果。比如：</p><ul><li>取消订单，恢复库存的业务。如果多次恢复就会出现库存重复增加的情况</li><li>退款业务。重复退款对商家而言会有经济损失。</li></ul><p>所以，我们要尽可能避免业务被重复执行。<br>然而在实际业务场景中，由于意外经常会出现业务被重复执行的情况，例如：</p><ul><li>页面卡顿时频繁刷新导致表单重复提交</li><li>服务间调用的重试</li><li>MQ消息的重复投递</li></ul><p>我们在用户支付成功后会发送MQ消息到交易服务，修改订单状态为已支付，就可能出现消息重复投递的情况。如果消费者不做判断，很有可能导致消息被消费多次，出现业务故障。<br>举例：</p><ol><li>假如用户刚刚支付完成，并且投递消息到交易服务，交易服务更改订单为<strong>已支付</strong>状态。</li><li>由于某种原因，例如网络故障导致生产者没有得到确认，隔了一段时间后<strong>重新投递</strong>给交易服务。</li><li>但是，在新投递的消息被消费之前，用户选择了退款，将订单状态改为了<strong>已退款</strong>状态。</li><li>退款完成后，新投递的消息才被消费，那么订单状态会被再次改为<strong>已支付</strong>。业务异常。</li></ol><p>因此，我们必须想办法保证消息处理的幂等性。这里给出两种方案：</p><ul><li>唯一消息ID</li><li>业务状态判断</li></ul><h3 id="8-4-1-唯一消息ID">8.4.1.唯一消息ID</h3><p>这个思路非常简单：</p><ol><li>每一条消息都生成一个唯一的id，与消息一起投递给消费者。</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</li></ol><p>我们该如何给消息添加唯一ID呢？<br>其实很简单，SpringAMQP的MessageConverter自带了MessageID的功能，我们只要开启这个功能即可。<br>以Jackson的消息转换器为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jjmc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jjmc.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jjmc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-2-业务判断">8.4.2.业务判断</h3><p>业务判断就是基于业务本身的逻辑或状态来判断是否是重复的请求或消息，不同的业务场景判断的思路也不一样。<br>例如我们当前案例中，处理消息的业务逻辑是把订单状态从未支付修改为已支付。因此我们就可以在执行业务时判断订单状态是否是未支付，如果不是则证明订单已经被处理过，无需重复处理。</p><p>相比较而言，消息ID的方案需要改造原有的数据库，所以我更推荐使用业务判断的方案。</p><p>以支付修改订单的业务为例，我们需要修改<code>OrderServiceImpl</code>中的<code>markOrderPaySuccess</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markOrderPaySuccess</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">old</span> <span class="operator">=</span> getById(orderId);</span><br><span class="line">    <span class="comment">// 2.判断订单状态</span></span><br><span class="line">    <span class="keyword">if</span> (old == <span class="literal">null</span> || old.getStatus() != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 订单不存在或者订单状态不是1，放弃处理</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.尝试更新订单</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    order.setId(orderId);</span><br><span class="line">    order.setStatus(<span class="number">2</span>);</span><br><span class="line">    order.setPayTime(LocalDateTime.now());</span><br><span class="line">    updateById(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码逻辑上符合了幂等判断的需求，但是由于判断和更新是两步动作，因此在极小概率下可能存在线程安全问题。</p><p>我们可以合并上述操作为这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markOrderPaySuccess</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">    <span class="comment">// UPDATE `order` SET status = ? , pay_time = ? WHERE id = ? AND status = 1</span></span><br><span class="line">    lambdaUpdate()</span><br><span class="line">            .set(Order::getStatus, <span class="number">2</span>)</span><br><span class="line">            .set(Order::getPayTime, LocalDateTime.now())</span><br><span class="line">            .eq(Order::getId, orderId)</span><br><span class="line">            .eq(Order::getStatus, <span class="number">1</span>)</span><br><span class="line">            .update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看，上述代码等同于这样的SQL语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `<span class="keyword">order</span>` <span class="keyword">SET</span> status <span class="operator">=</span> ? , pay_time <span class="operator">=</span> ? <span class="keyword">WHERE</span> id <span class="operator">=</span> ? <span class="keyword">AND</span> status <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们在where条件中除了判断id以外，还加上了status必须为1的条件。如果条件不符（说明订单已支付），则SQL匹配不到数据，根本不会执行。</p><h2 id="8-5-兜底方案">8.5.兜底方案</h2><p>虽然我们利用各种机制尽可能增加了消息的可靠性，但也不好说能保证消息100%的可靠。万一真的MQ通知失败该怎么办呢？<br>有没有其它兜底方案，能够确保订单的支付状态一致呢？</p><p>其实思想很简单：既然MQ通知不一定发送到交易服务，那么交易服务就必须自己<strong>主动去查询</strong>支付状态。这样即便支付服务的MQ通知失败，我们依然能通过主动查询来保证订单状态的一致。<br>流程如下：<br><img src="../assets/rabbitmq/1687521150465-25b54b36-b64a-4b2d-90b7-8dff12fb075b_1.jpeg" alt=""></p><p>图中黄色线圈起来的部分就是MQ通知失败后的兜底处理方案，由交易服务自己主动去查询支付状态。</p><p>不过需要注意的是，交易服务并不知道用户会在什么时候支付，如果查询的时机不正确（比如查询的时候用户正在支付中），可能查询到的支付状态也不正确。<br>那么问题来了，我们到底该在什么时间主动查询支付状态呢？</p><p>这个时间是无法确定的，因此，通常我们采取的措施就是利用<strong>定时任务</strong>定期查询，例如每隔20秒就查询一次，并判断支付状态。如果发现订单已经支付，则立刻更新订单状态为已支付即可。<br>定时任务大家之前学习过，具体的实现这里就不再赘述了。</p><p>至此，消息可靠性的问题已经解决了。</p><p>综上，支付服务与交易服务之间的订单状态一致性是如何保证的？</p><ul><li>首先，支付服务会正在用户支付成功以后利用MQ消息通知交易服务，完成订单状态同步。</li><li>其次，为了保证MQ消息的可靠性，我们采用了生产者确认机制、消费者确认、消费者失败重试等策略，确保消息投递的可靠性</li><li>最后，我们还在交易服务设置了定时任务，定期查询订单支付状态。这样即便MQ通知失败，还可以利用定时任务作为兜底方案，确保订单支付状态的最终一致性。</li></ul><h1>9.延迟消息</h1><p>在电商的支付业务中，对于一些库存有限的商品，为了更好的用户体验，通常都会在用户下单时立刻扣减商品库存。例如电影院购票、高铁购票，下单后就会锁定座位资源，其他人无法重复购买。</p><p>但是这样就存在一个问题，假如用户下单后一直不付款，就会一直占有库存资源，导致其他客户无法正常交易，最终导致商户利益受损！</p><p>因此，电商中通常的做法就是：<strong>对于超过一定时间未支付的订单，应该立刻取消订单并释放占用的库存</strong>。</p><p>例如，订单支付超时时间为30分钟，则我们应该在用户下单后的第30分钟检查订单支付状态，如果发现未支付，应该立刻取消订单，释放库存。</p><p>但问题来了：如何才能准确的实现在下单后第30分钟去检查支付状态呢？</p><p>像这种在一段时间以后才执行的任务，我们称之为<strong>延迟任务</strong>，而要实现延迟任务，最简单的方案就是利用MQ的延迟消息了。</p><p>在RabbitMQ中实现延迟消息也有两种方案：</p><ul><li>死信交换机+TTL</li><li>延迟消息插件</li></ul><p>这一章我们就一起研究下这两种方案的实现方式，以及优缺点。</p><h2 id="9-1-死信交换机和延迟消息">9.1.死信交换机和延迟消息</h2><p>首先我们来学习一下基于死信交换机的延迟消息方案。</p><h3 id="9-1-1-死信交换机">9.1.1.死信交换机</h3><p>什么是死信？</p><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用<code>basic.reject</code>或 <code>basic.nack</code>声明消费失败，并且消息的<code>requeue</code>参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><p>如果一个队列中的消息已经成为死信，并且这个队列通过<code>**dead-letter-exchange**</code>属性指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机就称为<strong>死信交换机</strong>（Dead Letter Exchange）。而此时加入有队列与死信交换机绑定，则最终死信就会被投递到这个队列中。</p><p>死信交换机有什么作用呢？</p><ol><li>收集那些因处理失败而被拒绝的消息</li><li>收集那些因队列满了而被拒绝的消息</li><li>收集因TTL（有效期）到期的消息</li></ol><h3 id="9-1-2-延迟消息">9.1.2.延迟消息</h3><p>前面两种作用场景可以看做是把死信交换机当做一种消息处理的最终兜底方案，与消费者重试时讲的<code>RepublishMessageRecoverer</code>作用类似。</p><p>而最后一种场景，大家设想一下这样的场景：<br>如图，有一组绑定的交换机（<code>ttl.fanout</code>）和队列（<code>ttl.queue</code>）。但是<code>ttl.queue</code>没有消费者监听，而是设定了死信交换机<code>hmall.direct</code>，而队列<code>direct.queue1</code>则与死信交换机绑定，RoutingKey是blue：<br><img src="../assets/rabbitmq/1687573175803-41a1c870-93bc-4307-974f-891de1b5a42d_1.png" alt="image.png"></p><p>假如我们现在发送一条消息到<code>ttl.fanout</code>，RoutingKey为blue，并设置消息的<strong>有效期</strong>为5000毫秒：<br><img src="../assets/rabbitmq/1687573506181-f0af9da1-0b0b-4cfb-afca-f5febb306cdf_1.png" alt="image.png"><br>:::warning<br><strong>注意</strong>：尽管这里的<code>ttl.fanout</code>不需要RoutingKey，但是当消息变为死信并投递到死信交换机时，会沿用之前的RoutingKey，这样<code>hmall.direct</code>才能正确路由消息。<br>:::</p><p>消息肯定会被投递到<code>ttl.queue</code>之后，由于没有消费者，因此消息无人消费。5秒之后，消息的有效期到期，成为死信：<br><img src="../assets/rabbitmq/1687573747592-4d95dbb1-3f4d-4174-af24-124cb1346a81_1.png" alt="image.png"><br>死信被再次投递到死信交换机<code>hmall.direct</code>，并沿用之前的RoutingKey，也就是<code>blue</code>：<br><img src="../assets/rabbitmq/1687573874094-ebf781c1-6273-474b-b0ed-17243d8370ae_1.png" alt="image.png"><br>由于<code>direct.queue1</code>与<code>hmall.direct</code>绑定的key是blue，因此最终消息被成功路由到<code>direct.queue1</code>，如果此时有消费者与<code>direct.queue1</code>绑定， 也就能成功消费消息了。但此时已经是5秒钟以后了：<br><img src="../assets/rabbitmq/1687574086294-106fe14b-6652-4783-a6c3-3d722d1f5232_1.png" alt="image.png"><br>也就是说，publisher发送了一条消息，但最终consumer在5秒后才收到消息。我们成功实现了<strong>延迟消息</strong>。</p><h3 id="9-1-3-总结">9.1.3.总结</h3><p>:::warning<br><strong>注意：</strong><br>RabbitMQ的消息过期是基于追溯方式来实现的，也就是说当一个消息的TTL到期以后不一定会被移除或投递到死信交换机，而是在消息恰好处于队首时才会被处理。<br>当队列中消息堆积很多的时候，过期消息可能不会被按时处理，因此你设置的TTL时间不一定准确。<br>:::</p><h2 id="9-2-DelayExchange插件">9.2.DelayExchange插件</h2><p>基于死信队列虽然可以实现延迟消息，但是太麻烦了。因此RabbitMQ社区提供了一个延迟消息插件来实现相同的效果。<br>官方文档说明：<br><a href="https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq">Scheduling Messages with RabbitMQ | RabbitMQ - Blog</a></p><h3 id="9-2-1-下载">9.2.1.下载</h3><p>插件下载地址：<br><a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">GitHub - rabbitmq/rabbitmq-delayed-message-exchange: Delayed Messaging for RabbitMQ</a><br>由于我们安装的MQ是<code>3.8</code>版本，因此这里下载<code>3.8.17</code>版本：<br><img src="../assets/rabbitmq/1687576610561-71355772-460c-4b7a-bf71-904b40bccdf9_1.png" alt="image.png"><br>当然，也可以直接使用课前资料提供好的插件：<br><img src="../assets/rabbitmq/1687611117405-f30b7216-cbef-44fc-a8a9-b62c50ef2a06_1.png" alt="image.png"></p><h3 id="9-2-2-安装">9.2.2.安装</h3><p>因为我们是基于Docker安装，所以需要先查看RabbitMQ的插件目录对应的数据卷。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect mq-plugins</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2024-06-19T09:22:59+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/mq-plugins/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;mq-plugins&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>插件目录被挂载到了<code>/var/lib/docker/volumes/mq-plugins/_data</code>这个目录，我们上传插件到该目录下。</p><p>接下来执行命令，安装插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img src="../assets/rabbitmq/1687576988700-43b5d4ad-a77c-4463-bea4-4f3c0888ebe5_1.png" alt="image.png"></p><h3 id="9-2-3-声明延迟交换机">9.2.3.声明延迟交换机</h3><p>基于注解方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayMessage</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到delay.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于<code>@Bean</code>的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.consumer.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayExchangeConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">delayExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">                .directExchange(<span class="string">&quot;delay.direct&quot;</span>) <span class="comment">// 指定交换机类型和名称</span></span><br><span class="line">                .delayed() <span class="comment">// 设置delay的属性为true</span></span><br><span class="line">                .durable(<span class="literal">true</span>) <span class="comment">// 持久化</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;delay.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delayQueueBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue()).to(delayExchange()).with(<span class="string">&quot;delay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9-2-4-发送延迟消息">9.2.4.发送延迟消息</h3><p>发送消息时，必须通过x-delay属性设定延迟时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherDelayMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, delayed message&quot;</span>;</span><br><span class="line">    <span class="comment">// 2.发送消息，利用消息后置处理器添加消息头</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;delay&quot;</span>, message, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">            <span class="comment">// 添加延迟消息属性</span></span><br><span class="line">            message.getMessageProperties().setDelay(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>:::warning<br><strong>注意：</strong><br>延迟消息插件内部会维护一个本地数据库表，同时使用Elang Timers功能实现计时。如果消息的延迟时间设置较长，可能会导致堆积的延迟消息非常多，会带来较大的CPU开销，同时延迟消息的时间会存在误差。<br>因此，<strong>不建议设置延迟时间过长的延迟消息</strong>。<br>:::</p><h2 id="9-5-订单状态同步问题">9.5.订单状态同步问题</h2><p>接下来，我们就在交易服务中利用延迟消息实现订单支付状态的同步。其大概思路如下：<br><img src="../assets/rabbitmq/1690343275577-b0f99b4a-40e2-40cf-8da2-11f0dfbd7d7c_1.jpeg" alt=""></p><p>假如订单超时支付时间为30分钟，理论上说我们应该在下单时发送一条延迟消息，延迟时间为30分钟。这样就可以在接收到消息时检验订单支付状态，关闭未支付订单。<br>但是大多数情况下用户支付都会在1分钟内完成，我们发送的消息却要在MQ中停留30分钟，额外消耗了MQ的资源。因此，我们最好多检测几次订单支付状态，而不是在最后第30分钟才检测。<br>例如：我们在用户下单后的第10秒、20秒、30秒、45秒、60秒、1分30秒、2分、…30分分别设置延迟消息，如果提前发现订单已经支付，则后续的检测取消即可。<br>这样就可以有效避免对MQ资源的浪费了。</p><p>优化后的实现思路如下：<br><img src="../assets/rabbitmq/1687593452790-58e296b7-0761-40f6-b4be-9c19bff9cd3e_1.jpeg" alt=""></p><p>由于我们要多次发送延迟消息，因此需要先定义一个记录消息延迟时间的消息体，处于通用性考虑，我们将其定义到<code>hm-common</code>模块下：<br><img src="../assets/rabbitmq/1687593306116-2a41b7c0-064c-463f-b109-fa05db8609e8_1.png" alt="image.png"><br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.common.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.common.utils.CollUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiDelayMessage</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录延迟时间的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Long&gt; delayMillis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MultiDelayMessage</span><span class="params">(T data, List&lt;Long&gt; delayMillis)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.delayMillis = delayMillis;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; MultiDelayMessage&lt;T&gt; <span class="title function_">of</span><span class="params">(T data, Long ... delayMillis)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MultiDelayMessage</span>&lt;&gt;(data, CollUtils.newArrayList(delayMillis));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取并移除下一个延迟时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 队列中的第一个延迟时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">removeNextDelay</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> delayMillis.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否还有下一个延迟时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNextDelay</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !delayMillis.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9-5-1-定义常量">9.5.1.定义常量</h3><p>无论是消息发送还是接收都是在交易服务完成，因此我们在<code>trade-service</code>中定义一个常量类，用于记录交换机、队列、RoutingKey等常量：<br><img src="../assets/rabbitmq/1687593919687-52eb9aa6-6f80-4b49-ba32-bb608018e333_1.png" alt="image.png"><br>内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.trade.constants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MqConstants</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;trade.delay.topic&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_ORDER_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;trade.order.delay.queue&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">DELAY_ORDER_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;order.query&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-5-2-抽取共享mq配置">9.5.2.抽取共享mq配置</h3><p>我们将mq的配置抽取到nacos中，方便各个微服务共享配置。<br>在nacos中定义一个名为<code>shared-mq.xml</code>的配置文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">$&#123;hm.mq.host:192.168.150.101&#125;</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">$&#123;hm.mq.port:5672&#125;</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">$&#123;hm.mq.vhost:/hmall&#125;</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">$&#123;hm.mq.un:hmall&#125;</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;hm.mq.pw:123&#125;</span> <span class="comment"># 密码</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p>这里只添加一些基础配置，至于生产者确认，消费者确认配置则由微服务根据业务自己决定。</p><p>在<code>trade-service</code>模块添加共享配置：<br><img src="../assets/rabbitmq/1687595291593-378450c1-ef00-4cbf-9be8-235d1eea8e7c_1.png" alt="image.png"></p><h3 id="9-5-3-改造下单业务">9.5.3.改造下单业务</h3><p>接下来，我们改造下单业务，在下单完成后，发送延迟消息，查询支付状态。</p><p>1）引入依赖<br>在<code>trade-service</code>模块的<code>pom.xml</code>中引入amqp的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--amqp--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）改造下单业务<br>修改<code>trade-service</code>模块的<code>com.hmall.trade.service.impl.OrderServiceImpl</code>类的<code>createOrder</code>方法，添加消息发送的代码：<br><img src="../assets/rabbitmq/1687595921876-005c46d9-4278-411b-bfc1-c5e545949cd5_1.png" alt="image.png"></p><h3 id="9-5-4-编写查询支付状态接口">9.5.4.编写查询支付状态接口</h3><p>由于MQ消息处理时需要查询支付状态，因此我们要在pay-service模块定义一个这样的接口，并提供对应的FeignClient.<br>首先，在hm-api模块定义三个类：<br><img src="../assets/rabbitmq/1690352506454-23b445b7-3a34-458e-bba2-47528a06ea65_1.png" alt="image.png"><br>说明：</p><ul><li>PayOrderDTO：支付单的数据传输实体</li><li>PayClient：支付系统的Feign客户端</li><li>PayClientFallback：支付系统的fallback逻辑</li></ul><p>PayOrderDTO代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 支付订单</span></span><br><span class="line"><span class="comment"> * &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;支付单数据传输实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayOrderDTO</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;业务订单号&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long bizOrderNo;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付单号&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long payOrderNo;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付用户id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long bizUserId;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付渠道编码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String payChannelCode;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付金额，单位分&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer amount;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;付类型，1：h5,2:小程序，3：公众号，4：扫码，5：余额支付&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer payType;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;付状态，0：待提交，1:待支付，2：支付超时或取消，3：支付成功&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;拓展字段，用于传递不同渠道单独处理的字段&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String expandJson;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;第三方返回业务码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String resultCode;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;第三方返回提示信息&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String resultMsg;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付成功时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime paySuccessTime;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付超时时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime payOverTime;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;支付二维码链接&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String qrCodeUrl;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;创建时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;更新时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>PayClient代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.fallback.PayClientFallback;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.dto.PayOrderDTO;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;pay-service&quot;, fallbackFactory = PayClientFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PayClient</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据交易订单id查询支付单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 业务订单id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 支付单信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/pay-orders/biz/&#123;id&#125;&quot;)</span></span><br><span class="line">    PayOrderDTO <span class="title function_">queryPayOrderByBizOrderNo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PayClientFallback代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.api.client.fallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.PayClient;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.dto.PayOrderDTO;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FallbackFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayClientFallback</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;PayClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PayClient <span class="title function_">create</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PayClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> PayOrderDTO <span class="title function_">queryPayOrderByBizOrderNo</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后，在pay-service模块的PayController中实现该接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;根据id查询支付单&quot;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/biz/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> PayOrderDTO <span class="title function_">queryPayOrderByBizOrderNo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>&#123;</span><br><span class="line">    <span class="type">PayOrder</span> <span class="variable">payOrder</span> <span class="operator">=</span> payOrderService.lambdaQuery().eq(PayOrder::getBizOrderNo, id).one();</span><br><span class="line">    <span class="keyword">return</span> BeanUtils.copyBean(payOrder, PayOrderDTO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-5-5-消息监听">9.5.5.消息监听</h3><p>接下来，我们在trader-service编写一个监听器，监听延迟消息，查询订单支付状态：<br><img src="../assets/rabbitmq/1690343618777-60200e66-3734-439b-91fe-db8ea3eba148_1.png" alt="image.png"><br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.trade.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hmall.api.client.PayClient;</span><br><span class="line"><span class="keyword">import</span> com.hmall.api.dto.PayOrderDTO;</span><br><span class="line"><span class="keyword">import</span> com.hmall.common.domain.MultiDelayMessage;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.constants.MqConstants;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.domain.po.Order;</span><br><span class="line"><span class="keyword">import</span> com.hmall.trade.service.IOrderService;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.ExchangeTypes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderStatusListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IOrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PayClient payClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = MqConstants.DELAY_ORDER_QUEUE, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = MqConstants.DELAY_EXCHANGE, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">            key = MqConstants.DELAY_ORDER_ROUTING_KEY</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenOrderCheckDelayMessage</span><span class="params">(MultiDelayMessage&lt;Long&gt; msg)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取消息中的订单id</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> msg.getData();</span><br><span class="line">        <span class="comment">// 2.查询订单，判断状态：1是未支付，大于1则是已支付或已关闭</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderService.getById(orderId);</span><br><span class="line">        <span class="keyword">if</span> (order == <span class="literal">null</span> || order.getStatus() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 订单不存在或交易已经结束，放弃处理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.可能是未支付，查询支付服务</span></span><br><span class="line">        <span class="type">PayOrderDTO</span> <span class="variable">payOrder</span> <span class="operator">=</span> payClient.queryPayOrderByBizOrderNo(orderId);</span><br><span class="line">        <span class="keyword">if</span> (payOrder != <span class="literal">null</span> &amp;&amp; payOrder.getStatus() == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// 支付成功，更新订单状态</span></span><br><span class="line">            orderService.markOrderPaySuccess(orderId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.确定未支付，判断是否还有剩余延迟时间</span></span><br><span class="line">        <span class="keyword">if</span> (msg.hasNextDelay()) &#123;</span><br><span class="line">            <span class="comment">// 4.1.有延迟时间，需要重发延迟消息，先获取延迟时间的int值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">delayVal</span> <span class="operator">=</span> msg.removeNextDelay().intValue();</span><br><span class="line">            <span class="comment">// 4.2.发送延迟消息</span></span><br><span class="line">            rabbitTemplate.convertAndSend(MqConstants.DELAY_EXCHANGE, MqConstants.DELAY_ORDER_ROUTING_KEY, msg,</span><br><span class="line">                    message -&gt; &#123;</span><br><span class="line">                        message.getMessageProperties().setDelay(delayVal);</span><br><span class="line">                        <span class="keyword">return</span> message;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.没有剩余延迟时间了，说明订单超时未支付，需要取消订单</span></span><br><span class="line">        orderService.cancelOrder(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意，这里要在OrderServiceImpl中实现cancelOrder方法，留作作业大家自行实现。</p><h1>10.作业</h1><h2 id="10-1-取消订单">10.1.取消订单</h2><p>在处理超时未支付订单时，如果发现订单确实超时未支付，最终需要关闭该订单。<br>关闭订单需要完成两件事情：</p><ul><li>将订单状态修改为已关闭</li><li>恢复订单中已经扣除的库存</li></ul><p>这部分功能尚未实现。<br>大家要在<code>IOrderService</code>接口中定义<code>cancelOrder</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">cancelOrder</span><span class="params">(Long orderId)</span>;</span><br></pre></td></tr></table></figure><p>并且在<code>OrderServiceImpl</code>中实现该方法。实现过程中要注意业务幂等性判断。</p><h2 id="10-2-抽取MQ工具">10.2.抽取MQ工具</h2><p>MQ在企业开发中的常见应用我们就学习完毕了，除了收发消息以外，消息可靠性的处理、生产者确认、消费者确认、延迟消息等等编码还是相对比较复杂的。<br>因此，我们需要将这些常用的操作封装为工具，方便在项目中使用。要求如下：</p><ul><li>在<code>hm-commom</code>模块下编写发送消息的工具类<code>RabbitMqHelper</code></li><li>定义一个自动配置类<code>MqConsumeErrorAutoConfiguration</code>，内容包括：<ul><li>声明一个交换机，名为<code>error.direct</code>，类型为<code>direct</code></li><li>声明一个队列，名为：<code>微服务名 + error.queue</code>，也就是说要动态获取</li><li>将队列与交换机绑定，绑定时的<code>RoutingKey</code>就是<code>微服务名</code></li><li>声明<code>RepublishMessageRecoverer</code>，消费失败消息投递到上述交换机</li><li>给配置类添加条件，当<code>spring.rabbitmq.listener.simple.retry.enabled</code>为<code>true</code>时触发</li></ul></li></ul><p>RabbitMqHelper的结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqHelper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String exchange, String routingKey, Object msg)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDelayMessage</span><span class="params">(String exchange, String routingKey, Object msg, <span class="type">int</span> delay)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessageWithConfirm</span><span class="params">(String exchange, String routingKey, Object msg, <span class="type">int</span> maxRetries)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-3-改造业务">10.3.改造业务</h2><p>利用你编写的工具，改造支付服务、购物车服务、交易服务中消息发送功能，并且添加消息确认或消费者重试机制，确保消息的可靠性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>导航：</strong></p><p><a href="https://blog.csdn.net/qq_40991313/article/details/126646289?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22126646289%22%2C%22source%22%3A%22qq_40991313%22%7D" title="【Java笔记+踩坑汇总】Java基础+JavaWeb+SSM+SpringBoot+SpringCloud+瑞吉外卖/谷粒商城/学成在线+设计模式+面试题汇总+性能调优/架构设计+源码解析">【Java笔记+踩坑汇总】Java基础+JavaWeb+SSM+SpringBoot+SpringCloud+瑞吉外卖/谷粒商城/学成在线+设计模式+面试题汇总+性能调优/架构设计+源码解析</a></p><p><strong>黑马旅游源码：</strong></p><p>GitHub：</p><p><a href="https://github.com/vincewm/hotel" title="GitHub - vincewm/hotel: 黑马旅游项目">GitHub - vincewm/hotel: 黑马旅游项目</a></p><p>Gitee：</p><p><a href="https://gitee.com/vincewm/hotel" title="hotel: 黑马旅游项目">hotel: 黑马旅游项目</a></p></blockquote><p><strong>目录</strong></p><p>1.数据聚合</p><p>1.1.聚合的种类</p><p>1.2.DSL实现聚合</p><p>1.2.1.Bucket聚合语法</p><p>1.2.2.聚合结果排序</p><p>1.2.3.通过query标签限定聚合范围</p><p>1.2.4.度量聚合语法，stats</p><p>1.2.5.小结，聚合三要素</p><p>1.3.RestAPI实现聚合</p><p>1.3.1.API语法</p><p>1.3.2.黑马旅游业务需求，标签随着搜索结果变化</p><p>1.3.3.业务实现</p><p>2.自动补全</p><p>2.1.pinyin拼音分词器的介绍和安装</p><p>2.2.自定义分词器，ik+拼音过滤</p><p>2.2.1 实现方法</p><p>2.2.2 索引分词器和搜索分词器问题</p><p>2.3.自动补全查询，conmpetion suggester</p><p>2.4.实现酒店搜索框自动补全</p><p>2.4.1.创建新索引库，使用自定义分词器</p><p>2.4.2.HotelDoc实体类添加suggestion字段</p><p>2.4.3.重新导入MySQL数据到es索引库</p><p>2.4.4 测试补全，suggest搜索&quot;rj&quot;结果“如家”的文档</p><p>2.4.5.自动补全查询的JavaAPI，SuggestBuilder()</p><p>2.4.6.实现旅游项目搜索框自动补全</p><p>3.mysql与es数据同步</p><p>3.1.思路分析</p><p>3.1.1.方案一：同步调用</p><p>3.1.2.方案二：异步通知</p><p>3.1.3.方案三：canal监听mysql的binlog</p><p>3.1.4.三种方案优缺点总结</p><p>3.2.MQ实现数据同步</p><p>3.2.1.思路</p><p>3.2.2.导入hotel-admin后台管理端、修改pom和yml</p><p>3.2.3.声明交换机、队列</p><p>3.2.4.后台端发送MQ消息</p><p>3.2.5.用户端接收MQ消息</p><p>3.2.6 测试</p><p>3.2.7.vue插件实现快速拷贝数据到表单</p><p>4.集群</p><p>4.0.概述</p><p>4.1.搭建ES集群</p><p>4.1.0.Docker Compose介绍</p><p>4.1.1.创建es集群</p><p>4.1.2.集群状态监控，安装cerebro</p><p>4.1.3.创建索引库</p><p>4.1.4.查看分片效果</p><p>4.2.集群脑裂问题</p><p>4.2.1.集群职责划分，四种节点类型</p><p>4.2.2.脑裂问题</p><p>4.2.3.小结，四种节点类型</p><p>4.3.集群分布式存储</p><p>4.3.1.文档存储到分片测试</p><p>4.3.2.分片存储原理</p><p>4.4.集群分布式查询，协调节点的分散和聚集</p><p>4.5.集群故障转移</p><hr><h2 id="1-数据聚合">1.数据聚合</h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html" title="聚合（">聚合（</a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html" title="aggregations">aggregations</a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html" title="）">）</a>可以让我们极其方便的实现对数据的统计、分析、运算。例如：</p><ul><li>什么品牌的手机最受欢迎？</li><li>这些手机的平均价格、最高价格、最低价格？</li><li>这些手机每月的销售情况如何？</li></ul><p>实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。</p><h3 id="1-1-聚合的种类">1.1.聚合的种类</h3><p>聚合常见的有三类：</p><ul><li><p><strong>桶（Bucket）聚合：</strong> 用来对文档做分组</p><ul><li>TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组</li><li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li></ul></li><li><p><strong>度量（Metric）聚合</strong> ：用以计算一些值，比如：最大值、最小值、平均值等</p><ul><li>Avg：求平均值</li><li>Max：求最大值</li><li>Min：求最小值</li><li>Stats：同时求max、min、avg、sum等</li></ul></li><li><p><strong>管道（pipeline）聚合：</strong> 其它聚合的结果为基础做聚合</p></li></ul><blockquote><p><strong>注意：参加聚合的字段必须是不能分词</strong> ，例如是keyword、日期、数值、布尔类型</p></blockquote><h3 id="1-2-DSL实现聚合">1.2.DSL实现聚合</h3><p>现在，我们要统计所有数据中的酒店品牌有几种，其实就是按照品牌对数据分组。此时可以根据酒店品牌的名称做聚合，也就是Bucket聚合。</p><h4 id="1-2-1-Bucket聚合语法">1.2.1.Bucket聚合语法</h4><p>语法如下：</p><pre><code>GET /hotel/_search&#123;  &quot;size&quot;: 0,  // 设置size为0，结果中不包含文档，只包含聚合结果。如果设为20，就是既展示20个brand查询的&quot;hits&quot;，又展示聚合&quot;aggregations&quot;  &quot;aggs&quot;: &#123; // 定义聚合    &quot;聚合名&quot;: &#123; //给聚合起个名字，例如brandAgg。查询结果里聚合名会嵌套在&quot;aggregations&quot;里      &quot;terms&quot;: &#123; // 聚合的类型，按照品牌值聚合，所以选择term        &quot;field&quot;: &quot;字段名&quot;, // 参与聚合的字段,例如brand        &quot;size&quot;: 20 // 希望获取的聚合结果数量        &quot;order&quot;: &#123;          &quot;_count&quot;: &quot;asc&quot;        //按升序排序，默认是降序        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><h4 id="1-2-2-聚合结果排序">1.2.2.聚合结果排序</h4><p><strong>默认情况下</strong> ，Bucket聚合会 <strong>统计Bucket内的文档数量</strong> ，记为_count，并且 <strong>按照_count降序</strong> 排序。</p><p>我们可以指定order属性，自定义聚合的排序方式：</p><pre><code>GET /hotel/_search&#123;  &quot;size&quot;: 0,   &quot;aggs&quot;: &#123;    &quot;brandAgg&quot;: &#123;      &quot;terms&quot;: &#123;        &quot;field&quot;: &quot;brand&quot;,        &quot;order&quot;: &#123;          &quot;_count&quot;: &quot;asc&quot; // 按照_count升序排列        &#125;,        &quot;size&quot;: 20              &#125;    &#125;  &#125;&#125;</code></pre><p>结果如图：</p><p><img src="../assets/es/045507ac495058cc953235172ac15caf.png" alt="image-20210723171948228"></p><h4 id="1-2-3-通过query标签限定聚合范围">1.2.3.通过query标签限定聚合范围</h4><p>“query” 标签和“aggs”标签是并列的，“query” 标签不为空就是限定了聚合范围。</p><p>默认情况下，Bucket聚合是对索引库的所有文档做聚合，但真实场景下，用户会输入搜索条件，因此聚合必须是对搜索结果聚合。那么聚合必须添加限定条件。</p><p>我们可以限定要聚合的文档范围，只要添加query条件即可。</p><p><strong>需求：</strong> 只对200元以下的文档聚合</p><pre><code>GET /hotel/_search&#123;  &quot;query&quot;: &#123;    &quot;range&quot;: &#123;      &quot;price&quot;: &#123;        &quot;lte&quot;: 200 // 只对200元以下的文档聚合      &#125;    &#125;  &#125;,   &quot;size&quot;: 0,   &quot;aggs&quot;: &#123;    &quot;brandAgg&quot;: &#123;      &quot;terms&quot;: &#123;        &quot;field&quot;: &quot;brand&quot;,        &quot;size&quot;: 20      &#125;    &#125;  &#125;&#125;</code></pre><p>这次，聚合得到的品牌明显变少了：</p><p><img src="../assets/es/340e991fde6d15a58429560f0412209e.png" alt="image-20210723172404836"></p><h4 id="1-2-4-度量聚合语法，stats">1.2.4.度量聚合语法，stats</h4><p>上节课，我们对酒店按照品牌分组，形成了一个个桶。</p><p><strong>需求：</strong> 现在我们需要 <strong>对桶内的酒店做运算</strong> ，获取每个品牌的用户评分的min、max、avg等值。</p><p>这就要用到Metric聚合了，例如stat聚合：就可以获取min、max、avg等结果。</p><p>语法如下：</p><pre><code>GET /hotel/_search&#123;  &quot;size&quot;: 0,   &quot;aggs&quot;: &#123;    &quot;brandAgg&quot;: &#123;       &quot;terms&quot;: &#123;         &quot;field&quot;: &quot;字段名&quot;,         &quot;size&quot;: 20      &#125;,      &quot;aggs&quot;: &#123; // 是brands聚合的子聚合，也就是分组后对每组分别计算        &quot;聚合名如score_stats&quot;: &#123; // 聚合名称          &quot;stats&quot;: &#123; // 聚合类型，这里stats可以计算min、max、avg等。stats是statistics统计缩写            &quot;field&quot;: &quot;score&quot; // 聚合字段，这里是score          &#125;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><p>这次的score_stats聚合是在brandAgg的聚合内部嵌套的子聚合。因为我们需要在每个桶分别计算。</p><p>我们还可以给聚合结果做个排序，例如按照每个桶的酒店平均分做排序：</p><p><img src="../assets/es/67670e14a5abe5ee6a15071992bc7287.png" alt="image-20210723172917636"></p><h4 id="1-2-5-小结，聚合三要素">1.2.5.小结，聚合三要素</h4><p><strong>aggs代表聚合</strong> ，与query同级， <strong>此时query的作用是？</strong></p><ul><li><strong>限定聚合的的文档范围</strong></li></ul><p><strong>聚合必须的三要素：</strong></p><ul><li>聚合 <strong>名称</strong></li><li>聚合 <strong>类型</strong></li><li>聚合 <strong>字段</strong></li></ul><p><strong>聚合可配置属性有：</strong></p><ul><li>size：指定聚合结果数量</li><li>order：指定聚合结果排序方式</li><li>field：指定聚合字段</li></ul><h3 id="1-3-RestAPI实现聚合">1.3.RestAPI实现聚合</h3><h4 id="1-3-1-API语法">1.3.1.API语法</h4><p><strong>聚合条件与query条件同级别</strong> ，因此需要使用 <strong>request.source()</strong> 来指定聚合条件。</p><p><strong>聚合条件的语法：</strong></p><p><img src="../assets/es/cc3c1fb77cec69792e9f56a43618ebca.png" alt="image-20210723173057733"></p><blockquote><p>注意：request.source().aggregation()， <strong>聚合不是负数</strong> ，因为虽然DSL是&quot;aggs&quot;，但它不是数组，所以不是request.source().aggregations()</p></blockquote><p><strong>聚合结果：</strong></p><p>聚合的结果也与查询结果不同，API也比较特殊。不过同样是JSON逐层解析：</p><p><img src="../assets/es/09d867346a4b6e97ec9b8cd190f27370.png" alt="image-20210723173215728"></p><blockquote><p><strong>注意：</strong> response.getAggregations().get(“brandAgg”)的返回结果要是Terms，注意包别导错了，提示的第一个不是es的包。</p><pre><code>    @Test    public void aggregation()throws IOException&#123;        SearchRequest request = new SearchRequest(&quot;hotel&quot;);        request.source().size(0).aggregation(AggregationBuilders.terms(&quot;brandAgg&quot;).field(&quot;brand&quot;).size(20));        SearchResponse response = client.search(request, RequestOptions.DEFAULT);        Terms brandTerms =response.getAggregations().get(&quot;brandAgg&quot;);        List&lt;? extends Terms.Bucket&gt; buckets = brandTerms.getBuckets();        for(Terms.Bucket bucket:buckets)&#123;            System.out.println(bucket.getKeyAsString()+&quot;:&quot;+bucket.getDocCount());        &#125;    &#125;</code></pre></blockquote><h4 id="1-3-2-黑马旅游业务需求，标签随着搜索结果变化">1.3.2.黑马旅游业务需求，标签随着搜索结果变化</h4><p>需求：搜索页面的品牌、城市等信息不应该是在页面写死，而是通过聚合索引库中的酒店数据得来的：</p><p><img src="../assets/es/23561e3f118c97e32d3ca8f95d65cc4b.png" alt="image-20210723192605566"></p><p><strong>分析：</strong></p><p>目前，页面的城市列表、星级列表、品牌列表都是写死的，并不会 <strong>随着搜索结果的变化而变化</strong> 。但是用户搜索条件改变时，搜索结果会跟着变化。</p><p>例如：用户搜索“东方明珠”，那搜索的酒店肯定是在上海东方明珠附近，因此，城市只能是上海，此时城市列表中就不应该显示北京、深圳、杭州这些信息了。</p><p>也就是说，搜索结果中包含哪些城市，页面就应该列出哪些城市；搜索结果中包含哪些品牌，页面就应该列出哪些品牌。</p><p>如何得知搜索结果中包含哪些品牌？如何得知搜索结果中包含哪些城市？</p><p>使用聚合功能，利用Bucket聚合，对搜索结果中的文档基于品牌分组、基于城市分组，就能得知包含哪些品牌、哪些城市了。</p><p>因为是对搜索结果聚合，因此聚合是 <strong>限定范围的聚合</strong> ，也就是说聚合的限定条件跟搜索文档的条件一致。</p><p>查看浏览器可以发现，前端其实已经发出了这样的一个请求：</p><p><img src="../assets/es/ec59aeb80be4ec00296fa013d20de728.png" alt="image-20210723193730799"></p><p>请求 <strong>参数与搜索文档的参数完全一致</strong> 。</p><p>返回值类型就是页面要展示的最终结果：</p><p><img src="../assets/es/a4e2be53159a29c46a44a6216cc0269c.png" alt="image-20210723203915982"></p><p>结果是一个Map结构：</p><ul><li>key是字符串，城市、星级、品牌、价格</li><li>value是集合，例如多个城市的名称</li></ul><h4 id="1-3-3-业务实现">1.3.3.业务实现</h4><p>在<code>cn.itcast.hotel.web</code>包的<code>HotelController</code>中添加一个方法，遵循下面的要求：</p><ul><li>请求方式：<code>POST</code></li><li>请求路径：<code>/hotel/filters</code></li><li>请求参数：<code>RequestParams</code>，与搜索文档的参数一致</li><li>返回值类型：<code>Map&lt;String, List&lt;String&gt;&gt;</code></li></ul><p>代码：</p><pre><code>    @PostMapping(&quot;filters&quot;)    public Map&lt;String, List&lt;String&gt;&gt; getFilters(@RequestBody RequestParams params)&#123;        return hotelService.getFilters(params);    &#125;</code></pre><p>这里调用了IHotelService中的getFilters方法，尚未实现。</p><p>在<code>cn.itcast.hotel.service.IHotelService</code>中定义新方法：</p><pre><code>Map&lt;String, List&lt;String&gt;&gt; filters(RequestParams params);</code></pre><p>在<code>cn.itcast.hotel.service.impl.HotelServiceImpl</code>中实现该方法：</p><pre><code>@Overridepublic Map&lt;String, List&lt;String&gt;&gt; filters(RequestParams params) &#123;    try &#123;        // 1.准备Request        SearchRequest request = new SearchRequest(&quot;hotel&quot;);        // 2.准备DSL        // 2.1.query查询城市、品牌等基本信息        buildBasicQuery(params, request);        // 2.2.设置size        request.source().size(0);        // 2.3.聚合，根据        buildAggregation(request);        // 3.发出请求        SearchResponse response = client.search(request, RequestOptions.DEFAULT);        // 4.解析结果        Map&lt;String, List&lt;String&gt;&gt; result = new HashMap&lt;&gt;();        Aggregations aggregations = response.getAggregations();        // 4.1.根据品牌名称，获取品牌结果        List&lt;String&gt; brandList = getAggByName(aggregations, &quot;brandAgg&quot;);        result.put(&quot;brand&quot;, brandList);        // 4.2.根据品牌名称，获取品牌结果        List&lt;String&gt; cityList = getAggByName(aggregations, &quot;cityAgg&quot;);        result.put(&quot;city&quot;, cityList);        // 4.3.根据品牌名称，获取品牌结果        List&lt;String&gt; starList = getAggByName(aggregations, &quot;starAgg&quot;);        result.put(&quot;starName&quot;, starList);        return result;    &#125; catch (IOException e) &#123;        throw new RuntimeException(e);    &#125;&#125;//三个聚合，分别聚合品牌、城市、星级private void buildAggregation(SearchRequest request) &#123;    request.source().aggregation(AggregationBuilders                                 .terms(&quot;brandAgg&quot;)                                 .field(&quot;brand&quot;)                                 .size(100)                                );    request.source().aggregation(AggregationBuilders                                 .terms(&quot;cityAgg&quot;)                                 .field(&quot;city&quot;)                                 .size(100)                                );    request.source().aggregation(AggregationBuilders                                 .terms(&quot;starAgg&quot;)                                 .field(&quot;starName&quot;)                                 .size(100)                                );&#125;private List&lt;String&gt; getAggByName(Aggregations aggregations, String aggName) &#123;    // 4.1.根据聚合名称获取聚合结果    Terms brandTerms = aggregations.get(aggName);    // 4.2.获取buckets    List&lt;? extends Terms.Bucket&gt; buckets = brandTerms.getBuckets();    // 4.3.遍历    List&lt;String&gt; brandList = new ArrayList&lt;&gt;();    for (Terms.Bucket bucket : buckets) &#123;        // 4.4.获取key        String key = bucket.getKeyAsString();        brandList.add(key);    &#125;    return brandList;&#125;</code></pre><p>测试：</p><p><img src="../assets/es/56eec2048f5038e0ef201aa5136641e7.png" alt=""></p><h2 id="2-自动补全">2.自动补全</h2><p>当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项，如图：</p><p><img src="../assets/es/06589481cf517964d5623b1688cd4bbc.png" alt="image-20210723204936367"></p><p>这种根据用户输入的字母，提示完整词条的功能，就是自动补全了。</p><p>因为需要根据拼音字母来推断，因此要用到拼音分词功能。</p><h3 id="2-1-pinyin拼音分词器的介绍和安装">2.1.pinyin拼音分词器的介绍和安装</h3><p>要实现根据字母做补全，就必须对文档按照拼音分词。在GitHub上恰好有elasticsearch的拼音分词插件。地址：</p><pre><code>https://github.com/medcl/elasticsearch-analysis-pinyin</code></pre><p><img src="../assets/es/98b8c0c0bac49f3c302b5f97af4fc8f5.png" alt="image-20210723205932746"></p><p>课前资料中也提供了拼音分词器的安装包：</p><p><img src="../assets/es/2ded121c3d2992e01c8368eddae1e7ed.png" alt="image-20210723205722303"></p><p>安装方式与IK分词器一样，分三步：</p><p>​ ①解压</p><p>​ ②上传到虚拟机中，elasticsearch的plugin目录</p><pre><code>/var/lib/docker/volumes/es-plugins/_data</code></pre><p><img src="../assets/es/8a2325af75c981cced6ed1e81d01cd75.png" alt=""></p><p>​ ③重启elasticsearch</p><pre><code>docker restart es</code></pre><p>​ ④测试</p><p>详细安装步骤可以参考IK分词器的安装过程。</p><p>测试用法如下：</p><pre><code>POST /_analyze&#123;  &quot;text&quot;: &quot;如家酒店还不错&quot;,  &quot;analyzer&quot;: &quot;pinyin&quot;&#125;</code></pre><p>结果：</p><p><img src="../assets/es/515dfef704bf5a7816b7dd24784c0a3e.png" alt="image-20210723210126506"></p><h3 id="2-2-自定义分词器，ik-拼音过滤">2.2.自定义分词器，ik+拼音过滤</h3><p>自定义分词器适合在创建索引库时使用，不能在搜索时候用</p><h4 id="2-2-1-实现方法">2.2.1 实现方法</h4><p>默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。</p><p>elasticsearch中分词器（analyzer）的组成包含三部分：</p><ul><li><strong>character filters：</strong> 在tokenizer之前对特 <strong>殊字符进行处理</strong> 。例如删除字符、替换字符</li><li><strong>tokenizer：</strong> 将文本按照一定的 <strong>规则切割成词条（term）</strong> 。例如keyword，就是不分词；还有ik_smart</li><li><strong>tokenizer filter：</strong> 将tokenizer输出的词条做 <strong>进一步处理，tokenizer的词条结果依然在，只是处理后新加了一些</strong> 。例如大小写转换、同义词处理、拼音处理等</li></ul><p><strong>拼音分词器处理文档流程：</strong></p><p><img src="../assets/es/79d3cca99ded3a5ff7cf0d71383ca32d.png" alt="image-20210723210427878"></p><p><strong>自定义分词器，把ik分词结果过滤成拼音：</strong></p><blockquote><p><strong>settings-analysis下定义分词器analyzer和filter</strong></p></blockquote><pre><code>PUT /test&#123;   //设置分词器和过滤器  &quot;settings&quot;: &#123;    &quot;analysis&quot;: &#123;      &quot;analyzer&quot;: &#123; // 自定义分词器        &quot;my_analyzer&quot;: &#123;  // 分词器名称，这里不需要指定character filters过滤器，因为没有特殊字符需要处理          &quot;tokenizer&quot;: &quot;ik_max_word&quot;,          &quot;filter&quot;: &quot;my_py_filter&quot;    //对ik分词结果做进一步处理        &#125;      &#125;,      &quot;filter&quot;: &#123; // 自定义tokenizer filter        &quot;my_py_filter&quot;: &#123; // 过滤器名称          &quot;type&quot;: &quot;pinyin&quot;, // 过滤器类型，填写分词器名，这里是pinyin  &quot;keep_full_pinyin&quot;: false,//eg: 刘德华&gt; [liu,de,hua], default: true          &quot;keep_joined_full_pinyin&quot;: true,//eg: 刘德华&gt; [liudehua], default: false          &quot;keep_original&quot;: true,//保留原始输入，默认false          &quot;limit_first_letter_length&quot;: 16,//          &quot;remove_duplicated_term&quot;: true,//          &quot;none_chinese_pinyin_tokenize&quot;: false// 默认true。eg: liudehuaalibaba13zhuanghan -&gt; liu,de,hua,a,li,ba,ba,13,zhuang,han        &#125;      &#125;    &#125;  &#125;,  //创建索引  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;      &quot;name&quot;: &#123;        &quot;type&quot;: &quot;text&quot;,        &quot;analyzer&quot;: &quot;my_analyzer&quot;,        //拼音分词器适合在创建索引时使用，不能在搜索时候用        &quot;search_analyzer&quot;: &quot;ik_smart&quot;     //如果搜索时用拼音分词器，搜索&quot;狮子爱跳舞&quot;，会搜出&quot;虱子&quot;等同音字      &#125;    &#125;  &#125;&#125;</code></pre><blockquote><p><strong>注意：</strong></p><p><strong>拼音分词器适合在创建索引时使用，不能在搜索时候用</strong> ，如果搜索时用拼音分词器，搜索&quot;狮子爱跳舞&quot;，会搜出&quot;虱子&quot;等同音字。</p></blockquote><p><strong>测试：自定义分词器搜索结果既有ik_smart，还有拼音分词的结果</strong></p><pre><code>GET /test/_analyze&#123;  &quot;analyzer&quot;: &quot;my_analyzer&quot;  , &quot;text&quot;: &quot;今天天气好&quot;&#125;</code></pre><p><img src="../assets/es/046d3e32098bbb5fc838cd8349e798d0.png" alt="image-20210723211829150"></p><h4 id="2-2-2-索引分词器和搜索分词器问题">2.2.2 索引分词器和搜索分词器问题</h4><p>在使用 <strong>ik+拼音过滤</strong> 的分词器时，建议创建的字段的 <strong>索引分词器设为自定义分词器，搜索分词器设为ik分词器。防止搜索时搜出拼音谐音的情况。</strong></p><p><strong>指定索引、搜索分词器，并创建索引：</strong></p><pre><code>PUT /test&#123;   //设置分词器和过滤器  &quot;settings&quot;: &#123;    &quot;analysis&quot;: &#123;      &quot;analyzer&quot;: &#123; // 自定义分词器        &quot;my_analyzer&quot;: &#123;  // 分词器名称，这里不需要指定character filters过滤器，因为没有特殊字符需要处理          &quot;tokenizer&quot;: &quot;ik_max_word&quot;,          &quot;filter&quot;: &quot;my_py_filter&quot;    //对ik分词结果做进一步处理        &#125;      &#125;,      &quot;filter&quot;: &#123; // 自定义tokenizer filter        &quot;my_py_filter&quot;: &#123; // 过滤器名称          &quot;type&quot;: &quot;pinyin&quot;, // 过滤器类型，填写分词器名，这里是pinyin  &quot;keep_full_pinyin&quot;: false,//eg: 刘德华&gt; [liu,de,hua], default: true          &quot;keep_joined_full_pinyin&quot;: true,//eg: 刘德华&gt; [liudehua], default: false          &quot;keep_original&quot;: true,//保留原始输入，默认false          &quot;limit_first_letter_length&quot;: 16,//          &quot;remove_duplicated_term&quot;: true,//          &quot;none_chinese_pinyin_tokenize&quot;: false// 默认true。eg: liudehuaalibaba13zhuanghan -&gt; liu,de,hua,a,li,ba,ba,13,zhuang,han        &#125;      &#125;    &#125;  &#125;,  //创建索引  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;      &quot;name&quot;: &#123;        &quot;type&quot;: &quot;text&quot;,        &quot;analyzer&quot;: &quot;my_analyzer&quot;,        //拼音分词器适合在创建索引时使用，不能在搜索时候用        &quot;search_analyzer&quot;: &quot;ik_smart&quot;     //如果搜索时用拼音分词器，搜索&quot;狮子爱跳舞&quot;，会搜出&quot;虱子&quot;等同音字      &#125;    &#125;  &#125;&#125;</code></pre><p>建议索引分词器设为自定义分词器，搜索分词器设为ik分词器。防止搜索时搜出拼音谐音问题。</p><blockquote><p><strong>问题模拟，索引、搜索都用自定义分词器：</strong></p><pre><code>DELETE /testPUT /test&#123;  &quot;settings&quot;: &#123;    &quot;analysis&quot;: &#123;      &quot;analyzer&quot;: &#123;        &quot;my_analyzer&quot;:&#123;          &quot;tokenizer&quot;:&quot;ik_smart&quot;,          &quot;filter&quot;:&quot;py_filter&quot;        &#125;      &#125;,      &quot;filter&quot;: &#123;        &quot;py_filter&quot;:&#123;          &quot;type&quot;:&quot;pinyin&quot;,          &quot;keep_full_pinyin&quot;: false,          &quot;keep_joined_full_pinyin&quot;: true,          &quot;keep_original&quot;: true,          &quot;limit_first_letter_length&quot;: 16,          &quot;remove_duplicated_term&quot;: true,          &quot;none_chinese_pinyin_tokenize&quot;: false        &#125;      &#125;    &#125;  &#125;,  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;      &quot;name&quot;:&#123;        &quot;type&quot;: &quot;text&quot;,        &quot;analyzer&quot;: &quot;my_analyzer&quot;    //统一ik+拼音过滤      &#125;    &#125;  &#125;&#125;POST /test/_doc/1&#123;  &quot;name&quot;:&quot;狮子&quot;&#125;POST /test/_doc/2&#123;  &quot;name&quot;:&quot;师资&quot;&#125;GET /test/_search&#123;  &quot;query&quot;: &#123;    &quot;match&quot;: &#123;      &quot;name&quot;: &quot;狮子爱跳舞&quot;    &#125;  &#125;&#125;</code></pre><p><img src="../assets/es/f27956135fc37053a66dbf5368254b6f.png" alt=""></p><p>可以看见，明明搜索的是狮子，却搜出了谐音师资。因为搜索“狮子爱跳舞”时，ik+拼音过滤后的结果里有“shizi”，而师资的分词结果也有“shizi”，所以就搜出了师资。</p><p>如果搜索“shizi”，出现结果正常，是狮子和师资。</p></blockquote><p><strong>解决办法：索引分词器设为自定义分词器，搜索分词器设为ik分词器。防止搜索时搜出拼音谐音问题。</strong></p><p>明显不是我们想要的，所以要让它搜索时候只用ik分词，不要拼音过滤就搜不出谐音了，而添加新文档时还要它进行分词拼音，以便于我们可以搜拼音时也能搜出对应字段。</p><pre><code>PUT /test&#123;   //设置分词器和过滤器  &quot;settings&quot;: &#123;     ...自定义分词器  &#125;,  //创建索引  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;      &quot;name&quot;: &#123;        &quot;type&quot;: &quot;text&quot;,        &quot;analyzer&quot;: &quot;my_analyzer&quot;,        //创建文档时自定义分词器，ik+拼音过滤        &quot;search_analyzer&quot;: &quot;ik_smart&quot;     //搜索时只用ik分词器      &#125;    &#125;  &#125;&#125;</code></pre><blockquote><p><strong>总结：</strong></p><p><strong>如何使用拼音分词器？</strong></p><ul><li><p>①下载pinyin分词器</p></li><li><p>②解压并放到elasticsearch的plugin目录</p></li><li><p>③重启即可</p></li></ul></blockquote><blockquote><p><strong>如何自定义分词器？</strong></p><ul><li><p>①创建索引库时，在settings中配置，可以包含三部分</p></li><li><p>②character filter</p></li><li><p>③tokenizer</p></li><li><p>④filter</p></li></ul></blockquote><blockquote><p><strong>拼音分词器注意事项？</strong></p><ul><li><strong>为了避免搜索到同音字，搜索时不要使用拼音分词器</strong></li></ul></blockquote><h3 id="2-3-自动补全查询，conmpetion-suggester">2.3.自动补全查询，conmpetion suggester</h3><p><strong>补全效果预览：</strong> 录入 [“天苍苍”, “野茫茫”]、[“天府”, “天下”]、[“世界”, “黄天”]。suggest搜索“天”，可以搜索出前两个文档。suggest搜索“天苍”，只能搜索出第一个文档。</p><p>elasticsearch提供了<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.6/search-suggesters.html" title="Completion Suggester">Completion Suggester</a>查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：</p><ul><li><p><strong>参与补全查询的字段必须是completion类型，数据是字符串数组。completion译为完成</strong></p></li><li><p><strong>字段的内容</strong> 一般是用来补全的 <strong>多个词条形成的数组</strong> 。</p></li></ul><p><img src="../assets/es/c9c76ec9ecfe3743fc638914e74bee3d.png" alt=""></p><p><strong>创建索引库：</strong></p><pre><code>// 创建索引库PUT test&#123;  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;      &quot;title&quot;:&#123;        &quot;type&quot;: &quot;completion&quot;          &#125;    &#125;  &#125;&#125;</code></pre><p><strong>插入数据：</strong></p><pre><code>// 示例数据POST test/_doc&#123;  &quot;title&quot;: [&quot;天苍苍&quot;, &quot;野茫茫&quot;]&#125;POST test/_doc&#123;  &quot;title&quot;: [&quot;天府&quot;, &quot;天下&quot;]&#125;POST test/_doc&#123;  &quot;title&quot;: [&quot;世界&quot;, &quot;黄天&quot;]&#125;</code></pre><p><strong>自动补全查询：</strong></p><pre><code>// 自动补全查询GET /test/_search&#123;  &quot;suggest&quot;: &#123;    &quot;titleSuggest&quot;: &#123;    //例如自定义查询名称      &quot;text&quot;: &quot;天&quot;, // 关键字      &quot;completion&quot;: &#123;        &quot;field&quot;: &quot;title&quot;, // 补全查询的字段，例如title        &quot;skip_duplicates&quot;: true, // 跳过重复的        &quot;size&quot;: 10 // 获取前10条结果      &#125;    &#125;  &#125;&#125;</code></pre><p><strong>搜索结果：</strong></p><pre><code>&#123;  &quot;took&quot; : 275,  &quot;timed_out&quot; : false,  &quot;_shards&quot; : &#123;    &quot;total&quot; : 1,    &quot;successful&quot; : 1,    &quot;skipped&quot; : 0,    &quot;failed&quot; : 0  &#125;,  &quot;hits&quot; : &#123;    &quot;total&quot; : &#123;      &quot;value&quot; : 0,      &quot;relation&quot; : &quot;eq&quot;    &#125;,    &quot;max_score&quot; : null,    &quot;hits&quot; : [ ]  &#125;,  &quot;suggest&quot; : &#123;    &quot;my_suggest&quot; : [      &#123;        &quot;text&quot; : &quot;天&quot;,        &quot;offset&quot; : 0,        &quot;length&quot; : 1,        &quot;options&quot; : [          &#123;            &quot;text&quot; : &quot;天下&quot;,            &quot;_index&quot; : &quot;test2&quot;,            &quot;_type&quot; : &quot;_doc&quot;,            &quot;_id&quot; : &quot;AEutP4MBg4Wtm5vtyLdE&quot;,            &quot;_score&quot; : 1.0,            &quot;_source&quot; : &#123;              &quot;name&quot; : [                &quot;天府&quot;,                &quot;天下&quot;              ]            &#125;          &#125;,          &#123;            &quot;text&quot; : &quot;天苍苍&quot;,            &quot;_index&quot; : &quot;test2&quot;,            &quot;_type&quot; : &quot;_doc&quot;,            &quot;_id&quot; : &quot;AUutP4MBg4Wtm5vtyLdI&quot;,            &quot;_score&quot; : 1.0,            &quot;_source&quot; : &#123;              &quot;name&quot; : [                &quot;天苍苍&quot;,                &quot;野茫茫&quot;              ]            &#125;          &#125;        ]      &#125;    ]  &#125;&#125;</code></pre><h3 id="2-4-实现酒店搜索框自动补全">2.4.实现酒店搜索框自动补全</h3><p>现在，我们的hotel索引库还没有设置拼音分词器，需要修改索引库中的配置。但是我们知道索引库是无法修改的，只能删除然后重新创建。</p><p>另外，我们需要添加一个字段，用来做自动补全，将brand、suggestion、city等都放进去，作为自动补全的提示。</p><p>因此，总结一下，我们需要做的事情包括：</p><ol><li><p>修改hotel索引库结构，设置自定义拼音分词器</p></li><li><p>修改索引库的name、all字段，使用自定义分词器</p></li><li><p>索引库添加一个新字段suggestion，类型为completion类型，使用自定义的分词器</p></li><li><p>给HotelDoc类添加suggestion字段，内容包含brand、business</p></li><li><p>重新导入数据到hotel库</p></li></ol><h4 id="2-4-1-创建新索引库，使用自定义分词器">2.4.1.创建新索引库，使用自定义分词器</h4><p>①ik+拼音过滤分词器，给ik分词设置自定义过滤器，给分词进一步处理成拼音。索引使用自定义分词器，搜索使用ik分词器。②关键字+拼音过滤分词器，代码补全使用的分词器。</p><p>代码如下：</p><pre><code>//酒店数据索引库。先删除旧的，再新的DELETE /hotelPUT /hotel&#123;  &quot;settings&quot;: &#123;    &quot;analysis&quot;: &#123;      &quot;analyzer&quot;: &#123;        &quot;text_anlyzer&quot;: &#123;    //ik+拼音过滤          &quot;tokenizer&quot;: &quot;ik_max_word&quot;,          &quot;filter&quot;: &quot;py&quot;        &#125;,        &quot;completion_analyzer&quot;: &#123;    //keyword+拼音过滤，相当于又保持关键词，又新加定制版拼音分词          &quot;tokenizer&quot;: &quot;keyword&quot;,          &quot;filter&quot;: &quot;py&quot;        &#125;      &#125;,      &quot;filter&quot;: &#123;        &quot;py&quot;: &#123;          &quot;type&quot;: &quot;pinyin&quot;,          &quot;keep_full_pinyin&quot;: false,          &quot;keep_joined_full_pinyin&quot;: true,          &quot;keep_original&quot;: true,          &quot;limit_first_letter_length&quot;: 16,          &quot;remove_duplicated_term&quot;: true,          &quot;none_chinese_pinyin_tokenize&quot;: false        &#125;      &#125;    &#125;  &#125;,  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;      &quot;id&quot;:&#123;        &quot;type&quot;: &quot;keyword&quot;      &#125;,      &quot;name&quot;:&#123;        &quot;type&quot;: &quot;text&quot;,        &quot;analyzer&quot;: &quot;text_anlyzer&quot;,        //新建文档时分词器用ik+拼音过滤        &quot;search_analyzer&quot;: &quot;ik_smart&quot;,    //搜索分词器用ik        &quot;copy_to&quot;: &quot;all&quot;      &#125;,      &quot;address&quot;:&#123;        &quot;type&quot;: &quot;keyword&quot;,        &quot;index&quot;: false      &#125;,      &quot;price&quot;:&#123;        &quot;type&quot;: &quot;integer&quot;      &#125;,      &quot;score&quot;:&#123;        &quot;type&quot;: &quot;integer&quot;      &#125;,      &quot;brand&quot;:&#123;        &quot;type&quot;: &quot;keyword&quot;,        &quot;copy_to&quot;: &quot;all&quot;      &#125;,      &quot;city&quot;:&#123;        &quot;type&quot;: &quot;keyword&quot;      &#125;,      &quot;starName&quot;:&#123;        &quot;type&quot;: &quot;keyword&quot;      &#125;,      &quot;business&quot;:&#123;        &quot;type&quot;: &quot;keyword&quot;,        &quot;copy_to&quot;: &quot;all&quot;      &#125;,      &quot;location&quot;:&#123;        &quot;type&quot;: &quot;geo_point&quot;      &#125;,      &quot;pic&quot;:&#123;        &quot;type&quot;: &quot;keyword&quot;,        &quot;index&quot;: false      &#125;,      &quot;all&quot;:&#123;        &quot;type&quot;: &quot;text&quot;,        &quot;analyzer&quot;: &quot;text_anlyzer&quot;,        &quot;search_analyzer&quot;: &quot;ik_smart&quot;      &#125;,      &quot;suggestion&quot;:&#123;    //补全字段suggestion          &quot;type&quot;: &quot;completion&quot;,    //补全字段类型必须completion          &quot;analyzer&quot;: &quot;completion_analyzer&quot;    //补全分词器，keyword+拼音过滤      &#125;    &#125;  &#125;&#125;</code></pre><h4 id="2-4-2-HotelDoc实体类添加suggestion字段">2.4.2.HotelDoc实体类添加suggestion字段</h4><p>HotelDoc中要添加一个字段，用来做自动补全，内容可以是酒店品牌、城市、商圈等信息。按照自动补全字段的要求，最好是这些字段的数组。</p><p>因此我们在HotelDoc中添加一个suggestion字段，类型为<code>List&lt;String&gt;</code>，然后将brand、city、business等信息放到里面。</p><p>代码如下：</p><pre><code>package cn.itcast.hotel.pojo;import lombok.Data;import lombok.NoArgsConstructor;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;@Data@NoArgsConstructorpublic class HotelDoc &#123;    private Long id;    private String name;    private String address;    private Integer price;    private Integer score;    private String brand;    private String city;    private String starName;    private String business;//商圈，例如虹桥机场/国家会展中心    private String location;    private String pic;    private Object distance;    private Boolean isAD;    private List&lt;String&gt; suggestion;//放自动补全的list列表，这里只补全搜索商圈和品牌    public HotelDoc(Hotel hotel) &#123;        this.id = hotel.getId();        this.name = hotel.getName();        this.address = hotel.getAddress();        this.price = hotel.getPrice();        this.score = hotel.getScore();        this.brand = hotel.getBrand();        this.city = hotel.getCity();        this.starName = hotel.getStarName();        this.business = hotel.getBusiness();        this.location = hotel.getLatitude() + &quot;, &quot; + hotel.getLongitude();        this.pic = hotel.getPic();        // 组装suggestion，把品牌和商圈放进去        if(this.business.contains(&quot;/&quot;))&#123;            // business有多个值，例如“例如虹桥机场/国家会展中心”，需要切割            String[] arr = this.business.split(&quot;/&quot;);            // 添加元素            this.suggestion = new ArrayList&lt;&gt;();            this.suggestion.add(this.brand);            Collections.addAll(this.suggestion, arr);        &#125;else &#123;            this.suggestion = Arrays.asList(this.brand, this.business);        &#125;    &#125;&#125;</code></pre><h4 id="2-4-3-重新导入MySQL数据到es索引库">2.4.3.重新导入MySQL数据到es索引库</h4><p>重新执行之前编写的导入数据功能</p><pre><code>    @Test    public void bulk() throws IOException &#123;        List&lt;Hotel&gt; hotels = hotelService.list();        for(Hotel hotel:hotels)&#123;            HotelDoc hotelDoc = new HotelDoc(hotel);            client.index(new IndexRequest(&quot;hotel&quot;).id(hotel.getId().toString()).source(JSON.toJSONString(hotelDoc),XContentType.JSON),RequestOptions.DEFAULT);        &#125;    &#125;</code></pre><p>查询所有 ，可以看到新的酒店数据中包含了suggestion：</p><pre><code>GET /hotel/_search&#123;  &quot;query&quot;: &#123;    &quot;match_all&quot;: &#123;&#125;  &#125;&#125;</code></pre><p><img src="../assets/es/8f19078dec5007b92c9b10aa86e43af9.png" alt="image-20210723213546183"></p><h4 id="2-4-4-测试补全，suggest搜索-rj-结果“如家”的文档"><strong>2.4.4 测试补全，suggest搜索&quot;rj&quot;结果“如家”的文档</strong></h4><p>因为 <strong>suggestion字段</strong> 自定义分词器是 <strong>keyword+拼音过滤</strong> ，所以搜索“如”搜不出“如家”。搜索“如家”可以搜索出brand为“如家”的一条文档（搜索条件有跳过重复）。搜索“rj”，可以搜索出brand为“如家”的文档</p><p><strong>测试：</strong></p><pre><code>GET /hotel/_search&#123;  &quot;suggest&quot;: &#123;    &quot;my_suggest&quot;: &#123;      &quot;text&quot;: &quot;rj&quot;,      &quot;completion&quot;:&#123;        &quot;field&quot;: &quot;suggestion&quot;,         &quot;skip_duplicates&quot;: true,         &quot;size&quot;: 10      &#125;    &#125;  &#125;&#125;</code></pre><p><strong>因为指定跳过重复，所以搜索结果仅一条：</strong></p><pre><code>&#123;  &quot;took&quot; : 6,  &quot;timed_out&quot; : false,  &quot;_shards&quot; : &#123;    &quot;total&quot; : 1,    &quot;successful&quot; : 1,    &quot;skipped&quot; : 0,    &quot;failed&quot; : 0  &#125;,  &quot;hits&quot; : &#123;    &quot;total&quot; : &#123;      &quot;value&quot; : 0,      &quot;relation&quot; : &quot;eq&quot;    &#125;,    &quot;max_score&quot; : null,    &quot;hits&quot; : [ ]  &#125;,  &quot;suggest&quot; : &#123;    &quot;my_suggest&quot; : [      &#123;        &quot;text&quot; : &quot;如家&quot;,        &quot;offset&quot; : 0,        &quot;length&quot; : 2,        &quot;options&quot; : [          &#123;            &quot;text&quot; : &quot;如家&quot;,            &quot;_index&quot; : &quot;hotel&quot;,            &quot;_type&quot; : &quot;_doc&quot;,            &quot;_id&quot; : &quot;415600&quot;,            &quot;_score&quot; : 1.0,            &quot;_source&quot; : &#123;              &quot;address&quot; : &quot;三间房乡褡裢坡村青年沟西侧558号&quot;,              &quot;brand&quot; : &quot;如家&quot;,              &quot;business&quot; : &quot;传媒大学/管庄地区&quot;,              &quot;city&quot; : &quot;北京&quot;,              &quot;id&quot; : 415600,              &quot;location&quot; : &quot;39.923212, 116.560023&quot;,              &quot;name&quot; : &quot;如家酒店(北京朝阳北路传媒大学褡裢坡地铁站店)&quot;,              &quot;pic&quot; : &quot;https://m.tuniucdn.com/fb3/s1/2n9c/3NezpxNZWQMdNXibwbMkQuAZjDyJ_w200_h200_c1_t0.jpg&quot;,              &quot;price&quot; : 259,              &quot;score&quot; : 47,              &quot;starName&quot; : &quot;二钻&quot;,              &quot;suggestion&quot; : [                &quot;如家&quot;,                &quot;传媒大学&quot;,                &quot;管庄地区&quot;              ]            &#125;          &#125;        ]      &#125;    ]  &#125;&#125;</code></pre><h4 id="2-4-5-自动补全查询的JavaAPI，SuggestBuilder">2.4.5.自动补全查询的JavaAPI，SuggestBuilder()</h4><p>之前我们学习了自动补全查询的DSL，而没有学习对应的JavaAPI，这里给出一个示例：</p><p>suggest和query是平级的。</p><p><img src="../assets/es/a65054ff019501f975ef140def8e3977.png" alt="image-20210723213759922"></p><p>而自动补全的结果也比较特殊，解析的代码如下：</p><p><img src="../assets/es/9c17c392d2b757c8d611a7925518df35.png" alt="image-20210723213917524"></p><h4 id="2-4-6-实现旅游项目搜索框自动补全">2.4.6.实现旅游项目搜索框自动补全</h4><p>查看前端页面，可以发现当我们在输入框键入时，前端会发起ajax请求：</p><p><img src="../assets/es/62a79c4576fdfdd7c4321157a58a1ead.png" alt="image-20210723214021062"></p><p>返回值是补全词条的集合，类型为<code>List&lt;String&gt;</code></p><p>1）在<code>cn.itcast.hotel.web</code>包下的<code>HotelController</code>中添加新接口，接收新的请求：</p><pre><code>@GetMapping(&quot;suggestion&quot;)public List&lt;String&gt; getSuggestions(@RequestParam(&quot;key&quot;) String prefix) &#123;    return hotelService.getSuggestions(prefix);&#125;</code></pre><p>2）在<code>cn.itcast.hotel.service</code>包下的<code>IhotelService</code>中添加方法：</p><pre><code>List&lt;String&gt; getSuggestions(String prefix);</code></pre><p>3）在<code>cn.itcast.hotel.service.impl.HotelService</code>中实现该方法：</p><blockquote><p>建议截图补全的es代码，贴到屏幕上，层层解析</p></blockquote><pre><code>@Overridepublic List&lt;String&gt; getSuggestions(String prefix) &#123;    try &#123;        // 1.准备Request        SearchRequest request = new SearchRequest(&quot;hotel&quot;);        // 2.准备DSL        request.source().suggest(new SuggestBuilder().addSuggestion(    //new SuggestBuilder()不是SuggestBuilders            &quot;suggestions&quot;,    //自定义补全的名字，后面根据它解析response            SuggestBuilders.completionSuggestion(&quot;suggestion&quot;)    //字段名            .prefix(prefix)    //需要补全的文本            .skipDuplicates(true)            .size(10)        ));        // 3.发起请求        SearchResponse response = client.search(request, RequestOptions.DEFAULT);        // 4.解析结果        Suggest suggest = response.getSuggest();        // 4.1.根据补全查询名称，获取补全结果，注意返回值和ctrl+alt+v生成的内容不一样        CompletionSuggestion suggestions = suggest.getSuggestion(&quot;suggestions&quot;);        // 4.2.获取options        List&lt;CompletionSuggestion.Entry.Option&gt; options = suggestions.getOptions();        // 4.3.遍历        List&lt;String&gt; list = new ArrayList&lt;&gt;(options.size());        for (CompletionSuggestion.Entry.Option option : options) &#123;            String text = option.getText().toString();            list.add(text);        &#125;        return list;    &#125; catch (IOException e) &#123;        throw new RuntimeException(e);    &#125;&#125;</code></pre><p><strong>测试成功：</strong></p><p><img src="../assets/es/f042019c0fc6093edfc66c58cf127869.png" alt=""></p><h2 id="3-mysql与es数据同步">3.mysql与es数据同步</h2><p>elasticsearch中的酒店数据来自于mysql数据库，因此mysql数据发生改变时，elasticsearch也必须跟着改变，这个就是elasticsearch与mysql之间的 <strong>数据同步</strong> 。</p><p><img src="../assets/es/f331d37395546a44d7f8aa9079de8808.png" alt="image-20210723214758392"></p><h3 id="3-1-思路分析">3.1.思路分析</h3><p>常见的数据同步方案有三种：</p><ul><li>同步调用</li><li>异步通知</li><li>监听binlog</li></ul><h4 id="3-1-1-方案一：-同步调用">3.1.1. <strong>方案一：</strong> 同步调用</h4><p><strong>方案一：同步调用</strong></p><p>管理端只能访问mysql，用户端只能访问es，两者间隔离，符合微服务规范。</p><p><img src="../assets/es/c23f8d1027d337c2f55dfcda1aac69a9.png" alt="image-20210723214931869"></p><p>基本步骤如下：</p><ul><li>hotel-demo对外提供接口，用来修改elasticsearch中的数据</li><li>酒店管理服务在完成数据库操作后，直接调用hotel-demo提供的接口，</li></ul><p><strong>缺点：耦合度高</strong></p><h4 id="3-1-2-方案二：异步通知">3.1.2.方案二：异步通知</h4><p>方案二：异步通知</p><p><img src="../assets/es/d5998cf60e46a42882a32c396221ea59.png" alt="image-20210723215140735"></p><p>流程如下：</p><ul><li>hotel-admin对mysql数据库数据完成增、删、改后，发送MQ消息</li><li>hotel-demo监听MQ，接收到消息后完成elasticsearch数据修改</li></ul><p>优点：性能高，耦合度低</p><p>缺点：依赖于mq消息队列可靠性</p><h4 id="3-1-3-方案三：canal监听mysql的binlog">3.1.3.方案三：canal监听mysql的binlog</h4><p>canal译为管道，运河。</p><blockquote><p><strong>回顾主从复制，</strong> 主库开启binlog，从库根据主库binlog的增删改信息，进行相同操作。</p></blockquote><p><img src="../assets/es/9c78f220c5746bd227b6a71b6707d7ae.png" alt="image-20210723215518541"></p><p>流程如下：</p><ul><li>给mysql开启binlog功能</li><li>mysql完成增、删、改操作都会记录在binlog中</li><li>hotel-demo基于canal监听binlog变化，实时更新elasticsearch中的内容</li></ul><p><strong>优点：</strong> 耦合度最低</p><p><strong>缺点：</strong> mysql压力增加</p><h4 id="3-1-4-三种方案优缺点总结">3.1.4.三种方案优缺点总结</h4><p><strong>方式一：同步调用</strong></p><ul><li>优点：实现简单，粗暴</li><li>缺点：业务 <strong>耦合度高</strong></li></ul><p><strong>方式二：异步通知</strong></p><ul><li>优点：低耦合，实现难度一般</li><li>缺点： <strong>依赖mq的可靠性</strong></li></ul><p><strong>方式三：监听binlog</strong></p><ul><li>优点： <strong>完全解除服务间耦合</strong></li><li>缺点：开启binlog增加 <strong>数据库负担</strong> 、实现复杂度高</li></ul><h3 id="3-2-MQ实现数据同步">3.2.MQ实现数据同步</h3><h4 id="3-2-1-思路">3.2.1.思路</h4><p>利用课前资料提供的hotel-admin项目作为酒店管理的微服务。当酒店数据发生增、删、改时，要求对elasticsearch中数据也要完成相同操作。</p><p><strong>使用RabbitMQ的发布/订阅模型topic话题模式，支持不同的消息根据routingKey被不同的队列消费。先声明交换机、队列，增删两个routingKey。只需要增删两个队列，restapi里增改是一致的，id存在则修改，id不存在则新增。</strong></p><blockquote><p>忘了就回顾：<a href="https://blog.csdn.net/qq_40991313/article/details/126801025?spm=1001.2014.3001.5501" title="SpringCloud基础4——RabbitMQ和SpringAMQP">SpringCloud基础4——RabbitMQ和SpringAMQP</a></p></blockquote><p>步骤：</p><ul><li><p>导入课前资料提供的hotel-admin项目，启动并测试酒店数据的CRUD</p></li><li><p>声明exchange、queue、RoutingKey</p></li><li><p>在hotel-admin中的增、删、改业务中完成消息发送</p></li><li><p>在hotel-demo中完成消息监听，并更新elasticsearch中数据</p></li><li><p>启动并测试数据同步功能</p></li></ul><h4 id="3-2-2-导入hotel-admin后台管理端、修改pom和yml">3.2.2.导入hotel-admin后台管理端、修改pom和yml</h4><p>导入课前资料提供的hotel-admin项目：</p><p><img src="../assets/es/c689544193b9602b43405a79410c2351.png" alt=""></p><p><img src="../assets/es/a925855b9112e9b19e859f556fa0f625.png" alt=""></p><p><strong>修改pom</strong></p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;            &lt;version&gt;3.4.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;1.2.11&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;</code></pre><p><strong>修改yml：</strong></p><pre><code>server:  port: 8099spring:  datasource:    druid:      driver-class-name: com.mysql.cj.jdbc.Driver      url: jdbc:mysql://localhost:3306/heima?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true      username: root      password: 1234  main:    banner-mode: off  rabbitmq:    host: 192.168.200.131    port: 5672    username: itcast    password: 123321    virtual-host: / #虚拟主机#logging:#  level:#    cn.itcast: debug#  pattern:#    dateformat: MM-dd HH:mm:ss:SSS#  type-aliases-package:com.vince.hotel.pojomybatis-plus:  configuration:    map-underscore-to-camel-case: true  global-config:    banner: false</code></pre><p>运行后，访问 <a href="http://localhost:8099">http://localhost:8099</a></p><p><img src="../assets/es/333c47760f4ebf7a5f03ceca42ef2949.png" alt="image-20210723220354464"></p><p><strong>其中包含了酒店的CRUD功能：</strong></p><p><img src="../assets/es/6f1223739ae4e0c564d0e0e7f0ad224c.png" alt="image-20210723220511090"></p><h4 id="3-2-3-声明交换机、队列">3.2.3.声明交换机、队列</h4><p>MQ结构如图：</p><p><img src="../assets/es/c1e06c92f6a3947c38ec6577cf2a11cc.png" alt="image-20210723215850307"></p><p><strong>0)开启RabbitMQ</strong></p><pre><code>docker ps -adocker start 容器名</code></pre><p>管理端：</p><pre><code>http://ip地址:15672/</code></pre><blockquote><p><a href="https://blog.csdn.net/qq_40991313/article/details/126801025?spm=1001.2014.3001.5501" title="SpringCloud基础4——RabbitMQ_springcloud rabbitmq_vincewm的博客-CSDN博客">SpringCloud基础4——RabbitMQ_springcloud rabbitmq_vincewm的博客-CSDN博客</a></p></blockquote><p><strong>1）引入依赖、yml</strong></p><p>在hotel-admin、hotel-demo中引入rabbitmq的依赖：</p><pre><code>&lt;!--amqp--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>yml：</p><pre><code>server:  port: 8099spring:  datasource:    druid:      driver-class-name: com.mysql.cj.jdbc.Driver      url: jdbc:mysql://localhost:3306/heima?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;allowPublicKeyRetrieval=true      username: root      password: 1234  main:    banner-mode: off  rabbitmq:    host: 192.168.200.131    port: 5672    username: itcast    password: 123321    virtual-host: / #虚拟主机#logging:#  level:#    cn.itcast: debug#  pattern:#    dateformat: MM-dd HH:mm:ss:SSS#  type-aliases-package:com.vince.hotel.pojomybatis-plus:  configuration:    map-underscore-to-camel-case: true  global-config:    banner: false</code></pre><p><strong>2）常量类，声明队列交换机名称</strong></p><p>在hotel-admin和hotel-demo中的<code>cn.itcast.hotel.constatnts</code>包下新建一个类<code>MqConstants</code>：</p><pre><code>package cn.itcast.hotel.constants;    public class MqConstants &#123;    /**     * 交换机     */    public final static String HOTEL_EXCHANGE = &quot;hotel.topic&quot;;    /**     * 监听新增和修改的队列     */    public final static String HOTEL_INSERT_QUEUE = &quot;hotel.insert.queue&quot;;    /**     * 监听删除的队列     */    public final static String HOTEL_DELETE_QUEUE = &quot;hotel.delete.queue&quot;;    /**     * 新增或修改的RoutingKey     */    public final static String HOTEL_INSERT_KEY = &quot;hotel.insert&quot;;    /**     * 删除的RoutingKey     */    public final static String HOTEL_DELETE_KEY = &quot;hotel.delete&quot;;&#125;</code></pre><p><strong>3）声明队列交换机</strong></p><blockquote><p><strong>topic模式回顾：话题模式，通配符。</strong><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过 <strong><code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</strong></p><p>也可以在接收消息时，使用注解方式@RabbitListener的bindings，适用于消息队列少的情况:</p><pre><code>@RabbitListener(bindings = @QueueBinding(    value = @Queue(name = &quot;topic.queue1&quot;),    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),    key = &quot;china.#&quot;))public void listenTopicQueue1(String msg)&#123;    System.out.println(&quot;消费者接收到topic.queue1的消息：【&quot; + msg + &quot;】&quot;);&#125;</code></pre></blockquote><p>在config包下创建MqConfig，声明队列、交换机：</p><pre><code>package cn.itcast.hotel.config;import cn.itcast.hotel.constants.MqConstants;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.Queue;import org.springframework.amqp.core.TopicExchange;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class MqConfig &#123;    @Bean    public TopicExchange topicExchange()&#123;        //第二个参数为是否持久化，第三个参数为是否自动删除。两个参数默认值就是持久化、不自动删除        return new TopicExchange(MqConstants.HOTEL_EXCHANGE, true, false);    &#125;    @Bean    public Queue insertQueue()&#123;        return new Queue(MqConstants.HOTEL_INSERT_QUEUE, true);    &#125;    @Bean    public Queue deleteQueue()&#123;        return new Queue(MqConstants.HOTEL_DELETE_QUEUE, true);    &#125;    @Bean    public Binding insertQueueBinding()&#123;        return BindingBuilder.bind(insertQueue()).to(topicExchange()).with(MqConstants.HOTEL_INSERT_KEY);    &#125;    @Bean    public Binding deleteQueueBinding()&#123;        return BindingBuilder.bind(deleteQueue()).to(topicExchange()).with(MqConstants.HOTEL_DELETE_KEY);    &#125;&#125;</code></pre><blockquote><p><strong>为什么只需要增删两个队列，不用“改” 队列？</strong></p><p>在RestClient的API中， <strong>全量修改与新增的API完全一致</strong> ，判断依据是ID：</p><ul><li>如果新增时，ID已经存在，则修改</li><li>如果新增时，ID不存在，则新增</li></ul></blockquote><h4 id="3-2-4-后台端发送MQ消息">3.2.4.后台端发送MQ消息</h4><p>在hotel-admin中的增、删、改业务中分别发送MQ消息， <strong>消息内容为id，到时候用户端根据id增删改</strong> ：</p><p><img src="../assets/es/d0afe430f232884b74b2c514806a864f.png" alt="image-20210723221843816"></p><h4 id="3-2-5-用户端-接收MQ消息">3.2.5. <strong>用户端</strong> 接收MQ消息</h4><p>管理端hotel-admin不能直接调用es，想对es实现增删改要通过给用户端hotel-demo发送新增（修改）、删除消息。</p><p><strong>hotel-demo</strong> 接收到MQ消息要做的事情包括：</p><ul><li><strong>新增消息：</strong> 根据传递的hotel的 <strong>id</strong> 查询hotel信息，然后新增一条数据到 <strong>索引库</strong></li><li><strong>删除消息：</strong> 根据传递的hotel的 <strong>id删除索引库</strong> 中的一条数据</li></ul><p><strong>0） 环境准备</strong></p><p>pom</p><pre><code>        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p>yml</p><pre><code>spring:  rabbitmq:    host: 192.168.200.131    port: 5672    username: itcast    password: 123321    virtual-host: / #虚拟主机</code></pre><p>复制管理端的MqConstants.java和MqConfig到用户端</p><p><strong>1）service接口新增新增、删除业务</strong></p><p>首先在hotel-demo的<code>cn.itcast.hotel.service</code>包下的<code>IHotelService</code>中 <strong>新增新增、删除业务</strong></p><pre><code>//mp的增删方法是saveById和removeById，所以这里并不冲突void deleteById(Long id);void insertById(Long id);</code></pre><p><strong>2）service实现类实现业务</strong></p><p>给hotel-demo中的<code>cn.itcast.hotel.service.impl</code>包下的HotelService中 <strong>实现业务：</strong></p><pre><code>//mp的增删方法是saveById和removeById，所以这里并不冲突@Overridepublic void deleteById(Long id) &#123;    try &#123;        // 1.准备Request        DeleteRequest request = new DeleteRequest(&quot;hotel&quot;, id.toString());        // 2.发送请求        client.delete(request, RequestOptions.DEFAULT);    &#125; catch (IOException e) &#123;        throw new RuntimeException(e);    &#125;&#125;@Overridepublic void insertById(Long id) &#123;    try &#123;        // 0.根据id查询酒店数据        Hotel hotel = getById(id);        // 转换为文档类型        HotelDoc hotelDoc = new HotelDoc(hotel);        // 1.准备Request对象        IndexRequest request = new IndexRequest(&quot;hotel&quot;).id(hotel.getId().toString());        // 2.准备Json文档        request.source(JSON.toJSONString(hotelDoc), XContentType.JSON);        // 3.发送请求        client.index(request, RequestOptions.DEFAULT);    &#125; catch (IOException e) &#123;        throw new RuntimeException(e);    &#125;&#125;</code></pre><blockquote><p>坑点：删除文档的request别忘了设置id，不然会删除所有数据。</p></blockquote><p><strong>3）编写监听器</strong></p><p><strong>在<code>mq</code>包下</strong>新增一个类：</p><pre><code>package cn.itcast.hotel.mq;import cn.itcast.hotel.constants.MqConstants;import cn.itcast.hotel.service.IHotelService;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;//别忘了@Component，被ioc容器管理，一直监听@Componentpublic class HotelListener &#123;    @Autowired    private IHotelService hotelService;    /**     * 监听酒店新增或修改的业务     * @param id 酒店id     */    @RabbitListener(queues = MqConstants.HOTEL_INSERT_QUEUE)    public void listenHotelInsertOrUpdate(Long id)&#123;        hotelService.insertById(id);    &#125;    /**     * 监听酒店删除的业务     * @param id 酒店id     */    @RabbitListener(queues = MqConstants.HOTEL_DELETE_QUEUE)    public void listenHotelDelete(Long id)&#123;        hotelService.deleteById(id);    &#125;&#125;</code></pre><h4 id="3-2-6-测试">3.2.6 测试</h4><p>运行管理端和用户端服务后，打开rabbitmq服务端： <a href="http://xn--ip-im8ckc:15672">http://ip地址:15672</a></p><p>可以看到队列、交换机创建成功：</p><p><img src="../assets/es/ac708c6b4fc9e95d1dce56a2e136713f.png" alt=""></p><p><img src="../assets/es/ca4855d06902eb5f6c19034a8b07aeda.png" alt=""></p><p><strong>交换机绑定关系：</strong></p><p><img src="../assets/es/5c3168cd4f4e917a2385c895f7fb6e80.png" alt=""></p><p><strong>先用户端搜索一个酒店，然后在管理端修改酒店信息 ：</strong></p><p><img src="../assets/es/305db1459558cea40dc022dea7a7e454.png" alt=""></p><p><strong>可以看到队列的消息记录：</strong></p><p><img src="../assets/es/6efbfddd7b7c980a30e758b1dbed30dd.png" alt=""></p><p><strong>用户端搜索后的数据也改变了：</strong></p><p><img src="../assets/es/b9e78c04fa69fd2eb2b2de8be421ffa9.png" alt=""></p><p>再删除酒店，发现成功。</p><h4 id="3-2-7-vue插件实现快速拷贝数据到表单">3.2.7.vue插件实现快速拷贝数据到表单</h4><p><strong>安装地址</strong></p><p><a href="https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh">https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=zh</a></p><p><strong>拷贝数据并保存的办法：</strong></p><p><img src="../assets/es/ef70c8fa4ce05c945fa49eb1fbd911d5.png" alt=""></p><p>粘贴即可快速填充表单：</p><p><img src="../assets/es/5c416e57971703394c70aa05340d4bb6.png" alt=""></p><h2 id="4-集群">4.集群</h2><h3 id="4-0-概述">4.0.概述</h3><p>单机的elasticsearch做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。</p><ul><li><strong>海量数据存储问题：</strong> 将 <strong>索引库</strong> 从逻辑 <strong>上拆分为N个分片</strong> （shard），存储到多个节点</li><li><strong>单点故障问题：将分片数据在不同节点备份</strong> （replica ）</li></ul><p><strong>ES集群相关概念</strong> :</p><p><strong>一个集群里有多个节点，每个节点都是一个es实例， 每个节点保存了自己的分片和一个其他节点备份的分片。</strong></p><ul><li><p><strong>集群（cluster）</strong> ：一组拥有共同的 集群名 的 节点。</p></li><li><p><strong>节点（node) ：</strong> 集群中的一个 Elasticearch 实例</p></li><li><p><strong>分片（shard）：</strong> 索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下， <strong>一个索引的不同分片可以拆分到不同的节点中</strong></p></li></ul><p><strong>解决问题：</strong> 数据量太大，单点存储量有限的问题。</p><p><img src="../assets/es/e3e8914f1418efc3923e087ce2667e11.png" alt="image-20200104124440086"></p><blockquote><p>此处，我们把数据分成3片：shard0、shard1、shard2</p></blockquote><ul><li><p><strong>主分片（Primary shard）：</strong> 相对于副本分片的定义。</p></li><li><p><strong>副本分片（Replica shard）：</strong> 每个主分片可以有一个或者多个副本， <strong>数据和主分片一样</strong> 。</p></li></ul><p>​</p><p>数据备份可以保证高可用，但是每个分片备份一份，所需要的节点数量就会翻一倍，成本实在是太高了！</p><p>为了在高可用和成本间寻求平衡，我们可以这样做：</p><ul><li>首先对数据分片，存储到不同节点</li><li>然后对 <strong>每个分片进行备份，放到对方节点，完成互相备份</strong></li></ul><p>这样可以大大减少所需要的服务节点数量，如图，我们以3分片，每个分片备份一份为例：</p><p><img src="../assets/es/0f744585940501b4513e67af778f62cf.png" alt="image-20200104124551912"></p><p>现在，每个分片都有1个备份，存储在3个节点：</p><ul><li><strong>节点node0：保存了分片0和1</strong></li><li>node1：保存了分片0和2</li><li>node2：保存了分片1和2</li></ul><h3 id="4-1-搭建ES集群">4.1.搭建ES集群</h3><h4 id="4-1-0-Docker-Compose介绍">4.1.0.Docker Compose介绍</h4><p>Docker Compose是一个用来定义和运行复杂应用的Docker工具，将一个或多个容器组合成一个完整的应用程序。一个使用Docker容器的应用，通常由多个容器组成。使用Docker Compose不再需要使用shell脚本来启动容器。</p><p>Compose 通过一个 <strong>配置文件</strong> 来管理多个Docker容器，在配置文件中，所有的容器通过 <strong>services</strong> 来定义，然后使用 <strong>docker-compose脚本</strong> 来启动，停止和重启应用，和应用中的服务以及所有依赖服务的容器，非常适合组合使用多个容器进行开发的场景。</p><p><strong>Docker Compose 使用的三个步骤：</strong></p><ol><li>使用 Dockerfile 定义应用程序的环境</li><li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行</li><li>执行 docker-compose up 命令（后面加-d是在后台运行）来启动并运行整个应用程序</li></ol><h4 id="4-1-1-创建es集群">4.1.1.创建es集群</h4><p>创建同一个集群的三个节点，每个节点都是一个es实例：</p><p><strong>①首先编写一个docker-compose.yml文件</strong> ，上传到/root，内容如下：</p><blockquote><p><strong>注意端口占用问题</strong> ：ports:-9200:9200，左边是centos的端口，右边是容器内部端口，只有左边会发生端口占用问题，前面安装过单点es的默认接口是9200，注意一下。</p></blockquote><pre><code>#创建三个es容器，容器名和节点名都是es01、es02、es03。version: '2.2'services:  es01:    image: elasticsearch:7.12.1    #镜像名称    container_name: es01    #容器名称    environment:      - node.name=es01#集群名称。三个容器集群名称一样，es会自动把他们组装成一个集群。      - cluster.name=es-docker-cluster    #集群中其他节点的ip地址；docker容器之间通过名字直接相互访问      - discovery.seed_hosts=es02,es03#集群中可以参与选举的主节点      - cluster.initial_master_nodes=es01,es02,es03      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;    #内存大小，最小和最大内存    volumes:      - data01:/usr/share/elasticsearch/data    ports:      - 9200:9200    #对外端口9200：对内端口9200    networks:      - elastic  es02:    image: elasticsearch:7.12.1    container_name: es02    environment:      - node.name=es02#集群名称。三个容器集群名称一样，es会自动把他们组装成一个集群。      - cluster.name=es-docker-cluster      - discovery.seed_hosts=es01,es03      - cluster.initial_master_nodes=es01,es02,es03      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;    volumes:      - data02:/usr/share/elasticsearch/data    ports:      - 9201:9200    networks:      - elastic  es03:    image: elasticsearch:7.12.1    container_name: es03    environment:      - node.name=es03      - cluster.name=es-docker-cluster#集群名称。三个容器集群名称一样，es会自动把他们组装成一个集群。      - discovery.seed_hosts=es01,es02      - cluster.initial_master_nodes=es01,es02,es03      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;    volumes:      - data03:/usr/share/elasticsearch/data    networks:      - elastic    ports:      - 9202:9200volumes:  data01:    driver: local  data02:    driver: local  data03:    driver: localnetworks:  elastic:    driver: bridge</code></pre><p><strong>②修改权限：</strong></p><p>es运行需要修改一些linux系统权限，修改<code>/etc/sysctl.conf</code>文件</p><pre><code>vi /etc/sysctl.conf</code></pre><p>添加下面的内容，或将注释打开：</p><pre><code>vm.max_map_count=262144</code></pre><p>然后执行命令， <strong>让配置生效</strong> ：</p><pre><code>sysctl -p</code></pre><p><strong>③通过docker-compose up启动集群：</strong></p><pre><code>docker-compose up -d</code></pre><h4 id="4-1-2-集群状态监控，安装cerebro">4.1.2.集群状态监控，安装cerebro</h4><p>kibana可以监控es集群，不过新版本需要依赖es的x-pack 功能，配置比较复杂。</p><p>这里推荐使用cerebro来监控es集群状态，官方网址：<a href="https://github.com/lmenezes/cerebro">https://github.com/lmenezes/cerebro</a></p><p>课前资料已经提供了安装包：</p><p><img src="../assets/es/596c94f7f44515c7ae1220f444b51784.png" alt="image-20210602220751081"></p><p><strong>windows解压即可</strong> 使用，非常方便。</p><p>解压好的目录如下：</p><p><img src="../assets/es/15e310b7a92b136bdb101cb26407f8a2.png" alt="image-20210602220824668"></p><p>进入对应的bin目录：</p><p><img src="../assets/es/d9b49750ab83b43060a78100f684770f.png" alt="image-20210602220846137"></p><p>双击其中的cerebro.bat文件即可启动服务。</p><p><img src="../assets/es/4d3f2df39357b23d5278da98f5a23a5d.png" alt="image-20210602220941101"></p><p>访问http://localhost:9000 即可进入管理界面：</p><p><img src="../assets/es/3bd5f3cb539c0ff27cfbb814285949ef.png" alt="image-20210602221115763"></p><p>输入你的elasticsearch的任意节点的地址和端口，点击connect即可：</p><p><img src="../assets/es/35e30f4b039d8777d52caa0b2c64c094.png" alt="image-20210109181106866"></p><p>绿色的条，代表集群处于绿色（健康状态）。</p><h4 id="4-1-3-创建索引库">4.1.3.创建索引库</h4><p><strong>1）方法一：利用kibana的DevTools创建索引库</strong></p><p>在DevTools中输入指令：</p><pre><code>PUT /itcast&#123;  &quot;settings&quot;: &#123;    &quot;number_of_shards&quot;: 3, // 分片数量，shard译为碎片    &quot;number_of_replicas&quot;: 1 // 副本数量，replica译为副本，复制品。  &#125;,  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;      // mapping映射定义 ...    &#125;  &#125;&#125;</code></pre><p><strong>2）方法二：利用cerebro创建索引库</strong></p><p>利用cerebro还可以创建索引库：</p><p><img src="../assets/es/130cb3bc96be83f8908cd7a6d7c667ef.png" alt="image-20210602221409524"></p><p>填写索引库信息：</p><p><img src="../assets/es/d1bc735f9f44b68bf3b338042670ba4a.png" alt="image-20210602221520629"></p><p>点击右下角的create按钮：</p><p><img src="../assets/es/3576486d9004b5d663c4f043e7233de7.png" alt="image-20210602221542745"></p><h4 id="4-1-4-查看分片效果">4.1.4.查看分片效果</h4><p>回到首页，即可查看索引库分片效果：</p><p><img src="../assets/es/75663fb18df1ef24ea0e484f61a823cf.png" alt="image-20210602221914483"></p><h3 id="4-2-集群脑裂问题">4.2.集群脑裂问题</h3><h4 id="4-2-1-集群职责划分，四种节点类型">4.2.1.集群职责划分，四种节点类型</h4><p><strong>集群职责划分：</strong></p><ul><li><p><strong>候选主节点（master eligible）：</strong> 管理集群状态，处理索引库增删请求。</p></li><li><p><strong>数据节点（data）：</strong> 对记录的增删改查。</p></li><li><p><strong>接待节点（ingest）：</strong> 数据存储前的预处理。</p></li></ul><p><strong>协作节点（coordinating）：</strong> 将请求路由其他节点，合并处理结果并返回。</p><p><img src="../assets/es/1a3c241d05840259906fe1e662f077f0.png" alt="image-20210723223008967"></p><blockquote><p>主节点的类型也是master eligible，它是备选主节点选出来的。</p><p><strong>eligible 译为合格的，合适的。</strong></p><p><strong>ingest译为接待、吸收。</strong></p><p><strong>coordinating译为协调，合作。</strong></p></blockquote><p><strong>默认情况下</strong> ，集群中的任何一个节点都 <strong>同时具备上述四种角色</strong> 。</p><p>但是 <strong>真实的集群</strong> 一定要将 <strong>集群职责分离</strong> ：</p><p>职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。</p><p><strong>典型的es集群职责划分：LB是负载均衡</strong></p><p><img src="../assets/es/c3ba5b8b43958c73f8d9bad7f5ef87d7.png" alt="image-20210723223629142"></p><h4 id="4-2-2-脑裂问题">4.2.2.脑裂问题</h4><p><strong>选举master条件：</strong> 当一个节点发现包括自己在内的多数派的master-eligible节点认为集群没有master时，就可以发起master选举。</p><p><strong>选举master过程：</strong></p><ol><li><p>备选主节点首先根据节点id（第一次启动时生成的随机字符串）排序，第一个节点暂定master；</p></li><li><p>如果有(n+1)/2个节点投票它是mater，并且它自己也给自己投票，则它当选master；</p></li><li><p>否则就暂定第二个节点为master，以此类推。</p></li></ol><p><strong>脑裂：</strong> master故障，集群选举出新master后旧master又恢复了，导致集群出现了两个master。</p><p><strong>&quot;脑裂&quot;成因：</strong></p><ul><li><p><strong>网络延迟导致误判：</strong> 集群间的网络延迟导致一些节点访问不到master, 认为master 挂掉了从而选举出新的master,并对master上的分片和副本标红，分配新的主分片</p></li><li><p><strong>主节点负载过高导致误判：</strong> 主节点的角色既为master又为data,访问量较大时可能会导致ES停止响应造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点</p></li><li><p><strong>内存回收导致误判：</strong> data 节点上的ES进程占用的内存较大，引发JVM的大规模内存回收，造成ES进程失去响应，从而长时间没ping通主节点，导致误判主节点下线</p></li><li><p><strong>主节点故障</strong> 。</p></li></ul><p><strong>解决方案：</strong></p><ul><li><p><strong>调大超时时间减少误判：</strong> discovery.zen.ping_timeout节点状态的响应时间，默认为3s，可以适当调大，如果master在该响应时间的范围内没有做出响应应答，判断该节点已经挂掉了。调大参数（如6s，discovery.zen.ping_timeout:6），可适当减少误判</p></li><li><p><strong>选举触发条件：</strong> discovery.zen.minimum_master_nodes:(备选主节点数量/ 2) +1。该参数是用于控制选举条件，只有(n / 2) +1个备选主节点认为主节点故障才开始选举。在es7.0以后，已经成为默认配置，因此一般不会发生脑裂问题</p></li><li><p><strong>master和data分离：</strong> 即master节点与data节点分离，限制角色</p><ul><li><p>主节点配置为：node.master: true，node.data: false</p></li><li><p>从节点配置为：node.master: false，node.data: true</p></li></ul></li></ul><blockquote><p>脑裂 <strong>是由集群中的节点失联导致的。</strong></p><p><strong>脑裂情况演示：</strong></p><p>例如一个集群中，主节点与其它节点失联：</p><p><img src="../assets/es/fde04bc2628246aa4b4a58c2ce7cef3e.png" alt="image-20210723223804995"></p><p>此时，node2和node3认为node1宕机（但其实只是阻塞了），就会重新选主：</p><p>宕机，即down机、死机。</p><p>指<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192?fromModule=lemma_inlink" title="操作系统">操作系统</a>无法从一个严重系统错误中恢复过来，或系统<a href="https://baike.baidu.com/item/%E7%A1%AC%E4%BB%B6/479446?fromModule=lemma_inlink" title="硬件">硬件</a>层面出问题，以致系统长时间无响应，而不得不重新启动计算机的现象。</p><p><img src="../assets/es/1fe75fadbba300181c5ef805fab9b090.png" alt="image-20210723223845754"></p><p>当node3当选后，集群继续对外提供服务，node2和node3自成集群，node1自成集群，两个集群数据不同步，出现数据差异。</p><p>当网络恢复后，因为集群中有两个master节点，集群状态的不一致，出现脑裂的情况：</p><p><img src="../assets/es/543ddad36df9e7bba38c91a250113055.png" alt="image-20210723224000555"></p><p><strong>解决脑裂</strong></p><p><strong>解决脑裂的方案</strong> 是，要求选票超过 ( eligible节点数量 + 1 ）/ 2 才能当选为主，因此 <strong>eligible节点数量最好是奇数</strong> 。对应配置项是 <strong>discovery.zen.minimum_master_nodes</strong> ，在es7.0以后，已经成为 <strong>默认配置</strong> ，因此 <strong>一般不会发生脑裂问题</strong></p><p>例如：3个节点形成的集群，选票必须超过 （3 + 1） / 2 ，也就是2票。node3得到node2和node3的选票，当选为主。node1只有自己1票，没有当选。集群中依然只有1个主节点，没有出现脑裂。</p></blockquote><h4 id="4-2-3-小结，四种节点类型">4.2.3.小结，四种节点类型</h4><p>master eligible节点的作用是什么？</p><p>data节点的作用是什么？</p><p>coordinator节点的作用是什么？</p><h3 id="4-3-集群分布式存储">4.3.集群分布式存储</h3><p>当新增文档时，应该保存到不同分片，保证数据均衡，那么 <strong>coordinating node如何确定数据该存储到哪个分片</strong> 呢？</p><h4 id="4-3-1-文档存储到分片测试">4.3.1.文档存储到分片测试</h4><blockquote><p><strong>一个集群里有多个节点，每个节点都是一个es实例， 每个节点保存了自己的分片和一个其他节点备份的分片。</strong></p></blockquote><p><strong>在9200端口的es插入三条数据：</strong></p><p><img src="../assets/es/d61f286063add87f52c72ec7fa168c79.png" alt="image-20210723225006058"></p><p><img src="../assets/es/f834dd5a25743690b6ba9e330e3d26f5.png" alt="image-20210723225034637"></p><p><img src="../assets/es/6434db5977e1023a784aa5d0bbd34e40.png" alt="image-20210723225112029"></p><p>测试可以看到， <strong>三条数据分别在不同分片：</strong></p><p><img src="../assets/es/3a4b8caa2b711a2034790905020eafff.png" alt="image-20210723225227928"></p><p><img src="../assets/es/4c06fbd63ddf24d72ad4acb0d4cbf67c.png" alt="image-20210723225342120"></p><h4 id="4-3-2-分片存储原理">4.3.2.分片存储原理</h4><p><strong>分布式新增如何确定分片？</strong></p><p>elasticsearch会通过 <strong>hash算法来计算文档应该存储到哪个分片，跟文档id和分片数量有关：</strong></p><p><img src="../assets/es/07e46766cf5654071a12d76e2ae59dea.png" alt="image-20210723224354904"></p><blockquote><p>说明：</p><ul><li>_routing默认是文档的id</li><li>算法与分片数量有关，因此索引库一旦创建， <strong>分片数量不能修改！</strong></li></ul></blockquote><p><strong>新增文档的流程如下：</strong></p><p><img src="../assets/es/f0be01a97750fd79a596b1cff21dd280.png" alt="image-20210723225436084"></p><p>解读：</p><h3 id="4-4-集群分布式查询，协调节点的分散和聚集">4.4.集群分布式查询，协调节点的分散和聚集</h3><p>elasticsearch的查询分成两个阶段：</p><p><img src="../assets/es/cd4634cf75764dc3ea1d52cc98715ec1.png" alt="image-20210723225809848"></p><h3 id="4-5-集群故障转移">4.5.集群故障转移</h3><p>集群的 <strong>master节点会监控集群中的节点状态</strong> ，如果发现有节点宕机，会立即 <strong>将宕机节点的分片数据迁移到其它节点</strong> ，确保数据安全，这个叫做 <strong>故障转移</strong> 。</p><p><strong>故障转移流程演示：</strong></p><p><strong>1）例如一个集群结构如图：</strong></p><p><img src="../assets/es/ef30f03e68948523b2427754fe163349.png" alt="image-20210723225945963"></p><p>现在，node1是主节点，其它两个节点是从节点。</p><p><strong>2）突然，node1发生了故障：</strong></p><p><img src="../assets/es/a121dde6d1f676a1cb1d565feaf41ad6.png" alt="image-20210723230020574"></p><p><strong>宕机后的第一件事，需要重新选主，例如选中了node2：</strong></p><p><img src="../assets/es/28f68706acb3e7ad9419426b8d1873b2.png" alt="image-20210723230055974"></p><p><strong>node2成为主节点后，会检测集群监控状态，发现：shard-1、shard-0没有副本节点。因此需要将node1上的数据迁移到node2、node3：</strong></p><p><img src="../assets/es/6dd6f800d7b545907fb305f79099f044.png" alt="image-20210723230216642"></p><p><strong>实际演示：</strong></p><p>现在有三个节点，其中es01是主节点。</p><p><img src="../assets/es/4c8615c41550eed333c4124b90ceaf15.png" alt=""></p><p><strong>令es01宕机</strong></p><pre><code>docker-compose stop es01</code></pre><p>此时es01节点上的1主分片和0副本分片没了，主节点转到es03，控制es01节点的数据迁移到es02和03。</p><p>故障转移后，所有分片都有主分片和副本分片：</p><p><img src="../assets/es/ca16313524692c750fb8e87c9692a7ec.png" alt=""></p><p><strong>再恢复es01，发现主节点es03迁移出两个分片到es01：</strong></p><pre><code>docker-compose start es01</code></pre><p><img src="../assets/es/caf76cb00cd9eb0a076275fa1a865116.png" alt=""></p><ul><li><p><strong>master节点：</strong> 对CPU要求高，但是内存要求低</p></li><li><p><strong>data节点：</strong> 对CPU和内存要求都高</p></li><li><p><strong>coordinating节点：</strong> 对网络带宽、CPU要求高</p></li><li><p>参与集群选主</p></li><li><p><strong>主节点可以管理集群状态、管理分片信息、处理创建和删除索引库的请求</strong></p></li><li><p>数据的CRUD</p></li><li><p><strong>路由请求</strong> 到其它节点</p></li><li><p><strong>合并</strong> 查询到的 <strong>结果</strong> ，返回给用户</p></li><li><p>1）新增一个id=1的文档</p></li><li><p>2）对id做hash运算，假如得到的是2，则应该存储到shard-2</p></li><li><p>3）shard-2的主分片在node3节点，将数据路由到node3</p></li><li><p>4）保存文档</p></li><li><p>5）同步给shard-2的副本replica-2，在node2节点</p></li><li><p>6）返回结果给coordinating-node节点</p></li><li><p><strong>scatter phase：分散阶段</strong> ，coordinating node会把 <strong>请求分发到每一个分片</strong> （只有data节点保存分片数据）</p></li><li><p><strong>gather phase：聚集阶段</strong> ，coordinating node汇总data node的搜索结果，并处理为最终结果集返回给用户</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>elasticsearch学习笔记</title>
      <link href="/posts/fa44ecc1.html"/>
      <url>/posts/fa44ecc1.html</url>
      
        <content type="html"><![CDATA[<h2 id="第1章-Elasticsearch概述">第1章 Elasticsearch概述</h2><h3 id="01-开篇">01-开篇</h3><p><a href="https://www.bilibili.com/video/BV1hh411D7sb">教学视频</a></p><p>结构化数据</p><p><img src="../assets/elasticsearch/db146e37101d065a68674dd20f8ea3cb.png" alt=""></p><p>非结构化数据</p><p><img src="../assets/elasticsearch/c3de5021542b027c48467a9b5c9b7e48.png" alt=""></p><p>半结构化数据</p><p><img src="../assets/elasticsearch/3c67fdd415d410e9499cb505eddbdee4.png" alt=""></p><h3 id="02-技术选型">02-技术选型</h3><h4 id="Elasticsearch-是什么">Elasticsearch 是什么</h4><p>The Elastic Stack, 包括 Elasticsearch、 Kibana、 Beats 和 Logstash（也称为 ELK Stack）。能够安全可靠地获取任何来源、任何格式的数据，然后实时地对数据进行搜索、分析和可视化。</p><p>Elaticsearch，简称为 ES， ES 是一个 <strong>开源的高扩展的分布式全文搜索引擎</strong> ， 是整个 ElasticStack 技术栈的核心。</p><p>它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理 PB 级别的数据。</p><blockquote><p>elastic<br>英 [ɪˈlæstɪk] 美 [ɪˈlæstɪk]<br>n. 橡皮圈(或带);松紧带<br>adj. 橡皮圈(或带)的;有弹性的;有弹力的;灵活的;可改变的;可伸缩的</p></blockquote><h4 id="全文搜索引擎">全文搜索引擎</h4><p>Google，百度类的网站搜索，它们都是根据网页中的关键字生成索引，我们在搜索的时候输入关键字，它们会将该关键字即索引匹配到的所有网页返回；还有常见的项目中应用日志的搜索等等。对于这些非结构化的数据文本，关系型数据库搜索不是能很好的支持。</p><p>一般传统数据库，全文检索都实现的很鸡肋，因为一般也没人用数据库存文本字段。进行全文检索需要扫描整个表，如果数据量大的话即使对 SQL 的语法优化，也收效甚微。建立了索引，但是维护起来也很麻烦，对于 insert 和 update 操作都会重新构建索引。</p><p>基于以上原因可以分析得出，在一些生产环境中，使用常规的搜索方式，性能是非常差的：</p><ul><li>搜索的数据对象是大量的非结构化的文本数据。</li><li>文件记录量达到数十万或数百万个甚至更多。</li><li>支持大量基于交互式文本的查询。</li><li>需求非常灵活的全文搜索查询。</li><li>对高度相关的搜索结果的有特殊需求，但是没有可用的关系数据库可以满足。</li><li>对不同记录类型、非文本数据操作或安全事务处理的需求相对较少的情况。为了解决结构化数据搜索和非结构化数据搜索性能问题，我们就需要专业，健壮，强大的全文搜索引擎 。</li></ul><p><strong>这里说到的全文搜索引擎指的是目前广泛应用的主流搜索引擎</strong> 。它的工作原理是计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程。</p><h4 id="Elasticsearch-应用案例">Elasticsearch 应用案例</h4><ul><li>GitHub: 2013 年初，抛弃了 Solr，采取 Elasticsearch 来做 PB 级的搜索。 “GitHub 使用Elasticsearch 搜索 20TB 的数据，包括 13 亿文件和 1300 亿行代码”。</li><li>维基百科：启动以 Elasticsearch 为基础的核心搜索架构</li><li>百度：目前广泛使用 Elasticsearch 作为文本数据分析，采集百度所有服务器上的各类指标数据及用户自定义数据，通过对各种数据进行多维分析展示，辅助定位分析实例异常或业务层面异常。目前覆盖百度内部 20 多个业务线（包括云分析、网盟、预测、文库、直达号、钱包、 风控等），单集群最大 100 台机器， 200 个 ES 节点，每天导入 30TB+数据。</li><li>新浪：使用 Elasticsearch 分析处理 32 亿条实时日志。</li><li>阿里：使用 Elasticsearch 构建日志采集和分析体系。</li><li>Stack Overflow：解决 Bug 问题的网站，全英文，编程人员交流的网站。</li></ul><h3 id="03-教学大纲">03-教学大纲</h3><ul><li>第1章 Elasticsearch概述</li><li>第2章 Elasticsearch入门</li><li>第3章 Elasticsearch环境</li><li>第4章 Elasticsearch进阶</li><li>第5章 Elasticsearch集成</li><li>第6章 Elasticsearch优化</li><li>第7章 Elasticsearch面试题</li></ul><h2 id="第2章-Elasticsearch入门">第2章 Elasticsearch入门</h2><h3 id="04-入门-环境准备">04-入门-环境准备</h3><p><a href="https://www.elastic.co/cn/">官方网址</a></p><p><a href="https://www.elastic.co/guide/index.html">官方文档</a></p><p><a href="https://www.elastic.co/cn/downloads/past-releases/elasticsearch-7-8-0">Elasticsearch 7.8.0下载页面</a></p><p>Windows 版的 Elasticsearch 压缩包，解压即安装完毕，解压后的 Elasticsearch 的目录结构如下 ：</p><table><thead><tr><th>目录</th><th>含义</th></tr></thead><tbody><tr><td>bin</td><td>可执行脚本目录</td></tr><tr><td>config</td><td>配置目录</td></tr><tr><td>jdk</td><td>内置 JDK 目录</td></tr><tr><td>lib</td><td>类库</td></tr><tr><td>logs</td><td>日志目录</td></tr><tr><td>modules</td><td>模块目录</td></tr><tr><td>plugins</td><td>插件目录</td></tr></tbody></table><p>解压后，进入 bin 文件目录，点击 elasticsearch.bat 文件启动 ES 服务 。</p><p>注意： 9300 端口为 Elasticsearch 集群间组件的通信端口， 9200 端口为浏览器访问的 http协议 RESTful 端口。</p><p>打开浏览器，输入地址： <a href="http://localhost:9200">http://localhost:9200</a>，测试返回结果，返回结果如下：</p><pre><code>&#123;  &quot;name&quot; : &quot;DESKTOP-LNJQ0VF&quot;,  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,  &quot;cluster_uuid&quot; : &quot;nCZqBhfdT1-pw8Yas4QU9w&quot;,  &quot;version&quot; : &#123;    &quot;number&quot; : &quot;7.8.0&quot;,    &quot;build_flavor&quot; : &quot;default&quot;,    &quot;build_type&quot; : &quot;zip&quot;,    &quot;build_hash&quot; : &quot;757314695644ea9a1dc2fecd26d1a43856725e65&quot;,    &quot;build_date&quot; : &quot;2020-06-14T19:35:50.234439Z&quot;,    &quot;build_snapshot&quot; : false,    &quot;lucene_version&quot; : &quot;8.5.1&quot;,    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;  &#125;,  &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125;</code></pre><h3 id="05-入门-RESTful-JSON">05-入门-RESTful &amp; JSON</h3><p>REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。 Web 应用程序最重要的 REST 原则是，客户端和服务器之间的交互在请求之间是无状态的。从客户端到服务器的每个请求都必须包含理解请求所必需的信息。如果服务器在请求之间的任何时间点重启，客户端不会得到通知。此外，无状态请求可以由任何可用服务器回答，这十分适合云计算之类的环境。客户端可以缓存数据以改进性能。</p><p>在服务器端，应用程序状态和功能可以分为各种资源。资源是一个有趣的概念实体，它向客户端公开。资源的例子有：应用程序对象、数据库记录、算法等等。每个资源都使用 URI(Universal Resource Identifier) 得到一个唯一的地址。所有资源都共享统一的接口，以便在客户端和服务器之间传输状态。使用的是标准的 HTTP 方法，比如 GET、 PUT、 POST 和DELETE。</p><p>在 REST 样式的 Web 服务中，每个资源都有一个地址。资源本身都是方法调用的目<br>标，方法列表对所有资源都是一样的。这些方法都是标准方法，包括 HTTP GET、 POST、PUT、 DELETE，还可能包括 HEAD 和 OPTIONS。简单的理解就是， <strong>如果想要访问互联网上的资源，就必须向资源所在的服务器发出请求，请求体中必须包含资源的网络路径， 以及对资源进行的操作(增删改查)</strong> 。</p><p>REST 样式的 Web 服务若有返回结果，大多数以JSON字符串形式返回。</p><h3 id="06-入门-Postman客户端工具">06-入门-Postman客户端工具</h3><p>如果直接通过浏览器向 Elasticsearch 服务器发请求，那么需要在发送的请求中包含<br>HTTP 标准的方法，而 HTTP 的大部分特性且仅支持 GET 和 POST 方法。所以为了能方便地进行客户端的访问，可以使用 Postman 软件Postman 是一款强大的网页调试工具，提供功能强大的 Web API 和 HTTP 请求调试。</p><p>软件功能强大，界面简洁明晰、操作方便快捷，设计得很人性化。 Postman 中文版能够发送任何类型的 HTTP 请求 (GET, HEAD, POST, PUT…)，不仅能够表单提交，且可以附带任意类型请求体。</p><p><a href="https://www.postman.com/downloads/">Postman下载页面</a></p><h3 id="07-入门-倒排索引">07-入门-倒排索引</h3><p>正排索引（传统）</p><table><thead><tr><th>id</th><th>content</th></tr></thead><tbody><tr><td>1001</td><td>my name is zhang san</td></tr><tr><td>1002</td><td>my name is li si</td></tr></tbody></table><p>倒排索引</p><table><thead><tr><th>keyword</th><th>id</th></tr></thead><tbody><tr><td>name</td><td>1001, 1002</td></tr><tr><td>zhang</td><td>1001</td></tr></tbody></table><p>Elasticsearch 是 <strong>面向文档型数据库</strong> ，一条数据在这里就是一个文档。 为了方便大家理解，我们将 Elasticsearch 里存储文档数据和关系型数据库 MySQL 存储数据的概念进行一个类比</p><p><img src="../assets/elasticsearch/fb2d75748469e8880f85ff9825557db4.png" alt=""></p><p>ES 里的 Index 可以看做一个库，而 Types 相当于表， Documents 则相当于表的行。这里 Types 的概念已经被逐渐弱化， Elasticsearch 6.X 中，一个 index 下已经只能包含一个type， Elasticsearch 7.X 中, Type 的概念已经被删除了。</p><h3 id="08-入门-HTTP-索引-创建">08-入门-HTTP-索引-创建</h3><p>对比关系型数据库，创建索引就等同于创建数据库。</p><p>在 Postman 中，向 ES 服务器发 PUT 请求 ： <a href="http://127.0.0.1:9200/shopping">http://127.0.0.1:9200/shopping</a></p><p>请求后，服务器返回响应：</p><pre><code>&#123;    &quot;acknowledged&quot;: true,//响应结果    &quot;shards_acknowledged&quot;: true,//分片结果    &quot;index&quot;: &quot;shopping&quot;//索引名称&#125;</code></pre><p>后台日志：</p><pre><code>[2021-04-08T13:57:06,954][INFO ][o.e.c.m.MetadataCreateIndexService] [DESKTOP-LNJQ0VF] [shopping] creating index, cause [api], templates [], shards [1]/[1], mappings []</code></pre><p>如果重复发 PUT 请求 ： <a href="http://127.0.0.1:9200/shopping">http://127.0.0.1:9200/shopping</a> 添加索引，会返回错误信息 :</p><pre><code>&#123;    &quot;error&quot;: &#123;        &quot;root_cause&quot;: [            &#123;                &quot;type&quot;: &quot;resource_already_exists_exception&quot;,                &quot;reason&quot;: &quot;index [shopping/J0WlEhh4R7aDrfIc3AkwWQ] already exists&quot;,                &quot;index_uuid&quot;: &quot;J0WlEhh4R7aDrfIc3AkwWQ&quot;,                &quot;index&quot;: &quot;shopping&quot;            &#125;        ],        &quot;type&quot;: &quot;resource_already_exists_exception&quot;,        &quot;reason&quot;: &quot;index [shopping/J0WlEhh4R7aDrfIc3AkwWQ] already exists&quot;,        &quot;index_uuid&quot;: &quot;J0WlEhh4R7aDrfIc3AkwWQ&quot;,        &quot;index&quot;: &quot;shopping&quot;    &#125;,    &quot;status&quot;: 400&#125;</code></pre><h3 id="09-入门-HTTP-索引-查询-删除">09-入门-HTTP-索引-查询 &amp; 删除</h3><h4 id="查看所有索引">查看所有索引</h4><p>在 Postman 中，向 ES 服务器发 GET 请求 ： <a href="http://127.0.0.1:9200/_cat/indices?v">http://127.0.0.1:9200/_cat/indices?v</a></p><p>这里请求路径中的_cat 表示查看的意思， indices 表示索引，所以整体含义就是查看当前 ES服务器中的所有索引，就好像 MySQL 中的 show tables 的感觉，服务器响应结果如下 :</p><pre><code>health status index    uuid                   pri rep docs.count docs.deleted store.size pri.store.sizeyellow open   shopping J0WlEhh4R7aDrfIc3AkwWQ   1   1          0            0       208b           208b</code></pre><table><thead><tr><th>表头</th><th>含义</th></tr></thead><tbody><tr><td>health</td><td>当前服务器健康状态： green(集群完整) yellow(单点正常、集群不完整) red(单点不正常)</td></tr><tr><td>status</td><td>索引打开、关闭状态</td></tr><tr><td>index</td><td>索引名</td></tr><tr><td>uuid</td><td>索引统一编号</td></tr><tr><td>pri</td><td>主分片数量</td></tr><tr><td>rep</td><td>副本数量</td></tr><tr><td>docs.count</td><td>可用文档数量</td></tr><tr><td>docs.deleted</td><td>文档删除状态（逻辑删除）</td></tr><tr><td>store.size</td><td>主分片和副分片整体占空间大小</td></tr><tr><td>pri.store.size</td><td>主分片占空间大小</td></tr></tbody></table><h4 id="查看单个索引">查看单个索引</h4><p>在 Postman 中，向 ES 服务器发 GET 请求 ： <a href="http://127.0.0.1:9200/shopping">http://127.0.0.1:9200/shopping</a></p><p>返回结果如下：</p><pre><code>&#123;    &quot;shopping&quot;: &#123;//索引名        &quot;aliases&quot;: &#123;&#125;,//别名        &quot;mappings&quot;: &#123;&#125;,//映射        &quot;settings&quot;: &#123;//设置            &quot;index&quot;: &#123;//设置 - 索引                &quot;creation_date&quot;: &quot;1617861426847&quot;,//设置 - 索引 - 创建时间                &quot;number_of_shards&quot;: &quot;1&quot;,//设置 - 索引 - 主分片数量                &quot;number_of_replicas&quot;: &quot;1&quot;,//设置 - 索引 - 主分片数量                &quot;uuid&quot;: &quot;J0WlEhh4R7aDrfIc3AkwWQ&quot;,//设置 - 索引 - 主分片数量                &quot;version&quot;: &#123;//设置 - 索引 - 主分片数量                    &quot;created&quot;: &quot;7080099&quot;                &#125;,                &quot;provided_name&quot;: &quot;shopping&quot;//设置 - 索引 - 主分片数量            &#125;        &#125;    &#125;&#125;</code></pre><h4 id="删除索引">删除索引</h4><p>在 Postman 中，向 ES 服务器发 DELETE 请求 ： <a href="http://127.0.0.1:9200/shopping">http://127.0.0.1:9200/shopping</a></p><p>返回结果如下：</p><pre><code>&#123;    &quot;acknowledged&quot;: true&#125;</code></pre><p>再次查看所有索引，GET <a href="http://127.0.0.1:9200/_cat/indices?v%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:9200/_cat/indices?v，返回结果如下：</a></p><pre><code>health status index uuid pri rep docs.count docs.deleted store.size pri.store.size</code></pre><p>成功删除。</p><h3 id="10-入门-HTTP-文档-创建（Put-Post）">10-入门-HTTP-文档-创建（Put &amp; Post）</h3><p>假设索引已经创建好了，接下来我们来创建文档，并添加数据。这里的文档可以类比为关系型数据库中的表数据，添加的数据格式为 JSON 格式</p><p>在 Postman 中，向 ES 服务器发 POST 请求 ： <a href="http://127.0.0.1:9200/shopping/_doc%EF%BC%8C%E8%AF%B7%E6%B1%82%E4%BD%93JSON%E5%86%85%E5%AE%B9%E4%B8%BA%EF%BC%9A">http://127.0.0.1:9200/shopping/_doc，请求体JSON内容为：</a></p><pre><code>&#123;    &quot;title&quot;:&quot;小米手机&quot;,    &quot;category&quot;:&quot;小米&quot;,    &quot;images&quot;:&quot;http://www.gulixueyuan.com/xm.jpg&quot;,    &quot;price&quot;:3999.00&#125;</code></pre><p><img src="../assets/elasticsearch/c59ec2604a4f54678f1249112cc125fd.png" alt=""></p><p>注意，此处发送请求的方式必须为 POST，不能是 PUT，否则会发生错误 。</p><p>返回结果：</p><pre><code>&#123;    &quot;_index&quot;: &quot;shopping&quot;,//索引    &quot;_type&quot;: &quot;_doc&quot;,//类型-文档    &quot;_id&quot;: &quot;ANQqsHgBaKNfVnMbhZYU&quot;,//唯一标识，可以类比为 MySQL 中的主键，随机生成    &quot;_version&quot;: 1,//版本    &quot;result&quot;: &quot;created&quot;,//结果，这里的 create 表示创建成功    &quot;_shards&quot;: &#123;//        &quot;total&quot;: 2,//分片 - 总数        &quot;successful&quot;: 1,//分片 - 总数        &quot;failed&quot;: 0//分片 - 总数    &#125;,    &quot;_seq_no&quot;: 0,    &quot;_primary_term&quot;: 1&#125;</code></pre><p>上面的数据创建后，由于没有指定数据唯一性标识（ID），默认情况下， ES 服务器会随机生成一个。</p><p>如果想要自定义唯一性标识，需要在创建时指定： <a href="http://127.0.0.1:9200/shopping/_doc/1%EF%BC%8C%E8%AF%B7%E6%B1%82%E4%BD%93JSON%E5%86%85%E5%AE%B9%E4%B8%BA%EF%BC%9A">http://127.0.0.1:9200/shopping/_doc/1，请求体JSON内容为：</a></p><pre><code>&#123;    &quot;title&quot;:&quot;小米手机&quot;,    &quot;category&quot;:&quot;小米&quot;,    &quot;images&quot;:&quot;http://www.gulixueyuan.com/xm.jpg&quot;,    &quot;price&quot;:3999.00&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;_index&quot;: &quot;shopping&quot;,    &quot;_type&quot;: &quot;_doc&quot;,    &quot;_id&quot;: &quot;1&quot;,//&lt;------------------自定义唯一性标识    &quot;_version&quot;: 1,    &quot;result&quot;: &quot;created&quot;,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 2,        &quot;successful&quot;: 1,        &quot;failed&quot;: 0    &#125;,    &quot;_seq_no&quot;: 1,    &quot;_primary_term&quot;: 1&#125;</code></pre><p><strong>此处需要注意：如果增加数据时明确数据主键，那么请求方式也可以为 PUT。</strong></p><h3 id="11-入门-HTTP-查询-主键查询-全查询">11-入门-HTTP-查询-主键查询 &amp; 全查询</h3><p>查看文档时，需要指明文档的唯一性标识，类似于 MySQL 中数据的主键查询</p><p>在 Postman 中，向 ES 服务器发 GET 请求 ： <a href="http://127.0.0.1:9200/shopping/_doc/1">http://127.0.0.1:9200/shopping/_doc/1</a> 。</p><p>返回结果如下：</p><pre><code>&#123;    &quot;_index&quot;: &quot;shopping&quot;,    &quot;_type&quot;: &quot;_doc&quot;,    &quot;_id&quot;: &quot;1&quot;,    &quot;_version&quot;: 1,    &quot;_seq_no&quot;: 1,    &quot;_primary_term&quot;: 1,    &quot;found&quot;: true,    &quot;_source&quot;: &#123;        &quot;title&quot;: &quot;小米手机&quot;,        &quot;category&quot;: &quot;小米&quot;,        &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,        &quot;price&quot;: 3999    &#125;&#125;</code></pre><p>查找不存在的内容，向 ES 服务器发 GET 请求 ： <a href="http://127.0.0.1:9200/shopping/_doc/1001%E3%80%82">http://127.0.0.1:9200/shopping/_doc/1001。</a></p><p>返回结果如下：</p><pre><code>&#123;    &quot;_index&quot;: &quot;shopping&quot;,    &quot;_type&quot;: &quot;_doc&quot;,    &quot;_id&quot;: &quot;1001&quot;,    &quot;found&quot;: false&#125;</code></pre><p>查看索引下所有数据，向 ES 服务器发 GET 请求 ： <a href="http://127.0.0.1:9200/shopping/_search%E3%80%82">http://127.0.0.1:9200/shopping/_search。</a></p><p>返回结果如下：</p><pre><code>&#123;    &quot;took&quot;: 133,    &quot;timed_out&quot;: false,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 1,        &quot;successful&quot;: 1,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0    &#125;,    &quot;hits&quot;: &#123;        &quot;total&quot;: &#123;            &quot;value&quot;: 2,            &quot;relation&quot;: &quot;eq&quot;        &#125;,        &quot;max_score&quot;: 1,        &quot;hits&quot;: [            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;ANQqsHgBaKNfVnMbhZYU&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 3999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;1&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 3999                &#125;            &#125;        ]    &#125;&#125;</code></pre><h3 id="12-入门-HTTP-全量修改-局部修改-删除">12-入门-HTTP-全量修改 &amp; 局部修改 &amp; 删除</h3><h4 id="全量修改">全量修改</h4><p>和新增文档一样，输入相同的 URL 地址请求，如果请求体变化，会将原有的数据内容覆盖</p><p>在 Postman 中，向 ES 服务器发 POST 请求 ： <a href="http://127.0.0.1:9200/shopping/_doc/1">http://127.0.0.1:9200/shopping/_doc/1</a></p><p>请求体JSON内容为:</p><pre><code>&#123;    &quot;title&quot;:&quot;华为手机&quot;,    &quot;category&quot;:&quot;华为&quot;,    &quot;images&quot;:&quot;http://www.gulixueyuan.com/hw.jpg&quot;,    &quot;price&quot;:1999.00&#125;</code></pre><p>修改成功后，服务器响应结果：</p><pre><code>&#123;    &quot;_index&quot;: &quot;shopping&quot;,    &quot;_type&quot;: &quot;_doc&quot;,    &quot;_id&quot;: &quot;1&quot;,    &quot;_version&quot;: 2,    &quot;result&quot;: &quot;updated&quot;,//&lt;-----------updated 表示数据被更新    &quot;_shards&quot;: &#123;        &quot;total&quot;: 2,        &quot;successful&quot;: 1,        &quot;failed&quot;: 0    &#125;,    &quot;_seq_no&quot;: 2,    &quot;_primary_term&quot;: 1&#125;</code></pre><h4 id="局部修改">局部修改</h4><p>修改数据时，也可以只修改某一给条数据的局部信息</p><p>在 Postman 中，向 ES 服务器发 POST 请求 ： <a href="http://127.0.0.1:9200/shopping/_update/1%E3%80%82">http://127.0.0.1:9200/shopping/_update/1。</a></p><p>请求体JSON内容为:</p><pre><code>&#123;&quot;doc&quot;: &#123;&quot;title&quot;:&quot;小米手机&quot;,&quot;category&quot;:&quot;小米&quot;&#125;&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;_index&quot;: &quot;shopping&quot;,    &quot;_type&quot;: &quot;_doc&quot;,    &quot;_id&quot;: &quot;1&quot;,    &quot;_version&quot;: 3,    &quot;result&quot;: &quot;updated&quot;,//&lt;-----------updated 表示数据被更新    &quot;_shards&quot;: &#123;        &quot;total&quot;: 2,        &quot;successful&quot;: 1,        &quot;failed&quot;: 0    &#125;,    &quot;_seq_no&quot;: 3,    &quot;_primary_term&quot;: 1&#125;</code></pre><p>在 Postman 中，向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_doc/1%EF%BC%8C%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E5%86%85%E5%AE%B9%EF%BC%9A">http://127.0.0.1:9200/shopping/_doc/1，查看修改内容：</a></p><pre><code>&#123;    &quot;_index&quot;: &quot;shopping&quot;,    &quot;_type&quot;: &quot;_doc&quot;,    &quot;_id&quot;: &quot;1&quot;,    &quot;_version&quot;: 3,    &quot;_seq_no&quot;: 3,    &quot;_primary_term&quot;: 1,    &quot;found&quot;: true,    &quot;_source&quot;: &#123;        &quot;title&quot;: &quot;小米手机&quot;,        &quot;category&quot;: &quot;小米&quot;,        &quot;images&quot;: &quot;http://www.gulixueyuan.com/hw.jpg&quot;,        &quot;price&quot;: 1999    &#125;&#125;</code></pre><h4 id="删除">删除</h4><p>删除一个文档不会立即从磁盘上移除，它只是被标记成已删除（逻辑删除）。</p><p>在 Postman 中，向 ES 服务器发 DELETE 请求 ： <a href="http://127.0.0.1:9200/shopping/_doc/1">http://127.0.0.1:9200/shopping/_doc/1</a></p><p>返回结果：</p><pre><code>&#123;    &quot;_index&quot;: &quot;shopping&quot;,    &quot;_type&quot;: &quot;_doc&quot;,    &quot;_id&quot;: &quot;1&quot;,    &quot;_version&quot;: 4,    &quot;result&quot;: &quot;deleted&quot;,//&lt;---删除成功    &quot;_shards&quot;: &#123;        &quot;total&quot;: 2,        &quot;successful&quot;: 1,        &quot;failed&quot;: 0    &#125;,    &quot;_seq_no&quot;: 4,    &quot;_primary_term&quot;: 1&#125;</code></pre><p>在 Postman 中，向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_doc/1%EF%BC%8C%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E5%88%A0%E9%99%A4%E6%88%90%E5%8A%9F%EF%BC%9A">http://127.0.0.1:9200/shopping/_doc/1，查看是否删除成功：</a></p><pre><code>&#123;    &quot;_index&quot;: &quot;shopping&quot;,    &quot;_type&quot;: &quot;_doc&quot;,    &quot;_id&quot;: &quot;1&quot;,    &quot;found&quot;: false&#125;</code></pre><h3 id="13-入门-HTTP-条件查询-分页查询-查询排序">13-入门-HTTP-条件查询 &amp; 分页查询 &amp; 查询排序</h3><h4 id="条件查询">条件查询</h4><p>假设有以下文档内容，（在 Postman 中，向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_search%EF%BC%89%EF%BC%9A">http://127.0.0.1:9200/shopping/_search）：</a></p><pre><code>&#123;    &quot;took&quot;: 5,    &quot;timed_out&quot;: false,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 1,        &quot;successful&quot;: 1,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0    &#125;,    &quot;hits&quot;: &#123;        &quot;total&quot;: &#123;            &quot;value&quot;: 6,            &quot;relation&quot;: &quot;eq&quot;        &#125;,        &quot;max_score&quot;: 1,        &quot;hits&quot;: [            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;ANQqsHgBaKNfVnMbhZYU&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 3999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;A9R5sHgBaKNfVnMb25Ya&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;BNR5sHgBaKNfVnMb7pal&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;BtR6sHgBaKNfVnMbX5Y5&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;B9R6sHgBaKNfVnMbZpZ6&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;CdR7sHgBaKNfVnMbsJb9&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;        ]    &#125;&#125;</code></pre><h5 id="URL带参查询">URL带参查询</h5><p><strong>查找category为小米的文档</strong> ，在 Postman 中，向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_search?q=category:%E5%B0%8F%E7%B1%B3%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:9200/shopping/_search?q=category:小米，返回结果如下：</a></p><pre><code>&#123;    &quot;took&quot;: 94,    &quot;timed_out&quot;: false,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 1,        &quot;successful&quot;: 1,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0    &#125;,    &quot;hits&quot;: &#123;        &quot;total&quot;: &#123;            &quot;value&quot;: 3,            &quot;relation&quot;: &quot;eq&quot;        &#125;,        &quot;max_score&quot;: 1.3862942,        &quot;hits&quot;: [            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;ANQqsHgBaKNfVnMbhZYU&quot;,                &quot;_score&quot;: 1.3862942,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 3999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;A9R5sHgBaKNfVnMb25Ya&quot;,                &quot;_score&quot;: 1.3862942,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;BNR5sHgBaKNfVnMb7pal&quot;,                &quot;_score&quot;: 1.3862942,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;        ]    &#125;&#125;</code></pre><p>上述为URL带参数形式查询，这很容易让不善者心怀恶意，或者参数值出现中文会出现乱码情况。为了避免这些情况，我们可用使用带JSON请求体请求进行查询。</p><h5 id="请求体带参查询">请求体带参查询</h5><p>接下带JSON请求体，还是 <strong>查找category为小米的文档</strong> ，在 Postman 中，向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_search%EF%BC%8C%E9%99%84%E5%B8%A6JSON%E4%BD%93%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:9200/shopping/_search，附带JSON体如下：</a></p><pre><code>&#123;&quot;query&quot;:&#123;&quot;match&quot;:&#123;&quot;category&quot;:&quot;小米&quot;&#125;&#125;&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;took&quot;: 3,    &quot;timed_out&quot;: false,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 1,        &quot;successful&quot;: 1,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0    &#125;,    &quot;hits&quot;: &#123;        &quot;total&quot;: &#123;            &quot;value&quot;: 3,            &quot;relation&quot;: &quot;eq&quot;        &#125;,        &quot;max_score&quot;: 1.3862942,        &quot;hits&quot;: [            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;ANQqsHgBaKNfVnMbhZYU&quot;,                &quot;_score&quot;: 1.3862942,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 3999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;A9R5sHgBaKNfVnMb25Ya&quot;,                &quot;_score&quot;: 1.3862942,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;BNR5sHgBaKNfVnMb7pal&quot;,                &quot;_score&quot;: 1.3862942,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;        ]    &#125;&#125;</code></pre><h5 id="带请求体方式的查找所有内容">带请求体方式的查找所有内容</h5><p><strong>查找所有文档内容</strong> ，也可以这样，在 Postman 中，向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_search%EF%BC%8C%E9%99%84%E5%B8%A6JSON%E4%BD%93%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:9200/shopping/_search，附带JSON体如下：</a></p><pre><code>&#123;&quot;query&quot;:&#123;&quot;match_all&quot;:&#123;&#125;&#125;&#125;</code></pre><p>则返回所有文档内容：</p><pre><code>&#123;    &quot;took&quot;: 2,    &quot;timed_out&quot;: false,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 1,        &quot;successful&quot;: 1,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0    &#125;,    &quot;hits&quot;: &#123;        &quot;total&quot;: &#123;            &quot;value&quot;: 6,            &quot;relation&quot;: &quot;eq&quot;        &#125;,        &quot;max_score&quot;: 1,        &quot;hits&quot;: [            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;ANQqsHgBaKNfVnMbhZYU&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 3999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;A9R5sHgBaKNfVnMb25Ya&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;BNR5sHgBaKNfVnMb7pal&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;BtR6sHgBaKNfVnMbX5Y5&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;B9R6sHgBaKNfVnMbZpZ6&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;CdR7sHgBaKNfVnMbsJb9&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;        ]    &#125;&#125;</code></pre><h5 id="查询指定字段">查询指定字段</h5><p><strong>如果你想查询指定字段</strong> ，在 Postman 中，向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_search%EF%BC%8C%E9%99%84%E5%B8%A6JSON%E4%BD%93%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:9200/shopping/_search，附带JSON体如下：</a></p><pre><code>&#123;&quot;query&quot;:&#123;&quot;match_all&quot;:&#123;&#125;&#125;,&quot;_source&quot;:[&quot;title&quot;]&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;took&quot;: 5,    &quot;timed_out&quot;: false,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 1,        &quot;successful&quot;: 1,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0    &#125;,    &quot;hits&quot;: &#123;        &quot;total&quot;: &#123;            &quot;value&quot;: 6,            &quot;relation&quot;: &quot;eq&quot;        &#125;,        &quot;max_score&quot;: 1,        &quot;hits&quot;: [            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;ANQqsHgBaKNfVnMbhZYU&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;A9R5sHgBaKNfVnMb25Ya&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;BNR5sHgBaKNfVnMb7pal&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;BtR6sHgBaKNfVnMbX5Y5&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;B9R6sHgBaKNfVnMbZpZ6&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;CdR7sHgBaKNfVnMbsJb9&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;                &#125;            &#125;        ]    &#125;&#125;</code></pre><h4 id="分页查询">分页查询</h4><p>在 Postman 中，向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_search%EF%BC%8C%E9%99%84%E5%B8%A6JSON%E4%BD%93%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:9200/shopping/_search，附带JSON体如下：</a></p><pre><code>&#123;&quot;query&quot;:&#123;&quot;match_all&quot;:&#123;&#125;&#125;,&quot;from&quot;:0,&quot;size&quot;:2&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;took&quot;: 1,    &quot;timed_out&quot;: false,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 1,        &quot;successful&quot;: 1,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0    &#125;,    &quot;hits&quot;: &#123;        &quot;total&quot;: &#123;            &quot;value&quot;: 6,            &quot;relation&quot;: &quot;eq&quot;        &#125;,        &quot;max_score&quot;: 1,        &quot;hits&quot;: [            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;ANQqsHgBaKNfVnMbhZYU&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 3999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;A9R5sHgBaKNfVnMb25Ya&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;        ]    &#125;&#125;</code></pre><h4 id="查询排序">查询排序</h4><p>如果你想通过排序查出价格最高的手机，在 Postman 中，向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_search%EF%BC%8C%E9%99%84%E5%B8%A6JSON%E4%BD%93%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:9200/shopping/_search，附带JSON体如下：</a></p><pre><code>&#123;&quot;query&quot;:&#123;&quot;match_all&quot;:&#123;&#125;&#125;,&quot;sort&quot;:&#123;&quot;price&quot;:&#123;&quot;order&quot;:&quot;desc&quot;&#125;&#125;&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;took&quot;: 96,    &quot;timed_out&quot;: false,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 1,        &quot;successful&quot;: 1,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0    &#125;,    &quot;hits&quot;: &#123;        &quot;total&quot;: &#123;            &quot;value&quot;: 6,            &quot;relation&quot;: &quot;eq&quot;        &#125;,        &quot;max_score&quot;: null,        &quot;hits&quot;: [            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;ANQqsHgBaKNfVnMbhZYU&quot;,                &quot;_score&quot;: null,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 3999                &#125;,                &quot;sort&quot;: [                    3999                ]            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;A9R5sHgBaKNfVnMb25Ya&quot;,                &quot;_score&quot;: null,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;,                &quot;sort&quot;: [                    1999                ]            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;BNR5sHgBaKNfVnMb7pal&quot;,                &quot;_score&quot;: null,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;,                &quot;sort&quot;: [                    1999                ]            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;BtR6sHgBaKNfVnMbX5Y5&quot;,                &quot;_score&quot;: null,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;,                &quot;sort&quot;: [                    1999                ]            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;B9R6sHgBaKNfVnMbZpZ6&quot;,                &quot;_score&quot;: null,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;,                &quot;sort&quot;: [                    1999                ]            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;CdR7sHgBaKNfVnMbsJb9&quot;,                &quot;_score&quot;: null,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;,                &quot;sort&quot;: [                    1999                ]            &#125;        ]    &#125;&#125;</code></pre><h3 id="14-入门-HTTP-多条件查询-范围查询">14-入门-HTTP-多条件查询 &amp; 范围查询</h3><h4 id="多条件查询">多条件查询</h4><p>假设想找出小米牌子，价格为3999元的。（must相当于数据库的&amp;&amp;）</p><p>在 Postman 中，向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_search%EF%BC%8C%E9%99%84%E5%B8%A6JSON%E4%BD%93%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:9200/shopping/_search，附带JSON体如下：</a></p><pre><code>&#123;&quot;query&quot;:&#123;&quot;bool&quot;:&#123;&quot;must&quot;:[&#123;&quot;match&quot;:&#123;&quot;category&quot;:&quot;小米&quot;&#125;&#125;,&#123;&quot;match&quot;:&#123;&quot;price&quot;:3999.00&#125;&#125;]&#125;&#125;&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;took&quot;: 134,    &quot;timed_out&quot;: false,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 1,        &quot;successful&quot;: 1,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0    &#125;,    &quot;hits&quot;: &#123;        &quot;total&quot;: &#123;            &quot;value&quot;: 1,            &quot;relation&quot;: &quot;eq&quot;        &#125;,        &quot;max_score&quot;: 2.3862944,        &quot;hits&quot;: [            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;ANQqsHgBaKNfVnMbhZYU&quot;,                &quot;_score&quot;: 2.3862944,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 3999                &#125;            &#125;        ]    &#125;&#125;</code></pre><p>假设想找出小米和华为的牌子。（should相当于数据库的||）</p><p>在 Postman 中，向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_search%EF%BC%8C%E9%99%84%E5%B8%A6JSON%E4%BD%93%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:9200/shopping/_search，附带JSON体如下：</a></p><pre><code>&#123;&quot;query&quot;:&#123;&quot;bool&quot;:&#123;&quot;should&quot;:[&#123;&quot;match&quot;:&#123;&quot;category&quot;:&quot;小米&quot;&#125;&#125;,&#123;&quot;match&quot;:&#123;&quot;category&quot;:&quot;华为&quot;&#125;&#125;]&#125;,        &quot;filter&quot;:&#123;            &quot;range&quot;:&#123;                &quot;price&quot;:&#123;                    &quot;gt&quot;:2000                &#125;            &#125;        &#125;&#125;&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;took&quot;: 8,    &quot;timed_out&quot;: false,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 1,        &quot;successful&quot;: 1,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0    &#125;,    &quot;hits&quot;: &#123;        &quot;total&quot;: &#123;            &quot;value&quot;: 6,            &quot;relation&quot;: &quot;eq&quot;        &#125;,        &quot;max_score&quot;: 1.3862942,        &quot;hits&quot;: [            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;ANQqsHgBaKNfVnMbhZYU&quot;,                &quot;_score&quot;: 1.3862942,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 3999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;A9R5sHgBaKNfVnMb25Ya&quot;,                &quot;_score&quot;: 1.3862942,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;BNR5sHgBaKNfVnMb7pal&quot;,                &quot;_score&quot;: 1.3862942,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;BtR6sHgBaKNfVnMbX5Y5&quot;,                &quot;_score&quot;: 1.3862942,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;B9R6sHgBaKNfVnMbZpZ6&quot;,                &quot;_score&quot;: 1.3862942,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;CdR7sHgBaKNfVnMbsJb9&quot;,                &quot;_score&quot;: 1.3862942,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;        ]    &#125;&#125;</code></pre><h4 id="范围查询">范围查询</h4><p>假设想找出小米和华为的牌子，价格大于2000元的手机。</p><p>在 Postman 中，向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_search%EF%BC%8C%E9%99%84%E5%B8%A6JSON%E4%BD%93%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:9200/shopping/_search，附带JSON体如下：</a></p><pre><code>&#123;&quot;query&quot;:&#123;&quot;bool&quot;:&#123;&quot;should&quot;:[&#123;&quot;match&quot;:&#123;&quot;category&quot;:&quot;小米&quot;&#125;&#125;,&#123;&quot;match&quot;:&#123;&quot;category&quot;:&quot;华为&quot;&#125;&#125;],            &quot;filter&quot;:&#123;            &quot;range&quot;:&#123;                &quot;price&quot;:&#123;                    &quot;gt&quot;:2000                &#125;            &#125;        &#125;&#125;&#125;&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;took&quot;: 72,    &quot;timed_out&quot;: false,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 1,        &quot;successful&quot;: 1,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0    &#125;,    &quot;hits&quot;: &#123;        &quot;total&quot;: &#123;            &quot;value&quot;: 1,            &quot;relation&quot;: &quot;eq&quot;        &#125;,        &quot;max_score&quot;: 1.3862942,        &quot;hits&quot;: [            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;ANQqsHgBaKNfVnMbhZYU&quot;,                &quot;_score&quot;: 1.3862942,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 3999                &#125;            &#125;        ]    &#125;&#125;</code></pre><h3 id="15-入门-HTTP-全文检索-完全匹配-高亮查询">15-入门-HTTP-全文检索 &amp; 完全匹配 &amp; 高亮查询</h3><h4 id="全文检索">全文检索</h4><p>这功能像搜索引擎那样，如品牌输入“小华”，返回结果带回品牌有“小米”和华为的。</p><p>在 Postman 中，向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_search%EF%BC%8C%E9%99%84%E5%B8%A6JSON%E4%BD%93%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:9200/shopping/_search，附带JSON体如下：</a></p><pre><code>&#123;&quot;query&quot;:&#123;&quot;match&quot;:&#123;&quot;category&quot; : &quot;小华&quot;&#125;&#125;&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;took&quot;: 7,    &quot;timed_out&quot;: false,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 1,        &quot;successful&quot;: 1,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0    &#125;,    &quot;hits&quot;: &#123;        &quot;total&quot;: &#123;            &quot;value&quot;: 6,            &quot;relation&quot;: &quot;eq&quot;        &#125;,        &quot;max_score&quot;: 0.6931471,        &quot;hits&quot;: [            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;ANQqsHgBaKNfVnMbhZYU&quot;,                &quot;_score&quot;: 0.6931471,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 3999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;A9R5sHgBaKNfVnMb25Ya&quot;,                &quot;_score&quot;: 0.6931471,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;BNR5sHgBaKNfVnMb7pal&quot;,                &quot;_score&quot;: 0.6931471,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;BtR6sHgBaKNfVnMbX5Y5&quot;,                &quot;_score&quot;: 0.6931471,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;B9R6sHgBaKNfVnMbZpZ6&quot;,                &quot;_score&quot;: 0.6931471,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;CdR7sHgBaKNfVnMbsJb9&quot;,                &quot;_score&quot;: 0.6931471,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;        ]    &#125;&#125;</code></pre><h4 id="完全匹配">完全匹配</h4><p>在 Postman 中，向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_search%EF%BC%8C%E9%99%84%E5%B8%A6JSON%E4%BD%93%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:9200/shopping/_search，附带JSON体如下：</a></p><pre><code>&#123;&quot;query&quot;:&#123;&quot;match_phrase&quot;:&#123;&quot;category&quot; : &quot;为&quot;&#125;&#125;&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;took&quot;: 2,    &quot;timed_out&quot;: false,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 1,        &quot;successful&quot;: 1,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0    &#125;,    &quot;hits&quot;: &#123;        &quot;total&quot;: &#123;            &quot;value&quot;: 3,            &quot;relation&quot;: &quot;eq&quot;        &#125;,        &quot;max_score&quot;: 0.6931471,        &quot;hits&quot;: [            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;BtR6sHgBaKNfVnMbX5Y5&quot;,                &quot;_score&quot;: 0.6931471,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;B9R6sHgBaKNfVnMbZpZ6&quot;,                &quot;_score&quot;: 0.6931471,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;CdR7sHgBaKNfVnMbsJb9&quot;,                &quot;_score&quot;: 0.6931471,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;        ]    &#125;&#125;</code></pre><h4 id="高亮查询">高亮查询</h4><p>在 Postman 中，向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_search%EF%BC%8C%E9%99%84%E5%B8%A6JSON%E4%BD%93%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:9200/shopping/_search，附带JSON体如下：</a></p><pre><code>&#123;&quot;query&quot;:&#123;&quot;match_phrase&quot;:&#123;&quot;category&quot; : &quot;为&quot;&#125;&#125;,    &quot;highlight&quot;:&#123;        &quot;fields&quot;:&#123;            &quot;category&quot;:&#123;&#125;//&lt;----高亮这字段        &#125;    &#125;&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;took&quot;: 100,    &quot;timed_out&quot;: false,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 1,        &quot;successful&quot;: 1,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0    &#125;,    &quot;hits&quot;: &#123;        &quot;total&quot;: &#123;            &quot;value&quot;: 3,            &quot;relation&quot;: &quot;eq&quot;        &#125;,        &quot;max_score&quot;: 0.6931471,        &quot;hits&quot;: [            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;BtR6sHgBaKNfVnMbX5Y5&quot;,                &quot;_score&quot;: 0.6931471,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;,                &quot;highlight&quot;: &#123;                    &quot;category&quot;: [                        &quot;华&lt;em&gt;为&lt;/em&gt;&quot;//&lt;------高亮一个为字。                    ]                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;B9R6sHgBaKNfVnMbZpZ6&quot;,                &quot;_score&quot;: 0.6931471,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;,                &quot;highlight&quot;: &#123;                    &quot;category&quot;: [                        &quot;华&lt;em&gt;为&lt;/em&gt;&quot;                    ]                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;CdR7sHgBaKNfVnMbsJb9&quot;,                &quot;_score&quot;: 0.6931471,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;,                &quot;highlight&quot;: &#123;                    &quot;category&quot;: [                        &quot;华&lt;em&gt;为&lt;/em&gt;&quot;                    ]                &#125;            &#125;        ]    &#125;&#125;</code></pre><h3 id="16-入门-HTTP-聚合查询">16-入门-HTTP-聚合查询</h3><p>聚合允许使用者对 es 文档进行统计分析，类似与关系型数据库中的 group by，当然还有很多其他的聚合，例如取最大值max、平均值avg等等。</p><p>接下来按price字段进行分组：</p><p>在 Postman 中，向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_search%EF%BC%8C%E9%99%84%E5%B8%A6JSON%E4%BD%93%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:9200/shopping/_search，附带JSON体如下：</a></p><pre><code>&#123;&quot;aggs&quot;:&#123;//聚合操作&quot;price_group&quot;:&#123;//名称，随意起名&quot;terms&quot;:&#123;//分组&quot;field&quot;:&quot;price&quot;//分组字段&#125;&#125;&#125;&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;took&quot;: 63,    &quot;timed_out&quot;: false,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 1,        &quot;successful&quot;: 1,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0    &#125;,    &quot;hits&quot;: &#123;        &quot;total&quot;: &#123;            &quot;value&quot;: 6,            &quot;relation&quot;: &quot;eq&quot;        &#125;,        &quot;max_score&quot;: 1,        &quot;hits&quot;: [            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;ANQqsHgBaKNfVnMbhZYU&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 3999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;A9R5sHgBaKNfVnMb25Ya&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;BNR5sHgBaKNfVnMb7pal&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;小米手机&quot;,                    &quot;category&quot;: &quot;小米&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;BtR6sHgBaKNfVnMbX5Y5&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;B9R6sHgBaKNfVnMbZpZ6&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;,            &#123;                &quot;_index&quot;: &quot;shopping&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;CdR7sHgBaKNfVnMbsJb9&quot;,                &quot;_score&quot;: 1,                &quot;_source&quot;: &#123;                    &quot;title&quot;: &quot;华为手机&quot;,                    &quot;category&quot;: &quot;华为&quot;,                    &quot;images&quot;: &quot;http://www.gulixueyuan.com/xm.jpg&quot;,                    &quot;price&quot;: 1999                &#125;            &#125;        ]    &#125;,    &quot;aggregations&quot;: &#123;        &quot;price_group&quot;: &#123;            &quot;doc_count_error_upper_bound&quot;: 0,            &quot;sum_other_doc_count&quot;: 0,            &quot;buckets&quot;: [                &#123;                    &quot;key&quot;: 1999,                    &quot;doc_count&quot;: 5                &#125;,                &#123;                    &quot;key&quot;: 3999,                    &quot;doc_count&quot;: 1                &#125;            ]        &#125;    &#125;&#125;</code></pre><p>上面返回结果会附带原始数据的。若不想要不附带原始数据的结果，在 Postman 中，向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_search%EF%BC%8C%E9%99%84%E5%B8%A6JSON%E4%BD%93%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:9200/shopping/_search，附带JSON体如下：</a></p><pre><code>&#123;&quot;aggs&quot;:&#123;&quot;price_group&quot;:&#123;&quot;terms&quot;:&#123;&quot;field&quot;:&quot;price&quot;&#125;&#125;&#125;,    &quot;size&quot;:0&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;took&quot;: 60,    &quot;timed_out&quot;: false,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 1,        &quot;successful&quot;: 1,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0    &#125;,    &quot;hits&quot;: &#123;        &quot;total&quot;: &#123;            &quot;value&quot;: 6,            &quot;relation&quot;: &quot;eq&quot;        &#125;,        &quot;max_score&quot;: null,        &quot;hits&quot;: []    &#125;,    &quot;aggregations&quot;: &#123;        &quot;price_group&quot;: &#123;            &quot;doc_count_error_upper_bound&quot;: 0,            &quot;sum_other_doc_count&quot;: 0,            &quot;buckets&quot;: [                &#123;                    &quot;key&quot;: 1999,                    &quot;doc_count&quot;: 5                &#125;,                &#123;                    &quot;key&quot;: 3999,                    &quot;doc_count&quot;: 1                &#125;            ]        &#125;    &#125;&#125;</code></pre><p>若想对所有手机价格求 <strong>平均值</strong> 。</p><p>在 Postman 中，向 ES 服务器发 GET请求 ： <a href="http://127.0.0.1:9200/shopping/_search%EF%BC%8C%E9%99%84%E5%B8%A6JSON%E4%BD%93%E5%A6%82%E4%B8%8B%EF%BC%9A">http://127.0.0.1:9200/shopping/_search，附带JSON体如下：</a></p><pre><code>&#123;&quot;aggs&quot;:&#123;&quot;price_avg&quot;:&#123;//名称，随意起名&quot;avg&quot;:&#123;//求平均&quot;field&quot;:&quot;price&quot;&#125;&#125;&#125;,    &quot;size&quot;:0&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;took&quot;: 14,    &quot;timed_out&quot;: false,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 1,        &quot;successful&quot;: 1,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0    &#125;,    &quot;hits&quot;: &#123;        &quot;total&quot;: &#123;            &quot;value&quot;: 6,            &quot;relation&quot;: &quot;eq&quot;        &#125;,        &quot;max_score&quot;: null,        &quot;hits&quot;: []    &#125;,    &quot;aggregations&quot;: &#123;        &quot;price_avg&quot;: &#123;            &quot;value&quot;: 2332.3333333333335        &#125;    &#125;&#125;</code></pre><h3 id="17-入门-HTTP-映射关系">17-入门-HTTP-映射关系</h3><p>有了索引库，等于有了数据库中的 database。</p><p>接下来就需要建索引库(index)中的映射了，类似于数据库(database)中的表结构(table)。</p><p>创建数据库表需要设置字段名称，类型，长度，约束等；索引库也一样，需要知道这个类型下有哪些字段，每个字段有哪些约束信息，这就叫做映射(mapping)。</p><p>先创建一个索引：</p><pre><code># PUT http://127.0.0.1:9200/user</code></pre><p>返回结果：</p><pre><code>&#123;    &quot;acknowledged&quot;: true,    &quot;shards_acknowledged&quot;: true,    &quot;index&quot;: &quot;user&quot;&#125;</code></pre><p><strong>创建映射</strong></p><pre><code># PUT http://127.0.0.1:9200/user/_mapping&#123;    &quot;properties&quot;: &#123;        &quot;name&quot;:&#123;        &quot;type&quot;: &quot;text&quot;,        &quot;index&quot;: true        &#125;,        &quot;sex&quot;:&#123;        &quot;type&quot;: &quot;keyword&quot;,        &quot;index&quot;: true        &#125;,        &quot;tel&quot;:&#123;        &quot;type&quot;: &quot;keyword&quot;,        &quot;index&quot;: false        &#125;    &#125;&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;acknowledged&quot;: true&#125;</code></pre><p><strong>查询映射</strong></p><pre><code>#GET http://127.0.0.1:9200/user/_mapping</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;user&quot;: &#123;        &quot;mappings&quot;: &#123;            &quot;properties&quot;: &#123;                &quot;name&quot;: &#123;                    &quot;type&quot;: &quot;text&quot;                &#125;,                &quot;sex&quot;: &#123;                    &quot;type&quot;: &quot;keyword&quot;                &#125;,                &quot;tel&quot;: &#123;                    &quot;type&quot;: &quot;keyword&quot;,                    &quot;index&quot;: false                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>增加数据</p><pre><code>#PUT http://127.0.0.1:9200/user/_create/1001&#123;&quot;name&quot;:&quot;小米&quot;,&quot;sex&quot;:&quot;男的&quot;,&quot;tel&quot;:&quot;1111&quot;&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;_index&quot;: &quot;user&quot;,    &quot;_type&quot;: &quot;_doc&quot;,    &quot;_id&quot;: &quot;1001&quot;,    &quot;_version&quot;: 1,    &quot;result&quot;: &quot;created&quot;,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 2,        &quot;successful&quot;: 1,        &quot;failed&quot;: 0    &#125;,    &quot;_seq_no&quot;: 0,    &quot;_primary_term&quot;: 1&#125;</code></pre><p>查找name含有”小“数据：</p><pre><code>#GET http://127.0.0.1:9200/user/_search&#123;&quot;query&quot;:&#123;&quot;match&quot;:&#123;&quot;name&quot;:&quot;小&quot;&#125;&#125;&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;took&quot;: 495,    &quot;timed_out&quot;: false,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 1,        &quot;successful&quot;: 1,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0    &#125;,    &quot;hits&quot;: &#123;        &quot;total&quot;: &#123;            &quot;value&quot;: 1,            &quot;relation&quot;: &quot;eq&quot;        &#125;,        &quot;max_score&quot;: 0.2876821,        &quot;hits&quot;: [            &#123;                &quot;_index&quot;: &quot;user&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;1001&quot;,                &quot;_score&quot;: 0.2876821,                &quot;_source&quot;: &#123;                    &quot;name&quot;: &quot;小米&quot;,                    &quot;sex&quot;: &quot;男的&quot;,                    &quot;tel&quot;: &quot;1111&quot;                &#125;            &#125;        ]    &#125;&#125;</code></pre><p>查找sex含有”男“数据：</p><pre><code>#GET http://127.0.0.1:9200/user/_search&#123;&quot;query&quot;:&#123;&quot;match&quot;:&#123;&quot;sex&quot;:&quot;男&quot;&#125;&#125;&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;took&quot;: 1,    &quot;timed_out&quot;: false,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 1,        &quot;successful&quot;: 1,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0    &#125;,    &quot;hits&quot;: &#123;        &quot;total&quot;: &#123;            &quot;value&quot;: 0,            &quot;relation&quot;: &quot;eq&quot;        &#125;,        &quot;max_score&quot;: null,        &quot;hits&quot;: []    &#125;&#125;</code></pre><p>找不想要的结果，只因创建映射时&quot;sex&quot;的类型为&quot;keyword&quot;。</p><p>&quot;sex&quot;只能完全为”男的“，才能得出原数据。</p><pre><code>#GET http://127.0.0.1:9200/user/_search&#123;&quot;query&quot;:&#123;&quot;match&quot;:&#123;&quot;sex&quot;:&quot;男的&quot;&#125;&#125;&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;took&quot;: 2,    &quot;timed_out&quot;: false,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 1,        &quot;successful&quot;: 1,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0    &#125;,    &quot;hits&quot;: &#123;        &quot;total&quot;: &#123;            &quot;value&quot;: 1,            &quot;relation&quot;: &quot;eq&quot;        &#125;,        &quot;max_score&quot;: 0.2876821,        &quot;hits&quot;: [            &#123;                &quot;_index&quot;: &quot;user&quot;,                &quot;_type&quot;: &quot;_doc&quot;,                &quot;_id&quot;: &quot;1001&quot;,                &quot;_score&quot;: 0.2876821,                &quot;_source&quot;: &#123;                    &quot;name&quot;: &quot;小米&quot;,                    &quot;sex&quot;: &quot;男的&quot;,                    &quot;tel&quot;: &quot;1111&quot;                &#125;            &#125;        ]    &#125;&#125;</code></pre><p>查询电话</p><pre><code># GET http://127.0.0.1:9200/user/_search&#123;&quot;query&quot;:&#123;&quot;match&quot;:&#123;&quot;tel&quot;:&quot;11&quot;&#125;&#125;&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;error&quot;: &#123;        &quot;root_cause&quot;: [            &#123;                &quot;type&quot;: &quot;query_shard_exception&quot;,                &quot;reason&quot;: &quot;failed to create query: Cannot search on field [tel] since it is not indexed.&quot;,                &quot;index_uuid&quot;: &quot;ivLnMfQKROS7Skb2MTFOew&quot;,                &quot;index&quot;: &quot;user&quot;            &#125;        ],        &quot;type&quot;: &quot;search_phase_execution_exception&quot;,        &quot;reason&quot;: &quot;all shards failed&quot;,        &quot;phase&quot;: &quot;query&quot;,        &quot;grouped&quot;: true,        &quot;failed_shards&quot;: [            &#123;                &quot;shard&quot;: 0,                &quot;index&quot;: &quot;user&quot;,                &quot;node&quot;: &quot;4P7dIRfXSbezE5JTiuylew&quot;,                &quot;reason&quot;: &#123;                    &quot;type&quot;: &quot;query_shard_exception&quot;,                    &quot;reason&quot;: &quot;failed to create query: Cannot search on field [tel] since it is not indexed.&quot;,                    &quot;index_uuid&quot;: &quot;ivLnMfQKROS7Skb2MTFOew&quot;,                    &quot;index&quot;: &quot;user&quot;,                    &quot;caused_by&quot;: &#123;                        &quot;type&quot;: &quot;illegal_argument_exception&quot;,                        &quot;reason&quot;: &quot;Cannot search on field [tel] since it is not indexed.&quot;                    &#125;                &#125;            &#125;        ]    &#125;,    &quot;status&quot;: 400&#125;</code></pre><p>报错只因创建映射时&quot;tel&quot;的&quot;index&quot;为false。</p><h3 id="18-入门-JavaAPI-环境准备">18-入门-JavaAPI-环境准备</h3><p>新建Maven工程。</p><p>添加依赖：</p><pre><code>&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt;        &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt;        &lt;version&gt;7.8.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- elasticsearch 的客户端 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;        &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;        &lt;version&gt;7.8.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- elasticsearch 依赖 2.x 的 log4j --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;        &lt;version&gt;2.8.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;        &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;        &lt;version&gt;2.8.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;        &lt;version&gt;2.9.9&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- junit 单元测试 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>HelloElasticsearch</p><pre><code>import java.io.IOException;import org.apache.http.HttpHost;import org.elasticsearch.client.RestClient;import org.elasticsearch.client.RestHighLevelClient;public class HelloElasticsearch &#123;public static void main(String[] args) throws IOException &#123;// 创建客户端对象RestHighLevelClient client = new RestHighLevelClient(RestClient.builder(new HttpHost(&quot;localhost&quot;, 9200, &quot;http&quot;)));//...System.out.println(client);// 关闭客户端连接client.close();&#125;&#125;</code></pre><h3 id="19-入门-JavaAPI-索引-创建">19-入门-JavaAPI-索引-创建</h3><pre><code>import org.apache.http.HttpHost;import org.elasticsearch.action.admin.indices.create.CreateIndexRequest;import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.client.RestClient;import org.elasticsearch.client.RestHighLevelClient;import java.io.IOException;public class CreateIndex &#123;    public static void main(String[] args) throws IOException &#123;        // 创建客户端对象        RestHighLevelClient client = new RestHighLevelClient(                RestClient.builder(new HttpHost(&quot;localhost&quot;, 9200, &quot;http&quot;)));        // 创建索引 - 请求对象        CreateIndexRequest request = new CreateIndexRequest(&quot;user2&quot;);        // 发送请求，获取响应        CreateIndexResponse response = client.indices().create(request,                RequestOptions.DEFAULT);        boolean acknowledged = response.isAcknowledged();        // 响应状态        System.out.println(&quot;操作状态 = &quot; + acknowledged);        // 关闭客户端连接        client.close();    &#125;&#125;</code></pre><p>后台打印：</p><pre><code>四月 09, 2021 2:12:08 下午 org.elasticsearch.client.RestClient logResponse警告: request [PUT http://localhost:9200/user2?master_timeout=30s&amp;include_type_name=true&amp;timeout=30s] returned 1 warnings: [299 Elasticsearch-7.8.0-757314695644ea9a1dc2fecd26d1a43856725e65 &quot;[types removal] Using include_type_name in create index requests is deprecated. The parameter will be removed in the next major version.&quot;]操作状态 = trueProcess finished with exit code 0</code></pre><h3 id="20-入门-JavaAPI-索引-查询-删除">20-入门-JavaAPI-索引-查询 &amp; 删除</h3><h4 id="查询">查询</h4><pre><code>import org.apache.http.HttpHost;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.client.RestClient;import org.elasticsearch.client.RestHighLevelClient;import org.elasticsearch.client.indices.GetIndexRequest;import org.elasticsearch.client.indices.GetIndexResponse;import java.io.IOException;public class SearchIndex &#123;    public static void main(String[] args) throws IOException &#123;        // 创建客户端对象        RestHighLevelClient client = new RestHighLevelClient(                RestClient.builder(new HttpHost(&quot;localhost&quot;, 9200, &quot;http&quot;)));        // 查询索引 - 请求对象        GetIndexRequest request = new GetIndexRequest(&quot;user2&quot;);        // 发送请求，获取响应        GetIndexResponse response = client.indices().get(request,                RequestOptions.DEFAULT);                System.out.println(&quot;aliases:&quot;+response.getAliases());        System.out.println(&quot;mappings:&quot;+response.getMappings());        System.out.println(&quot;settings:&quot;+response.getSettings());        client.close();    &#125;&#125;</code></pre><p>后台打印：</p><pre><code>aliases:&#123;user2=[]&#125;mappings:&#123;user2=org.elasticsearch.cluster.metadata.MappingMetadata@ad700514&#125;settings:&#123;user2=&#123;&quot;index.creation_date&quot;:&quot;1617948726976&quot;,&quot;index.number_of_replicas&quot;:&quot;1&quot;,&quot;index.number_of_shards&quot;:&quot;1&quot;,&quot;index.provided_name&quot;:&quot;user2&quot;,&quot;index.uuid&quot;:&quot;UGZ1ntcySnK6hWyP2qoVpQ&quot;,&quot;index.version.created&quot;:&quot;7080099&quot;&#125;&#125;Process finished with exit code 0</code></pre><h4 id="删除-2">删除</h4><pre><code>import org.apache.http.HttpHost;import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;import org.elasticsearch.action.support.master.AcknowledgedResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.client.RestClient;import org.elasticsearch.client.RestHighLevelClient;import java.io.IOException;public class DeleteIndex &#123;    public static void main(String[] args) throws IOException &#123;        RestHighLevelClient client = new RestHighLevelClient(                RestClient.builder(new HttpHost(&quot;localhost&quot;, 9200, &quot;http&quot;)));        // 删除索引 - 请求对象        DeleteIndexRequest request = new DeleteIndexRequest(&quot;user2&quot;);        // 发送请求，获取响应        AcknowledgedResponse response = client.indices().delete(request,RequestOptions.DEFAULT);        // 操作结果        System.out.println(&quot;操作结果 ： &quot; + response.isAcknowledged());        client.close();    &#125;&#125;</code></pre><p>后台打印：</p><pre><code>操作结果 ： trueProcess finished with exit code 0</code></pre><h3 id="21-入门-JavaAPI-文档-新增-修改">21-入门-JavaAPI-文档-新增 &amp; 修改</h3><h4 id="重构">重构</h4><p>上文由于频繁使用以下连接Elasticsearch和关闭它的代码，于是 <strong>个人</strong> 对它进行重构。</p><pre><code>public class SomeClass &#123;    public static void main(String[] args) throws IOException &#123;        RestHighLevelClient client = new RestHighLevelClient(                RestClient.builder(new HttpHost(&quot;localhost&quot;, 9200, &quot;http&quot;)));        ...                client.close();    &#125;&#125;</code></pre><p>重构后的代码：</p><pre><code>import org.elasticsearch.client.RestHighLevelClient;public interface ElasticsearchTask &#123;    void doSomething(RestHighLevelClient client) throws Exception;&#125;</code></pre><p>​<br>​<br>​    public class ConnectElasticsearch{<br>​<br>public static void connect(ElasticsearchTask task){<br>// 创建客户端对象<br>RestHighLevelClient client = new RestHighLevelClient(<br>RestClient.builder(new HttpHost(“localhost”, 9200, “http”)));<br>try {<br>task.doSomething(client);<br>// 关闭客户端连接<br>client.close();<br>} catch (Exception e) {<br>e.printStackTrace();<br>}<br>}<br>}</p><p>接下来，如果想让Elasticsearch完成一些操作，就编写一个lambda式即可。</p><pre><code>public class SomeClass &#123;    public static void main(String[] args) &#123;        ConnectElasticsearch.connect(client -&gt; &#123;//do something        &#125;);    &#125;&#125;</code></pre><p>​</p><h4 id="新增">新增</h4><pre><code>import com.fasterxml.jackson.databind.ObjectMapper;import com.lun.elasticsearch.hello.ConnectElasticsearch;import com.lun.elasticsearch.model.User;import org.elasticsearch.action.index.IndexRequest;import org.elasticsearch.action.index.IndexResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.common.xcontent.XContentType;public class InsertDoc &#123;    public static void main(String[] args) &#123;        ConnectElasticsearch.connect(client -&gt; &#123;            // 新增文档 - 请求对象            IndexRequest request = new IndexRequest();            // 设置索引及唯一性标识            request.index(&quot;user&quot;).id(&quot;1001&quot;);            // 创建数据对象            User user = new User();            user.setName(&quot;zhangsan&quot;);            user.setAge(30);            user.setSex(&quot;男&quot;);            ObjectMapper objectMapper = new ObjectMapper();            String productJson = objectMapper.writeValueAsString(user);            // 添加文档数据，数据格式为 JSON 格式            request.source(productJson, XContentType.JSON);            // 客户端发送请求，获取响应对象            IndexResponse response = client.index(request, RequestOptions.DEFAULT);            3.打印结果信息            System.out.println(&quot;_index:&quot; + response.getIndex());            System.out.println(&quot;_id:&quot; + response.getId());            System.out.println(&quot;_result:&quot; + response.getResult());        &#125;);    &#125;&#125;</code></pre><p>后台打印：</p><pre><code>_index:user_id:1001_result:UPDATEDProcess finished with exit code 0</code></pre><h4 id="修改">修改</h4><pre><code>import com.lun.elasticsearch.hello.ConnectElasticsearch;import org.elasticsearch.action.update.UpdateRequest;import org.elasticsearch.action.update.UpdateResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.common.xcontent.XContentType;public class UpdateDoc &#123;    public static void main(String[] args) &#123;        ConnectElasticsearch.connect(client -&gt; &#123;            // 修改文档 - 请求对象            UpdateRequest request = new UpdateRequest();            // 配置修改参数            request.index(&quot;user&quot;).id(&quot;1001&quot;);            // 设置请求体，对数据进行修改            request.doc(XContentType.JSON, &quot;sex&quot;, &quot;女&quot;);            // 客户端发送请求，获取响应对象            UpdateResponse response = client.update(request, RequestOptions.DEFAULT);            System.out.println(&quot;_index:&quot; + response.getIndex());            System.out.println(&quot;_id:&quot; + response.getId());            System.out.println(&quot;_result:&quot; + response.getResult());        &#125;);    &#125;&#125;</code></pre><p>后台打印：</p><pre><code>_index:user_id:1001_result:UPDATEDProcess finished with exit code 0</code></pre><h3 id="22-入门-JavaAPI-文档-查询-删除">22-入门-JavaAPI-文档-查询 &amp; 删除</h3><h4 id="查询-2">查询</h4><pre><code>import com.lun.elasticsearch.hello.ConnectElasticsearch;import org.elasticsearch.action.get.GetRequest;import org.elasticsearch.action.get.GetResponse;import org.elasticsearch.client.RequestOptions;public class GetDoc &#123;    public static void main(String[] args) &#123;        ConnectElasticsearch.connect(client -&gt; &#123;            //1.创建请求对象            GetRequest request = new GetRequest().index(&quot;user&quot;).id(&quot;1001&quot;);            //2.客户端发送请求，获取响应对象            GetResponse response = client.get(request, RequestOptions.DEFAULT);            3.打印结果信息            System.out.println(&quot;_index:&quot; + response.getIndex());            System.out.println(&quot;_type:&quot; + response.getType());            System.out.println(&quot;_id:&quot; + response.getId());            System.out.println(&quot;source:&quot; + response.getSourceAsString());        &#125;);    &#125;&#125;</code></pre><p>​</p><p>后台打印：</p><pre><code>_index:user_type:_doc_id:1001source:&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:30,&quot;sex&quot;:&quot;男&quot;&#125;Process finished with exit code 0</code></pre><h4 id="删除-3">删除</h4><pre><code>import com.lun.elasticsearch.hello.ConnectElasticsearch;import org.elasticsearch.action.delete.DeleteRequest;import org.elasticsearch.action.delete.DeleteResponse;import org.elasticsearch.client.RequestOptions;public class DeleteDoc &#123;    public static void main(String[] args) &#123;        ConnectElasticsearch.connect(client -&gt; &#123;            //创建请求对象            DeleteRequest request = new DeleteRequest().index(&quot;user&quot;).id(&quot;1001&quot;);            //客户端发送请求，获取响应对象            DeleteResponse response = client.delete(request, RequestOptions.DEFAULT);            //打印信息            System.out.println(response.toString());        &#125;);    &#125;&#125;</code></pre><p>后台打印：</p><pre><code>DeleteResponse[index=user,type=_doc,id=1001,version=16,result=deleted,shards=ShardInfo&#123;total=2, successful=1, failures=[]&#125;]Process finished with exit code 0</code></pre><h3 id="23-入门-JavaAPI-文档-批量新增-批量删除">23-入门-JavaAPI-文档-批量新增 &amp; 批量删除</h3><h4 id="批量新增">批量新增</h4><pre><code>import com.lun.elasticsearch.hello.ConnectElasticsearch;import org.elasticsearch.action.bulk.BulkRequest;import org.elasticsearch.action.bulk.BulkResponse;import org.elasticsearch.action.index.IndexRequest;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.common.xcontent.XContentType;public class BatchInsertDoc &#123;    public static void main(String[] args) &#123;        ConnectElasticsearch.connect(client -&gt; &#123;            //创建批量新增请求对象            BulkRequest request = new BulkRequest();            request.add(new                    IndexRequest().index(&quot;user&quot;).id(&quot;1001&quot;).source(XContentType.JSON, &quot;name&quot;,                    &quot;zhangsan&quot;));            request.add(new                    IndexRequest().index(&quot;user&quot;).id(&quot;1002&quot;).source(XContentType.JSON, &quot;name&quot;,                            &quot;lisi&quot;));            request.add(new                    IndexRequest().index(&quot;user&quot;).id(&quot;1003&quot;).source(XContentType.JSON, &quot;name&quot;,                    &quot;wangwu&quot;));            //客户端发送请求，获取响应对象            BulkResponse responses = client.bulk(request, RequestOptions.DEFAULT);            //打印结果信息            System.out.println(&quot;took:&quot; + responses.getTook());            System.out.println(&quot;items:&quot; + responses.getItems());        &#125;);    &#125;&#125;</code></pre><p>后台打印</p><pre><code>took:294msitems:[Lorg.elasticsearch.action.bulk.BulkItemResponse;@2beee7ffProcess finished with exit code 0</code></pre><h4 id="批量删除">批量删除</h4><pre><code>import com.lun.elasticsearch.hello.ConnectElasticsearch;import org.elasticsearch.action.bulk.BulkRequest;import org.elasticsearch.action.bulk.BulkResponse;import org.elasticsearch.action.delete.DeleteRequest;import org.elasticsearch.client.RequestOptions;public class BatchDeleteDoc &#123;    public static void main(String[] args) &#123;        ConnectElasticsearch.connect(client -&gt; &#123;            //创建批量删除请求对象            BulkRequest request = new BulkRequest();            request.add(new DeleteRequest().index(&quot;user&quot;).id(&quot;1001&quot;));            request.add(new DeleteRequest().index(&quot;user&quot;).id(&quot;1002&quot;));            request.add(new DeleteRequest().index(&quot;user&quot;).id(&quot;1003&quot;));            //客户端发送请求，获取响应对象            BulkResponse responses = client.bulk(request, RequestOptions.DEFAULT);            //打印结果信息            System.out.println(&quot;took:&quot; + responses.getTook());            System.out.println(&quot;items:&quot; + responses.getItems());        &#125;);    &#125;&#125;</code></pre><p>后台打印</p><pre><code>took:108msitems:[Lorg.elasticsearch.action.bulk.BulkItemResponse;@7b02881eProcess finished with exit code 0</code></pre><p>​</p><h3 id="24-入门-JavaAPI-文档-高级查询-全量查询">24-入门-JavaAPI-文档-高级查询-全量查询</h3><p>先批量增加数据</p><pre><code>public class BatchInsertDoc &#123;    public static void main(String[] args) &#123;        ConnectElasticsearch.connect(client -&gt; &#123;            //创建批量新增请求对象            BulkRequest request = new BulkRequest();            request.add(new IndexRequest().index(&quot;user&quot;).id(&quot;1001&quot;).source(XContentType.JSON, &quot;name&quot;, &quot;zhangsan&quot;, &quot;age&quot;, &quot;10&quot;, &quot;sex&quot;,&quot;女&quot;));            request.add(new IndexRequest().index(&quot;user&quot;).id(&quot;1002&quot;).source(XContentType.JSON, &quot;name&quot;, &quot;lisi&quot;, &quot;age&quot;, &quot;30&quot;, &quot;sex&quot;,&quot;女&quot;));            request.add(new IndexRequest().index(&quot;user&quot;).id(&quot;1003&quot;).source(XContentType.JSON, &quot;name&quot;, &quot;wangwu1&quot;, &quot;age&quot;, &quot;40&quot;, &quot;sex&quot;,&quot;男&quot;));            request.add(new IndexRequest().index(&quot;user&quot;).id(&quot;1004&quot;).source(XContentType.JSON, &quot;name&quot;, &quot;wangwu2&quot;, &quot;age&quot;, &quot;20&quot;, &quot;sex&quot;,&quot;女&quot;));            request.add(new IndexRequest().index(&quot;user&quot;).id(&quot;1005&quot;).source(XContentType.JSON, &quot;name&quot;, &quot;wangwu3&quot;, &quot;age&quot;, &quot;50&quot;, &quot;sex&quot;,&quot;男&quot;));            request.add(new IndexRequest().index(&quot;user&quot;).id(&quot;1006&quot;).source(XContentType.JSON, &quot;name&quot;, &quot;wangwu4&quot;, &quot;age&quot;, &quot;20&quot;, &quot;sex&quot;,&quot;男&quot;));            //客户端发送请求，获取响应对象            BulkResponse responses = client.bulk(request, RequestOptions.DEFAULT);            //打印结果信息            System.out.println(&quot;took:&quot; + responses.getTook());            System.out.println(&quot;items:&quot; + responses.getItems());        &#125;);    &#125;&#125;</code></pre><p>后台打印</p><pre><code>took:168msitems:[Lorg.elasticsearch.action.bulk.BulkItemResponse;@2beee7ffProcess finished with exit code 0</code></pre><p><strong>查询所有索引数据</strong></p><pre><code>import com.lun.elasticsearch.hello.ConnectElasticsearch;import org.elasticsearch.action.search.SearchRequest;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.search.SearchHit;import org.elasticsearch.search.SearchHits;import org.elasticsearch.search.builder.SearchSourceBuilder;public class QueryDoc &#123;    public static void main(String[] args) &#123;        ConnectElasticsearch.connect(client -&gt; &#123;            // 创建搜索请求对象            SearchRequest request = new SearchRequest();            request.indices(&quot;user&quot;);            // 构建查询的请求体            SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();            // 查询所有数据            sourceBuilder.query(QueryBuilders.matchAllQuery());            request.source(sourceBuilder);            SearchResponse response = client.search(request, RequestOptions.DEFAULT);            // 查询匹配            SearchHits hits = response.getHits();            System.out.println(&quot;took:&quot; + response.getTook());            System.out.println(&quot;timeout:&quot; + response.isTimedOut());            System.out.println(&quot;total:&quot; + hits.getTotalHits());            System.out.println(&quot;MaxScore:&quot; + hits.getMaxScore());            System.out.println(&quot;hits========&gt;&gt;&quot;);            for (SearchHit hit : hits) &#123;            //输出每条查询的结果信息                System.out.println(hit.getSourceAsString());            &#125;            System.out.println(&quot;&lt;&lt;========&quot;);        &#125;);    &#125;&#125;</code></pre><p>后台打印</p><pre><code>took:2mstimeout:falsetotal:6 hitsMaxScore:1.0hits========&gt;&gt;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:&quot;10&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&#123;&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:&quot;30&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&#123;&quot;name&quot;:&quot;wangwu1&quot;,&quot;age&quot;:&quot;40&quot;,&quot;sex&quot;:&quot;男&quot;&#125;&#123;&quot;name&quot;:&quot;wangwu2&quot;,&quot;age&quot;:&quot;20&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&#123;&quot;name&quot;:&quot;wangwu3&quot;,&quot;age&quot;:&quot;50&quot;,&quot;sex&quot;:&quot;男&quot;&#125;&#123;&quot;name&quot;:&quot;wangwu4&quot;,&quot;age&quot;:&quot;20&quot;,&quot;sex&quot;:&quot;男&quot;&#125;&lt;&lt;========Process finished with exit code 0</code></pre><h3 id="25-入门-JavaAPI-文档-高级查询-分页查询-条件查询-查询排序">25-入门-JavaAPI-文档-高级查询-分页查询 &amp; 条件查询 &amp; 查询排序</h3><h4 id="条件查询-2">条件查询</h4><pre><code>import com.lun.elasticsearch.hello.ConnectElasticsearch;import com.lun.elasticsearch.hello.ElasticsearchTask;import org.elasticsearch.action.search.SearchRequest;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.search.SearchHit;import org.elasticsearch.search.SearchHits;import org.elasticsearch.search.builder.SearchSourceBuilder;import org.elasticsearch.search.sort.SortOrder;public class QueryDoc &#123;    public static final ElasticsearchTask SEARCH_BY_CONDITION = client -&gt; &#123;        // 创建搜索请求对象        SearchRequest request = new SearchRequest();        request.indices(&quot;user&quot;);        // 构建查询的请求体        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();        sourceBuilder.query(QueryBuilders.termQuery(&quot;age&quot;, &quot;30&quot;));        request.source(sourceBuilder);        SearchResponse response = client.search(request, RequestOptions.DEFAULT);        // 查询匹配        SearchHits hits = response.getHits();        System.out.println(&quot;took:&quot; + response.getTook());        System.out.println(&quot;timeout:&quot; + response.isTimedOut());        System.out.println(&quot;total:&quot; + hits.getTotalHits());        System.out.println(&quot;MaxScore:&quot; + hits.getMaxScore());        System.out.println(&quot;hits========&gt;&gt;&quot;);        for (SearchHit hit : hits) &#123;            //输出每条查询的结果信息            System.out.println(hit.getSourceAsString());        &#125;        System.out.println(&quot;&lt;&lt;========&quot;);    &#125;;        public static void main(String[] args) &#123;        ConnectElasticsearch.connect(SEARCH_BY_CONDITION);    &#125;&#125;</code></pre><p>后台打印</p><pre><code>took:1mstimeout:falsetotal:1 hitsMaxScore:1.0hits========&gt;&gt;&#123;&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:&quot;30&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&lt;&lt;========</code></pre><h4 id="分页查询-2">分页查询</h4><pre><code>import com.lun.elasticsearch.hello.ConnectElasticsearch;import com.lun.elasticsearch.hello.ElasticsearchTask;import org.elasticsearch.action.search.SearchRequest;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.search.SearchHit;import org.elasticsearch.search.SearchHits;import org.elasticsearch.search.builder.SearchSourceBuilder;import org.elasticsearch.search.sort.SortOrder;public class QueryDoc &#123;    public static final ElasticsearchTask SEARCH_BY_PAGING = client -&gt; &#123;        // 创建搜索请求对象        SearchRequest request = new SearchRequest();        request.indices(&quot;user&quot;);        // 构建查询的请求体        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();        sourceBuilder.query(QueryBuilders.matchAllQuery());        // 分页查询        // 当前页其实索引(第一条数据的顺序号)， from        sourceBuilder.from(0);        // 每页显示多少条 size        sourceBuilder.size(2);        request.source(sourceBuilder);        SearchResponse response = client.search(request, RequestOptions.DEFAULT);        // 查询匹配        SearchHits hits = response.getHits();        System.out.println(&quot;took:&quot; + response.getTook());        System.out.println(&quot;timeout:&quot; + response.isTimedOut());        System.out.println(&quot;total:&quot; + hits.getTotalHits());        System.out.println(&quot;MaxScore:&quot; + hits.getMaxScore());        System.out.println(&quot;hits========&gt;&gt;&quot;);        for (SearchHit hit : hits) &#123;            //输出每条查询的结果信息            System.out.println(hit.getSourceAsString());        &#125;        System.out.println(&quot;&lt;&lt;========&quot;);    &#125;;        public static void main(String[] args) &#123;        ConnectElasticsearch.connect(SEARCH_BY_CONDITION);    &#125;&#125;</code></pre><p>后台打印</p><pre><code>took:1mstimeout:falsetotal:6 hitsMaxScore:1.0hits========&gt;&gt;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:&quot;10&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&#123;&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:&quot;30&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&lt;&lt;========</code></pre><h4 id="查询排序-2">查询排序</h4><pre><code>import com.lun.elasticsearch.hello.ConnectElasticsearch;import com.lun.elasticsearch.hello.ElasticsearchTask;import org.elasticsearch.action.search.SearchRequest;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.search.SearchHit;import org.elasticsearch.search.SearchHits;import org.elasticsearch.search.builder.SearchSourceBuilder;import org.elasticsearch.search.sort.SortOrder;public class QueryDoc &#123;    public static final ElasticsearchTask SEARCH_WITH_ORDER = client -&gt; &#123;        // 创建搜索请求对象        SearchRequest request = new SearchRequest();        request.indices(&quot;user&quot;);        // 构建查询的请求体        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();        sourceBuilder.query(QueryBuilders.matchAllQuery());        // 排序        sourceBuilder.sort(&quot;age&quot;, SortOrder.ASC);        request.source(sourceBuilder);        SearchResponse response = client.search(request, RequestOptions.DEFAULT);        // 查询匹配        SearchHits hits = response.getHits();        System.out.println(&quot;took:&quot; + response.getTook());        System.out.println(&quot;timeout:&quot; + response.isTimedOut());        System.out.println(&quot;total:&quot; + hits.getTotalHits());        System.out.println(&quot;MaxScore:&quot; + hits.getMaxScore());        System.out.println(&quot;hits========&gt;&gt;&quot;);        for (SearchHit hit : hits) &#123;        //输出每条查询的结果信息            System.out.println(hit.getSourceAsString());        &#125;        System.out.println(&quot;&lt;&lt;========&quot;);    &#125;;    public static void main(String[] args) &#123;        ConnectElasticsearch.connect(SEARCH_WITH_ORDER);    &#125;&#125;</code></pre><p>​</p><p>后台打印</p><pre><code>took:1mstimeout:falsetotal:6 hitsMaxScore:NaNhits========&gt;&gt;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:&quot;10&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&#123;&quot;name&quot;:&quot;wangwu2&quot;,&quot;age&quot;:&quot;20&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&#123;&quot;name&quot;:&quot;wangwu4&quot;,&quot;age&quot;:&quot;20&quot;,&quot;sex&quot;:&quot;男&quot;&#125;&#123;&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:&quot;30&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&#123;&quot;name&quot;:&quot;wangwu1&quot;,&quot;age&quot;:&quot;40&quot;,&quot;sex&quot;:&quot;男&quot;&#125;&#123;&quot;name&quot;:&quot;wangwu3&quot;,&quot;age&quot;:&quot;50&quot;,&quot;sex&quot;:&quot;男&quot;&#125;&lt;&lt;========</code></pre><h3 id="26-入门-JavaAPI-文档-高级查询-组合查询-范围查询">26-入门-JavaAPI-文档-高级查询-组合查询 &amp; 范围查询</h3><h4 id="组合查询">组合查询</h4><pre><code>import com.lun.elasticsearch.hello.ConnectElasticsearch;import com.lun.elasticsearch.hello.ElasticsearchTask;import org.elasticsearch.action.search.SearchRequest;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.index.query.BoolQueryBuilder;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.search.SearchHit;import org.elasticsearch.search.SearchHits;import org.elasticsearch.search.builder.SearchSourceBuilder;import org.elasticsearch.search.sort.SortOrder;public class QueryDoc &#123;    public static final ElasticsearchTask SEARCH_BY_BOOL_CONDITION = client -&gt; &#123;        // 创建搜索请求对象        SearchRequest request = new SearchRequest();        request.indices(&quot;user&quot;);        // 构建查询的请求体        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();        // 必须包含        boolQueryBuilder.must(QueryBuilders.matchQuery(&quot;age&quot;, &quot;30&quot;));        // 一定不含        boolQueryBuilder.mustNot(QueryBuilders.matchQuery(&quot;name&quot;, &quot;zhangsan&quot;));        // 可能包含        boolQueryBuilder.should(QueryBuilders.matchQuery(&quot;sex&quot;, &quot;男&quot;));        sourceBuilder.query(boolQueryBuilder);        request.source(sourceBuilder);        SearchResponse response = client.search(request, RequestOptions.DEFAULT);        // 查询匹配        SearchHits hits = response.getHits();        System.out.println(&quot;took:&quot; + response.getTook());        System.out.println(&quot;timeout:&quot; + response.isTimedOut());        System.out.println(&quot;total:&quot; + hits.getTotalHits());        System.out.println(&quot;MaxScore:&quot; + hits.getMaxScore());        System.out.println(&quot;hits========&gt;&gt;&quot;);        for (SearchHit hit : hits) &#123;            //输出每条查询的结果信息            System.out.println(hit.getSourceAsString());        &#125;        System.out.println(&quot;&lt;&lt;========&quot;);    &#125;;    public static void main(String[] args) &#123;        ConnectElasticsearch.connect(SEARCH_BY_BOOL_CONDITION);    &#125;&#125;</code></pre><p>后台打印</p><pre><code>took:28mstimeout:falsetotal:1 hitsMaxScore:1.0hits========&gt;&gt;&#123;&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:&quot;30&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&lt;&lt;========Process finished with exit code 0</code></pre><h4 id="范围查询-2">范围查询</h4><pre><code>import com.lun.elasticsearch.hello.ConnectElasticsearch;import com.lun.elasticsearch.hello.ElasticsearchTask;import org.elasticsearch.action.search.SearchRequest;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.index.query.BoolQueryBuilder;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.index.query.RangeQueryBuilder;import org.elasticsearch.search.SearchHit;import org.elasticsearch.search.SearchHits;import org.elasticsearch.search.builder.SearchSourceBuilder;import org.elasticsearch.search.sort.SortOrder;public class QueryDoc &#123;    public static final ElasticsearchTask SEARCH_BY_RANGE = client -&gt; &#123;        // 创建搜索请求对象        SearchRequest request = new SearchRequest();        request.indices(&quot;user&quot;);        // 构建查询的请求体        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();        RangeQueryBuilder rangeQuery = QueryBuilders.rangeQuery(&quot;age&quot;);        // 大于等于        //rangeQuery.gte(&quot;30&quot;);        // 小于等于        rangeQuery.lte(&quot;40&quot;);        sourceBuilder.query(rangeQuery);        request.source(sourceBuilder);        SearchResponse response = client.search(request, RequestOptions.DEFAULT);        // 查询匹配        SearchHits hits = response.getHits();        System.out.println(&quot;took:&quot; + response.getTook());        System.out.println(&quot;timeout:&quot; + response.isTimedOut());        System.out.println(&quot;total:&quot; + hits.getTotalHits());        System.out.println(&quot;MaxScore:&quot; + hits.getMaxScore());        System.out.println(&quot;hits========&gt;&gt;&quot;);        for (SearchHit hit : hits) &#123;        //输出每条查询的结果信息            System.out.println(hit.getSourceAsString());        &#125;        System.out.println(&quot;&lt;&lt;========&quot;);    &#125;;    public static void main(String[] args) &#123;        ConnectElasticsearch.connect(SEARCH_BY_RANGE);    &#125;&#125;</code></pre><p>​</p><p>后台打印</p><pre><code>took:1mstimeout:falsetotal:5 hitsMaxScore:1.0hits========&gt;&gt;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:&quot;10&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&#123;&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:&quot;30&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&#123;&quot;name&quot;:&quot;wangwu1&quot;,&quot;age&quot;:&quot;40&quot;,&quot;sex&quot;:&quot;男&quot;&#125;&#123;&quot;name&quot;:&quot;wangwu2&quot;,&quot;age&quot;:&quot;20&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&#123;&quot;name&quot;:&quot;wangwu4&quot;,&quot;age&quot;:&quot;20&quot;,&quot;sex&quot;:&quot;男&quot;&#125;&lt;&lt;========Process finished with exit code 0</code></pre><h3 id="27-入门-JavaAPI-文档-高级查询-模糊查询-高亮查询">27-入门-JavaAPI-文档-高级查询-模糊查询 &amp; 高亮查询</h3><h4 id="模糊查询">模糊查询</h4><pre><code>import com.lun.elasticsearch.hello.ConnectElasticsearch;import com.lun.elasticsearch.hello.ElasticsearchTask;import org.elasticsearch.action.search.SearchRequest;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.common.unit.Fuzziness;import org.elasticsearch.index.query.BoolQueryBuilder;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.index.query.RangeQueryBuilder;import org.elasticsearch.search.SearchHit;import org.elasticsearch.search.SearchHits;import org.elasticsearch.search.builder.SearchSourceBuilder;import org.elasticsearch.search.sort.SortOrder;public class QueryDoc &#123;        public static final ElasticsearchTask SEARCH_BY_FUZZY_CONDITION = client -&gt; &#123;        // 创建搜索请求对象        SearchRequest request = new SearchRequest();        request.indices(&quot;user&quot;);        // 构建查询的请求体        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();        sourceBuilder.query(QueryBuilders.fuzzyQuery(&quot;name&quot;,&quot;wangwu&quot;).fuzziness(Fuzziness.ONE));        request.source(sourceBuilder);        SearchResponse response = client.search(request, RequestOptions.DEFAULT);        // 查询匹配        SearchHits hits = response.getHits();        System.out.println(&quot;took:&quot; + response.getTook());        System.out.println(&quot;timeout:&quot; + response.isTimedOut());        System.out.println(&quot;total:&quot; + hits.getTotalHits());        System.out.println(&quot;MaxScore:&quot; + hits.getMaxScore());        System.out.println(&quot;hits========&gt;&gt;&quot;);        for (SearchHit hit : hits) &#123;            //输出每条查询的结果信息            System.out.println(hit.getSourceAsString());        &#125;        System.out.println(&quot;&lt;&lt;========&quot;);    &#125;;</code></pre><p>​<br>​        public static void main(String[] args) {<br>​    //        ConnectElasticsearch.connect(SEARCH_ALL);<br>​    //        ConnectElasticsearch.connect(SEARCH_BY_CONDITION);<br>​    //        ConnectElasticsearch.connect(SEARCH_BY_PAGING);<br>​    //        ConnectElasticsearch.connect(SEARCH_WITH_ORDER);<br>​    //        ConnectElasticsearch.connect(SEARCH_BY_BOOL_CONDITION);<br>​    //        ConnectElasticsearch.connect(SEARCH_BY_RANGE);<br>​            ConnectElasticsearch.connect(SEARCH_BY_FUZZY_CONDITION);<br>​        }<br>​<br>}</p><p>后台打印</p><pre><code>took:152mstimeout:falsetotal:4 hitsMaxScore:1.2837042hits========&gt;&gt;&#123;&quot;name&quot;:&quot;wangwu1&quot;,&quot;age&quot;:&quot;40&quot;,&quot;sex&quot;:&quot;男&quot;&#125;&#123;&quot;name&quot;:&quot;wangwu2&quot;,&quot;age&quot;:&quot;20&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&#123;&quot;name&quot;:&quot;wangwu3&quot;,&quot;age&quot;:&quot;50&quot;,&quot;sex&quot;:&quot;男&quot;&#125;&#123;&quot;name&quot;:&quot;wangwu4&quot;,&quot;age&quot;:&quot;20&quot;,&quot;sex&quot;:&quot;男&quot;&#125;&lt;&lt;========Process finished with exit code 0</code></pre><h4 id="高亮查询-2">高亮查询</h4><pre><code>import com.lun.elasticsearch.hello.ConnectElasticsearch;import com.lun.elasticsearch.hello.ElasticsearchTask;import org.elasticsearch.action.search.SearchRequest;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.common.unit.Fuzziness;import org.elasticsearch.index.query.BoolQueryBuilder;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.index.query.RangeQueryBuilder;import org.elasticsearch.index.query.TermsQueryBuilder;import org.elasticsearch.search.SearchHit;import org.elasticsearch.search.SearchHits;import org.elasticsearch.search.builder.SearchSourceBuilder;import org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;import org.elasticsearch.search.fetch.subphase.highlight.HighlightField;import org.elasticsearch.search.sort.SortOrder;import java.util.Map;public class QueryDoc &#123;        public static final ElasticsearchTask SEARCH_WITH_HIGHLIGHT = client -&gt; &#123;        // 高亮查询        SearchRequest request = new SearchRequest().indices(&quot;user&quot;);        //2.创建查询请求体构建器        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();        //构建查询方式：高亮查询        TermsQueryBuilder termsQueryBuilder =                QueryBuilders.termsQuery(&quot;name&quot;,&quot;zhangsan&quot;);        //设置查询方式        sourceBuilder.query(termsQueryBuilder);        //构建高亮字段        HighlightBuilder highlightBuilder = new HighlightBuilder();        highlightBuilder.preTags(&quot;&lt;font color='red'&gt;&quot;);//设置标签前缀        highlightBuilder.postTags(&quot;&lt;/font&gt;&quot;);//设置标签后缀        highlightBuilder.field(&quot;name&quot;);//设置高亮字段        //设置高亮构建对象        sourceBuilder.highlighter(highlightBuilder);        //设置请求体        request.source(sourceBuilder);        //3.客户端发送请求，获取响应对象        SearchResponse response = client.search(request, RequestOptions.DEFAULT);        //4.打印响应结果        SearchHits hits = response.getHits();        System.out.println(&quot;took::&quot;+response.getTook());        System.out.println(&quot;time_out::&quot;+response.isTimedOut());        System.out.println(&quot;total::&quot;+hits.getTotalHits());        System.out.println(&quot;max_score::&quot;+hits.getMaxScore());        System.out.println(&quot;hits::::&gt;&gt;&quot;);        for (SearchHit hit : hits) &#123;            String sourceAsString = hit.getSourceAsString();            System.out.println(sourceAsString);            //打印高亮结果            Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();            System.out.println(highlightFields);        &#125;        System.out.println(&quot;&lt;&lt;::::&quot;);    &#125;;</code></pre><p>​<br>​        public static void main(String[] args) {<br>​            ConnectElasticsearch.connect(SEARCH_WITH_HIGHLIGHT);<br>​        }<br>​<br>}</p><p>后台打印</p><pre><code>took::672mstime_out::falsetotal::1 hitsmax_score::1.0hits::::&gt;&gt;&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:&quot;10&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&#123;name=[name], fragments[[&lt;font color='red'&gt;zhangsan&lt;/font&gt;]]&#125;&lt;&lt;::::Process finished with exit code 0</code></pre><h3 id="28-入门-JavaAPI-文档-高级查询-最大值查询-分组查询">28-入门-JavaAPI-文档-高级查询-最大值查询 &amp; 分组查询</h3><h4 id="最大值查询">最大值查询</h4><pre><code>import com.lun.elasticsearch.hello.ConnectElasticsearch;import com.lun.elasticsearch.hello.ElasticsearchTask;import org.elasticsearch.action.search.SearchRequest;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.common.unit.Fuzziness;import org.elasticsearch.index.query.BoolQueryBuilder;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.index.query.RangeQueryBuilder;import org.elasticsearch.index.query.TermsQueryBuilder;import org.elasticsearch.search.SearchHit;import org.elasticsearch.search.SearchHits;import org.elasticsearch.search.aggregations.AggregationBuilders;import org.elasticsearch.search.builder.SearchSourceBuilder;import org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;import org.elasticsearch.search.fetch.subphase.highlight.HighlightField;import org.elasticsearch.search.sort.SortOrder;import java.util.Map;public class QueryDoc &#123;        public static final ElasticsearchTask SEARCH_WITH_MAX = client -&gt; &#123;        // 高亮查询        SearchRequest request = new SearchRequest().indices(&quot;user&quot;);        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();        sourceBuilder.aggregation(AggregationBuilders.max(&quot;maxAge&quot;).field(&quot;age&quot;));        //设置请求体        request.source(sourceBuilder);        //3.客户端发送请求，获取响应对象        SearchResponse response = client.search(request, RequestOptions.DEFAULT);        //4.打印响应结果        SearchHits hits = response.getHits();        System.out.println(response);    &#125;;    public static void main(String[] args) &#123;        ConnectElasticsearch.connect(SEARCH_WITH_MAX);    &#125;&#125;</code></pre><p>后台打印</p><pre><code>&#123;&quot;took&quot;:16,&quot;timed_out&quot;:false,&quot;_shards&quot;:&#123;&quot;total&quot;:1,&quot;successful&quot;:1,&quot;skipped&quot;:0,&quot;failed&quot;:0&#125;,&quot;hits&quot;:&#123;&quot;total&quot;:&#123;&quot;value&quot;:6,&quot;relation&quot;:&quot;eq&quot;&#125;,&quot;max_score&quot;:1.0,&quot;hits&quot;:[&#123;&quot;_index&quot;:&quot;user&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;1001&quot;,&quot;_score&quot;:1.0,&quot;_source&quot;:&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:&quot;10&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&#125;,&#123;&quot;_index&quot;:&quot;user&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;1002&quot;,&quot;_score&quot;:1.0,&quot;_source&quot;:&#123;&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:&quot;30&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&#125;,&#123;&quot;_index&quot;:&quot;user&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;1003&quot;,&quot;_score&quot;:1.0,&quot;_source&quot;:&#123;&quot;name&quot;:&quot;wangwu1&quot;,&quot;age&quot;:&quot;40&quot;,&quot;sex&quot;:&quot;男&quot;&#125;&#125;,&#123;&quot;_index&quot;:&quot;user&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;1004&quot;,&quot;_score&quot;:1.0,&quot;_source&quot;:&#123;&quot;name&quot;:&quot;wangwu2&quot;,&quot;age&quot;:&quot;20&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&#125;,&#123;&quot;_index&quot;:&quot;user&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;1005&quot;,&quot;_score&quot;:1.0,&quot;_source&quot;:&#123;&quot;name&quot;:&quot;wangwu3&quot;,&quot;age&quot;:&quot;50&quot;,&quot;sex&quot;:&quot;男&quot;&#125;&#125;,&#123;&quot;_index&quot;:&quot;user&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;1006&quot;,&quot;_score&quot;:1.0,&quot;_source&quot;:&#123;&quot;name&quot;:&quot;wangwu4&quot;,&quot;age&quot;:&quot;20&quot;,&quot;sex&quot;:&quot;男&quot;&#125;&#125;]&#125;,&quot;aggregations&quot;:&#123;&quot;max#maxAge&quot;:&#123;&quot;value&quot;:50.0&#125;&#125;&#125;Process finished with exit code 0</code></pre><h4 id="分组查询">分组查询</h4><pre><code>import com.lun.elasticsearch.hello.ConnectElasticsearch;import com.lun.elasticsearch.hello.ElasticsearchTask;import org.elasticsearch.action.search.SearchRequest;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.common.unit.Fuzziness;import org.elasticsearch.index.query.BoolQueryBuilder;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.index.query.RangeQueryBuilder;import org.elasticsearch.index.query.TermsQueryBuilder;import org.elasticsearch.search.SearchHit;import org.elasticsearch.search.SearchHits;import org.elasticsearch.search.aggregations.AggregationBuilders;import org.elasticsearch.search.builder.SearchSourceBuilder;import org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;import org.elasticsearch.search.fetch.subphase.highlight.HighlightField;import org.elasticsearch.search.sort.SortOrder;import java.util.Map;public class QueryDoc &#123;public static final ElasticsearchTask SEARCH_WITH_GROUP = client -&gt; &#123;        SearchRequest request = new SearchRequest().indices(&quot;user&quot;);        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();        sourceBuilder.aggregation(AggregationBuilders.terms(&quot;age_groupby&quot;).field(&quot;age&quot;));        //设置请求体        request.source(sourceBuilder);        //3.客户端发送请求，获取响应对象        SearchResponse response = client.search(request, RequestOptions.DEFAULT);        //4.打印响应结果        SearchHits hits = response.getHits();        System.out.println(response);    &#125;;    public static void main(String[] args) &#123;        ConnectElasticsearch.connect(SEARCH_WITH_GROUP);    &#125;&#125;</code></pre><p>后台打印</p><pre><code>&#123;&quot;took&quot;:10,&quot;timed_out&quot;:false,&quot;_shards&quot;:&#123;&quot;total&quot;:1,&quot;successful&quot;:1,&quot;skipped&quot;:0,&quot;failed&quot;:0&#125;,&quot;hits&quot;:&#123;&quot;total&quot;:&#123;&quot;value&quot;:6,&quot;relation&quot;:&quot;eq&quot;&#125;,&quot;max_score&quot;:1.0,&quot;hits&quot;:[&#123;&quot;_index&quot;:&quot;user&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;1001&quot;,&quot;_score&quot;:1.0,&quot;_source&quot;:&#123;&quot;name&quot;:&quot;zhangsan&quot;,&quot;age&quot;:&quot;10&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&#125;,&#123;&quot;_index&quot;:&quot;user&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;1002&quot;,&quot;_score&quot;:1.0,&quot;_source&quot;:&#123;&quot;name&quot;:&quot;lisi&quot;,&quot;age&quot;:&quot;30&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&#125;,&#123;&quot;_index&quot;:&quot;user&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;1003&quot;,&quot;_score&quot;:1.0,&quot;_source&quot;:&#123;&quot;name&quot;:&quot;wangwu1&quot;,&quot;age&quot;:&quot;40&quot;,&quot;sex&quot;:&quot;男&quot;&#125;&#125;,&#123;&quot;_index&quot;:&quot;user&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;1004&quot;,&quot;_score&quot;:1.0,&quot;_source&quot;:&#123;&quot;name&quot;:&quot;wangwu2&quot;,&quot;age&quot;:&quot;20&quot;,&quot;sex&quot;:&quot;女&quot;&#125;&#125;,&#123;&quot;_index&quot;:&quot;user&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;1005&quot;,&quot;_score&quot;:1.0,&quot;_source&quot;:&#123;&quot;name&quot;:&quot;wangwu3&quot;,&quot;age&quot;:&quot;50&quot;,&quot;sex&quot;:&quot;男&quot;&#125;&#125;,&#123;&quot;_index&quot;:&quot;user&quot;,&quot;_type&quot;:&quot;_doc&quot;,&quot;_id&quot;:&quot;1006&quot;,&quot;_score&quot;:1.0,&quot;_source&quot;:&#123;&quot;name&quot;:&quot;wangwu4&quot;,&quot;age&quot;:&quot;20&quot;,&quot;sex&quot;:&quot;男&quot;&#125;&#125;]&#125;,&quot;aggregations&quot;:&#123;&quot;lterms#age_groupby&quot;:&#123;&quot;doc_count_error_upper_bound&quot;:0,&quot;sum_other_doc_count&quot;:0,&quot;buckets&quot;:[&#123;&quot;key&quot;:20,&quot;doc_count&quot;:2&#125;,&#123;&quot;key&quot;:10,&quot;doc_count&quot;:1&#125;,&#123;&quot;key&quot;:30,&quot;doc_count&quot;:1&#125;,&#123;&quot;key&quot;:40,&quot;doc_count&quot;:1&#125;,&#123;&quot;key&quot;:50,&quot;doc_count&quot;:1&#125;]&#125;&#125;&#125;Process finished with exit code 0</code></pre><h2 id="第3章-Elasticsearch环境">第3章 Elasticsearch环境</h2><h3 id="29-环境-简介">29-环境-简介</h3><h4 id="单机-集群">单机 &amp; 集群</h4><p>单台 Elasticsearch 服务器提供服务，往往都有最大的负载能力，超过这个阈值，服务器<br>性能就会大大降低甚至不可用，所以生产环境中，一般都是运行在指定服务器集群中。<br>除了负载能力，单点服务器也存在其他问题：</p><ul><li>单台机器存储容量有限</li><li>单服务器容易出现单点故障，无法实现高可用</li><li>单服务的并发处理能力有限</li></ul><p>配置服务器集群时，集群中节点数量没有限制，大于等于 2 个节点就可以看做是集群了。一<br>般出于高性能及高可用方面来考虑集群中节点数量都是 3 个以上</p><p>总之，集群能提高性能，增加容错。</p><h4 id="集群-Cluster">集群 Cluster</h4><p>**一个集群就是由一个或多个服务器节点组织在一起，共同持有整个的数据，并一起提供索引和搜索功能。**一个 Elasticsearch 集群有一个唯一的名字标识，这个名字默认就是”elasticsearch”。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群。</p><h4 id="节点-Node">节点 Node</h4><p>集群中包含很多服务器， 一个节点就是其中的一个服务器。 作为集群的一部分，它存储数据，参与集群的索引和搜索功能。</p><p>一个节点也是由一个名字来标识的，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的时候赋予节点。这个名字对于管理工作来说挺重要的，因为在这个管理过程中，你会去确定网络中的哪些服务器对应于 Elasticsearch 集群中的哪些节点。</p><p>一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做“elasticsearch”的集群中，这意味着，如果你在你的网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。</p><p>在一个集群里，只要你想，可以拥有任意多个节点。而且，如果当前你的网络中没有运<br>行任何 Elasticsearch 节点，这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的<br>集群。</p><h3 id="30-环境-Windows集群部署">30-环境-Windows集群部署</h3><h4 id="部署集群">部署集群</h4><p>一、创建 elasticsearch-cluster 文件夹</p><p>创建 elasticsearch-7.8.0-cluster 文件夹，在内部复制三个 elasticsearch 服务。</p><p><img src="../assets/elasticsearch/bb0bb111f455c3ee28faf4ea1d200e97.png" alt=""></p><p>二、修改集群文件目录中每个节点的 config/elasticsearch.yml 配置文件</p><p><strong>node-1001 节点</strong></p><pre><code>#节点 1 的配置信息：#集群名称，节点之间要保持一致cluster.name: my-elasticsearch#节点名称，集群内要唯一node.name: node-1001node.master: truenode.data: true#ip 地址network.host: localhost#http 端口http.port: 1001#tcp 监听端口transport.tcp.port: 9301#discovery.seed_hosts: [&quot;localhost:9301&quot;, &quot;localhost:9302&quot;,&quot;localhost:9303&quot;]#discovery.zen.fd.ping_timeout: 1m#discovery.zen.fd.ping_retries: 5#集群内的可以被选为主节点的节点列表#cluster.initial_master_nodes: [&quot;node-1&quot;, &quot;node-2&quot;,&quot;node-3&quot;]#跨域配置#action.destructive_requires_name: truehttp.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;</code></pre><p><strong>node-1002 节点</strong></p><pre><code>#节点 2 的配置信息：#集群名称，节点之间要保持一致cluster.name: my-elasticsearch#节点名称，集群内要唯一node.name: node-1002node.master: truenode.data: true#ip 地址network.host: localhost#http 端口http.port: 1002#tcp 监听端口transport.tcp.port: 9302discovery.seed_hosts: [&quot;localhost:9301&quot;]discovery.zen.fd.ping_timeout: 1mdiscovery.zen.fd.ping_retries: 5#集群内的可以被选为主节点的节点列表#cluster.initial_master_nodes: [&quot;node-1&quot;, &quot;node-2&quot;,&quot;node-3&quot;]#跨域配置#action.destructive_requires_name: truehttp.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;</code></pre><p><strong>node-1003 节点</strong></p><pre><code>#节点 3 的配置信息：#集群名称，节点之间要保持一致cluster.name: my-elasticsearch#节点名称，集群内要唯一node.name: node-1003node.master: truenode.data: true#ip 地址network.host: localhost#http 端口http.port: 1003#tcp 监听端口transport.tcp.port: 9303#候选主节点的地址，在开启服务后可以被选为主节点discovery.seed_hosts: [&quot;localhost:9301&quot;, &quot;localhost:9302&quot;]discovery.zen.fd.ping_timeout: 1mdiscovery.zen.fd.ping_retries: 5#集群内的可以被选为主节点的节点列表#cluster.initial_master_nodes: [&quot;node-1&quot;, &quot;node-2&quot;,&quot;node-3&quot;]#跨域配置#action.destructive_requires_name: truehttp.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;</code></pre><p>三、如果有必要，删除每个节点中的 data 目录中所有内容 。</p><h4 id="启动集群">启动集群</h4><p>分别依次双击执行节点的bin/elasticsearch.bat, 启动节点服务器（可以编写一个脚本启动），启动后，会自动加入指定名称的集群。</p><h4 id="测试集群">测试集群</h4><p>一、用Postman，查看集群状态</p><pre><code>1. `GET http://127.0.0.1:1001/_cluster/health`2. `GET http://127.0.0.1:1002/_cluster/health`3. `GET http://127.0.0.1:1003/_cluster/health`</code></pre><p>返回结果皆为如下：</p><pre><code>&#123;    &quot;cluster_name&quot;: &quot;my-application&quot;,    &quot;status&quot;: &quot;green&quot;,    &quot;timed_out&quot;: false,    &quot;number_of_nodes&quot;: 3,    &quot;number_of_data_nodes&quot;: 3,    &quot;active_primary_shards&quot;: 0,    &quot;active_shards&quot;: 0,    &quot;relocating_shards&quot;: 0,    &quot;initializing_shards&quot;: 0,    &quot;unassigned_shards&quot;: 0,    &quot;delayed_unassigned_shards&quot;: 0,    &quot;number_of_pending_tasks&quot;: 0,    &quot;number_of_in_flight_fetch&quot;: 0,    &quot;task_max_waiting_in_queue_millis&quot;: 0,    &quot;active_shards_percent_as_number&quot;: 100.0&#125;</code></pre><p><strong>status字段</strong> 指示着当前集群在总体上是否工作正常。它的三种颜色含义如下：</p><pre><code>1. green：所有的主分片和副本分片都正常运行。2. yellow：所有的主分片都正常运行，但不是所有的副本分片都正常运行。3. red：有主分片没能正常运行。</code></pre><p>二、用Postman，在一节点增加索引，另一节点获取索引</p><p>向集群中的node-1001节点增加索引：</p><pre><code>#PUT http://127.0.0.1:1001/user</code></pre><p>返回结果：</p><pre><code>&#123;    &quot;acknowledged&quot;: true,    &quot;shards_acknowledged&quot;: true,    &quot;index&quot;: &quot;user&quot;&#125;</code></pre><p>向集群中的node-1003节点获取索引：</p><pre><code>#GET http://127.0.0.1:1003/user</code></pre><p>返回结果：</p><pre><code>&#123;    &quot;user&quot;: &#123;        &quot;aliases&quot;: &#123;&#125;,        &quot;mappings&quot;: &#123;&#125;,        &quot;settings&quot;: &#123;            &quot;index&quot;: &#123;                &quot;creation_date&quot;: &quot;1617993035885&quot;,                &quot;number_of_shards&quot;: &quot;1&quot;,                &quot;number_of_replicas&quot;: &quot;1&quot;,                &quot;uuid&quot;: &quot;XJKERwQlSJ6aUxZEN2EV0w&quot;,                &quot;version&quot;: &#123;                    &quot;created&quot;: &quot;7080099&quot;                &#125;,                &quot;provided_name&quot;: &quot;user&quot;            &#125;        &#125;    &#125;&#125;</code></pre><p>如果在1003创建索引，同样在1001也能获取索引信息，这就是集群能力。</p><h3 id="31-环境-Linux单节点部署">31-环境-Linux单节点部署</h3><h4 id="软件安装">软件安装</h4><p>一、下载软件</p><p><a href="https://www.elastic.co/cn/downloads/past-releases/elasticsearch-7-8-0">下载Linux版的Elasticsearch</a></p><p>二、解压软件</p><pre><code># 解压缩tar -zxvf elasticsearch-7.8.0-linux-x86_64.tar.gz -C /opt/module# 改名mv elasticsearch-7.8.0 es</code></pre><p>三、创建用户</p><p>因为安全问题， Elasticsearch 不允许 root 用户直接运行，所以要创建新用户，在 root 用户中创建新用户。</p><pre><code>useradd es #新增 es 用户passwd es #为 es 用户设置密码userdel -r es #如果错了，可以删除再加chown -R es:es /opt/module/es #文件夹所有者</code></pre><p>四、修改配置文件</p><p>修改/opt/module/es/config/elasticsearch.yml文件。</p><pre><code># 加入如下配置cluster.name: elasticsearchnode.name: node-1network.host: 0.0.0.0http.port: 9200cluster.initial_master_nodes: [&quot;node-1&quot;]</code></pre><p>修改/etc/security/limits.conf</p><pre><code># 在文件末尾中增加下面内容# 每个进程可以打开的文件数的限制es soft nofile 65536es hard nofile 65536</code></pre><p>修改/etc/security/limits.d/20-nproc.conf</p><pre><code># 在文件末尾中增加下面内容# 每个进程可以打开的文件数的限制es soft nofile 65536es hard nofile 65536# 操作系统级别对每个用户创建的进程数的限制* hard nproc 4096# 注： * 带表 Linux 所有用户名称</code></pre><p>修改/etc/sysctl.conf</p><pre><code># 在文件中增加下面内容# 一个进程可以拥有的 VMA(虚拟内存区域)的数量,默认值为 65536vm.max_map_count=655360</code></pre><p>重新加载</p><pre><code>sysctl -p</code></pre><h4 id="启动软件">启动软件</h4><p>使用 ES 用户启动</p><pre><code>cd /opt/module/es/#启动bin/elasticsearch#后台启动bin/elasticsearch -d  </code></pre><p>启动时，会动态生成文件，如果文件所属用户不匹配，会发生错误，需要重新进行修改用户和用户组</p><p><img src="../assets/elasticsearch/a1db2a83d71b7d619dd28bd1d21b6d1a.png" alt=""></p><p>关闭防火墙</p><pre><code>#暂时关闭防火墙systemctl stop firewalld#永久关闭防火墙systemctl enable firewalld.service #打开防火墙永久性生效，重启后不会复原systemctl disable firewalld.service #关闭防火墙，永久性生效，重启后不会复原</code></pre><h4 id="测试软件">测试软件</h4><p>浏览器中输入地址： <a href="http://linux1:9200/">http://linux1:9200/</a></p><p><img src="../assets/elasticsearch/647a8a0494376b22002da5386eb473ac.png" alt=""></p><h3 id="32-环境-Linux集群部署">32-环境-Linux集群部署</h3><h4 id="软件安装-2">软件安装</h4><p>一、下载软件</p><p><a href="https://www.elastic.co/cn/downloads/past-releases/elasticsearch-7-8-0">下载Linux版的Elasticsearch</a></p><p>二、解压软件</p><pre><code># 解压缩tar -zxvf elasticsearch-7.8.0-linux-x86_64.tar.gz -C /opt/module# 改名mv elasticsearch-7.8.0 es-cluster</code></pre><p>将软件分发到其他节点： linux2, linux3</p><p>三、创建用户</p><p>因为安全问题， Elasticsearch 不允许 root 用户直接运行，所以要创建新用户，在 root 用户中创建新用户。</p><pre><code>useradd es #新增 es 用户passwd es #为 es 用户设置密码userdel -r es #如果错了，可以删除再加chown -R es:es /opt/module/es #文件夹所有者</code></pre><p>四、修改配置文件</p><p>修改/opt/module/es/config/elasticsearch.yml 文件，分发文件。</p><pre><code># 加入如下配置#集群名称cluster.name: cluster-es#节点名称， 每个节点的名称不能重复node.name: node-1#ip 地址， 每个节点的地址不能重复network.host: linux1#是不是有资格主节点node.master: truenode.data: truehttp.port: 9200# head 插件需要这打开这两个配置http.cors.allow-origin: &quot;*&quot;http.cors.enabled: truehttp.max_content_length: 200mb#es7.x 之后新增的配置，初始化一个新的集群时需要此配置来选举 mastercluster.initial_master_nodes: [&quot;node-1&quot;]#es7.x 之后新增的配置，节点发现discovery.seed_hosts: [&quot;linux1:9300&quot;,&quot;linux2:9300&quot;,&quot;linux3:9300&quot;]gateway.recover_after_nodes: 2network.tcp.keep_alive: truenetwork.tcp.no_delay: truetransport.tcp.compress: true#集群内同时启动的数据任务个数，默认是 2 个cluster.routing.allocation.cluster_concurrent_rebalance: 16#添加或删除节点及负载均衡时并发恢复的线程个数，默认 4 个cluster.routing.allocation.node_concurrent_recoveries: 16#初始化数据恢复时，并发恢复线程的个数，默认 4 个cluster.routing.allocation.node_initial_primaries_recoveries: 16</code></pre><p>修改/etc/security/limits.conf ，分发文件</p><pre><code># 在文件末尾中增加下面内容es soft nofile 65536es hard nofile 65536</code></pre><p>修改/etc/security/limits.d/20-nproc.conf，分发文件</p><pre><code># 在文件末尾中增加下面内容es soft nofile 65536es hard nofile 65536\* hard nproc 4096\# 注： * 带表 Linux 所有用户名称</code></pre><p>修改/etc/sysctl.conf</p><pre><code># 在文件中增加下面内容vm.max_map_count=655360</code></pre><p>重新加载</p><pre><code>sysctl -p</code></pre><h4 id="启动软件-2">启动软件</h4><p>分别在不同节点上启动 ES 软件</p><pre><code>cd /opt/module/es-cluster#启动bin/elasticsearch#后台启动bin/elasticsearch -d</code></pre><h4 id="测试集群-2">测试集群</h4><p><img src="../assets/elasticsearch/73ba4fe5821e2c9d98ff8d16221e5fe8.png" alt=""></p><h2 id="第4章-Elasticsearch进阶">第4章 Elasticsearch进阶</h2><h3 id="33-进阶-核心概念">33-进阶-核心概念</h3><p><img src="../assets/elasticsearch/fb2d75748469e8880f85ff9825557db4.png" alt=""></p><h4 id="索引Index">索引Index</h4><p>一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母），并且当我们要对这个索引中的文档进行索引、搜索、更新和删除（CRUD）的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。</p><p>能搜索的数据必须索引，这样的好处是可以提高查询速度，比如：新华字典前面的目录就是索引的意思，目录可以提高查询速度。</p><p><strong>Elasticsearch 索引的精髓：一切设计都是为了提高搜索的性能。</strong></p><h4 id="类型Type">类型Type</h4><p>在一个索引中，你可以定义一种或多种类型。</p><p>一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具<br>有一组共同字段的文档定义一个类型。不同的版本，类型发生了不同的变化。</p><table><thead><tr><th>版本</th><th>Type</th></tr></thead><tbody><tr><td>5.x</td><td>支持多种 type</td></tr><tr><td>6.x</td><td>只能有一种 type</td></tr><tr><td>7.x</td><td>默认不再支持自定义索引类型（默认类型为： _doc）</td></tr></tbody></table><h4 id="文档Document">文档Document</h4><p>一个文档是一个可被索引的基础信息单元，也就是一条数据。</p><p>比如：你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以 JSON（Javascript Object Notation）格式来表示，而 JSON 是一个到处存在的互联网数据交互格式。</p><p>在一个 index/type 里面，你可以存储任意多的文档。</p><h4 id="字段Field">字段Field</h4><p>相当于是数据表的字段，对文档数据根据不同属性进行的分类标识。</p><h4 id="映射Mapping">映射Mapping</h4><p>mapping 是处理数据的方式和规则方面做一些限制，如：某个字段的数据类型、默认值、分析器、是否被索引等等。这些都是映射里面可以设置的，其它就是处理 ES 里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。</p><h4 id="分片Shards">分片Shards</h4><p>一个索引可以存储超出单个节点硬件限制的大量数据。比如，一个具有 10 亿文档数据<br>的索引占据 1TB 的磁盘空间，而任一节点都可能没有这样大的磁盘空间。 或者单个节点处理搜索请求，响应太慢。为了解决这个问题，**Elasticsearch 提供了将索引划分成多份的能力，每一份就称之为分片。**当你创建一个索引的时候，你可以指定你想要的分片的数量。 <strong>每个分片本身也是一个功能完善并且独立的“索引”</strong> ，这个“索引”可以被放置到集群中的任何节点上。</p><p>分片很重要，主要有两方面的原因：</p><pre><code>1. 允许你水平分割 / 扩展你的内容容量。2. 允许你在分片之上进行分布式的、并行的操作，进而提高性能/吞吐量。</code></pre><p>至于一个分片怎样分布，它的文档怎样聚合和搜索请求，是完全由 Elasticsearch 管理的，对于作为用户的你来说，这些都是透明的，无需过分关心。</p><p>被混淆的概念是，一个 Lucene 索引 我们在 Elasticsearch 称作 分片 。 一个Elasticsearch 索引 是分片的集合。 当 Elasticsearch 在索引中搜索的时候， 他发送查询到每一个属于索引的分片（Lucene 索引），然后合并每个分片的结果到一个全局的结果集。</p><p>Lucene 是 Apache 软件基金会 Jakarta 项目组的一个子项目，提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在 Java 开发环境里 Lucene 是一个成熟的免费开源工具。就其本身而言， Lucene 是当前以及最近几年最受欢迎的免费 Java 信息检索程序库。但 Lucene 只是一个提供全文搜索功能类库的核心工具包，而真正使用它还需要一个完善的服务框架搭建起来进行应用。</p><p>目前市面上流行的搜索引擎软件，主流的就两款： Elasticsearch 和 Solr,这两款都是基于 Lucene 搭建的，可以独立部署启动的搜索引擎服务软件。由于内核相同，所以两者除了服务器安装、部署、管理、集群以外，对于数据的操作 修改、添加、保存、查询等等都十分类似。</p><h4 id="副本Replicas">副本Replicas</h4><p>在一个网络 / 云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于<br>离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的， Elasticsearch 允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片(副本)。</p><p>复制分片之所以重要，有两个主要原因：</p><ul><li>在分片/节点失败的情况下， <strong>提供了高可用性</strong> 。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。</li><li>扩展你的搜索量/吞吐量，因为搜索可以在所有的副本上并行运行。</li></ul><p>总之，每个索引可以被分成多个分片。一个索引也可以被复制 0 次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。</p><p>分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。</p><p>默认情况下，Elasticsearch 中的每个索引被分片 1 个主分片和 1 个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有 1 个主分片和另外 1 个复制分片（1 个完全拷贝），这样的话每个索引总共就有 2 个分片， 我们需要根据索引需要确定分片个数。</p><h4 id="分配Allocation">分配Allocation</h4><p>将分片分配给某个节点的过程，包括分配主分片或者副本。如果是副本，还包含从主分片复制数据的过程。这个过程是由 master 节点完成的。</p><h3 id="34-进阶-系统架构-简介">34-进阶-系统架构-简介</h3><p><img src="../assets/elasticsearch/06e709a9e2dafdd29d09f42d17b98aaf.png" alt=""></p><p>一个运行中的 Elasticsearch 实例称为一个节点，而集群是由一个或者多个拥有相同<br><a href="http://cluster.name">cluster.name</a> 配置的节点组成， 它们共同承担数据和负载的压力。当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据。</p><p>当一个节点被选举成为主节点时， 它将负责管理集群范围内的所有变更，例如增加、<br>删除索引，或者增加、删除节点等。 而主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量的增加它也不会成为瓶颈。 任何节点都可以成为主节点。我们的示例集群就只有一个节点，所以它同时也成为了主节点。</p><p>作为用户，我们可以将请求发送到集群中的任何节点 ，包括主节点。 每个节点都知道<br>任意文档所处的位置，并且能够将我们的请求直接转发到存储我们所需文档的节点。 无论我们将请求发送到哪个节点，它都能负责从各个包含我们所需文档的节点收集回数据，并将最终结果返回給客户端。 Elasticsearch 对这一切的管理都是透明的。</p><h3 id="35-进阶-单节点集群">35-进阶-单节点集群</h3><p>我们在包含一个空节点的集群内创建名为 users 的索引，为了演示目的，我们将分配 3个主分片和一份副本（每个主分片拥有一个副本分片）。</p><pre><code>#PUT http://127.0.0.1:1001/users&#123;    &quot;settings&quot; : &#123;        &quot;number_of_shards&quot; : 3,        &quot;number_of_replicas&quot; : 1    &#125;&#125;</code></pre><p>集群现在是拥有一个索引的单节点集群。所有 3 个主分片都被分配在 node-1 。</p><p><img src="../assets/elasticsearch/42c19d9cfde517cdf576933e3d9e8f4a.png" alt=""></p><p>通过 elasticsearch-head 插件（一个Chrome插件）查看集群情况 。</p><p><img src="../assets/elasticsearch/50645290d5a783985dbce090237ec21b.png" alt=""></p><ul><li>集群健康值:yellow( 3 of 6 )：表示当前集群的全部主分片都正常运行，但是副本分片没有全部处在正常状态。</li><li><img src="../assets/elasticsearch/376296c37deb618bdc96e407d583650d.png" alt="">：3 个主分片正常。</li><li><img src="../assets/elasticsearch/70f6cbd3921827ecebd62a58540c4c21.png" alt="">：3 个副本分片都是 Unassigned，它们都没有被分配到任何节点。 在同 一个节点上既保存原始数据又保存副本是没有意义的，因为一旦失去了那个节点，我们也将丢失该节点 上的所有副本数据。</li></ul><p>当前集群是正常运行的，但存在丢失数据的风险。</p><hr><p><strong>elasticsearch-head chrome插件安装</strong></p><p><a href="https://github.com/mobz/elasticsearch-head">插件获取网址</a>，下载压缩包，解压后将内容放入自定义命名为elasticsearch-head文件夹。</p><p>接着点击Chrome右上角选项-&gt;工具-&gt;管理扩展（或则地址栏输入chrome://extensions/），选择打开“开发者模式”，让后点击“加载已解压得扩展程序”，选择elasticsearch-head/_site，即可完成chrome插件安装。</p><h3 id="36-进阶-故障转移">36-进阶-故障转移</h3><p>当集群中只有一个节点在运行时，意味着会有一个单点故障问题——没有冗余。 幸运的是，我们只需再启动一个节点即可防止数据丢失。当你在同一台机器上启动了第二个节点时，只要它和第一个节点有同样的 <a href="http://cluster.name">cluster.name</a> 配置，它就会自动发现集群并加入到其中。但是在不同机器上启动节点的时候，为了加入到同一集群，你需要配置一个可连接到的单播主机列表。之所以配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上<br>运行的节点才会自动组成集群。</p><p>如果启动了第二个节点，集群将会拥有两个节点 : 所有主分片和副本分片都已被分配 。</p><p><img src="../assets/elasticsearch/85b977e5c116d8851c56cb4a46e78c44.png" alt=""></p><p>通过 elasticsearch-head 插件查看集群情况</p><p><img src="../assets/elasticsearch/c13e253f5e48acad777bb7c0783fea9f.png" alt=""></p><ul><li>集群健康值:green( 3 of 6 )：表示所有 6 个分片（包括 3 个主分片和 3 个副本分片）都在正常运行。</li><li><img src="../assets/elasticsearch/376296c37deb618bdc96e407d583650d.png" alt="">：3 个主分片正常。</li><li><img src="../assets/elasticsearch/376296c37deb618bdc96e407d583650d.png" alt="">：第二个节点加入到集群后， 3 个副本分片将会分配到这个节点上——每 个主分片对应一个副本分片。这意味着当集群内任何一个节点出现问题时，我们的数据都完好无损。所 有新近被索引的文档都将会保存在主分片上，然后被并行的复制到对应的副本分片上。这就保证了我们 既可以从主分片又可以从副本分片上获得文档。</li></ul><h3 id="37-进阶-水平扩容">37-进阶-水平扩容</h3><p>怎样为我们的正在增长中的应用程序按需扩容呢？当启动了第三个节点，我们的集群将会拥有三个节点的集群 : 为了分散负载而对分片进行重新分配 。</p><p><img src="../assets/elasticsearch/f780e2f8b277df6834883ba1098b0145.png" alt=""></p><p>通过 elasticsearch-head 插件查看集群情况。</p><p><img src="../assets/elasticsearch/70515723bc8dad6e692a1e6cd48b0271.png" alt=""></p><ul><li>集群健康值:green( 3 of 6 )：表示所有 6 个分片（包括 3 个主分片和 3 个副本分片）都在正常运行。</li><li><img src="../assets/elasticsearch/1f1c8a251e580654d7d16b24287020f6.png" alt="">Node 1 和 Node 2 上各有一个分片被迁移到了新的 Node 3 节点，现在每个节点上都拥有 2 个分片， 而不是之前的 3 个。 这表示每个节点的硬件资源（CPU, RAM, I/O)将被更少的分片所共享，每个分片 的性能将会得到提升。</li></ul><p>分片是一个功能完整的搜索引擎，它拥有使用一个节点上的所有资源的能力。 我们这个拥有 6 个分 片（3 个主分片和 3 个副本分片）的索引可以最大扩容到 6 个节点，每个节点上存在一个分片，并且每个 分片拥有所在节点的全部资源。</p><p><strong>但是如果我们想要扩容超过 6 个节点怎么办呢？</strong></p><p>主分片的数目在索引创建时就已经确定了下来。实际上，这个数目定义了这个索引能够<br>存储 的最大数据量。（实际大小取决于你的数据、硬件和使用场景。） 但是，读操作——<br>搜索和返回数据——可以同时被主分片 或 副本分片所处理，所以当你拥有越多的副本分片<br>时，也将拥有越高的吞吐量。</p><p>在运行中的集群上是可以动态调整副本分片数目的，我们可以按需伸缩集群。让我们把<br>副本数从默认的 1 增加到 2。</p><pre><code>#PUT http://127.0.0.1:1001/users/_settings&#123;    &quot;number_of_replicas&quot; : 2&#125;</code></pre><p>users 索引现在拥有 9 个分片： 3 个主分片和 6 个副本分片。 这意味着我们可以将集群<br>扩容到 9 个节点，每个节点上一个分片。相比原来 3 个节点时，集群搜索性能可以提升 3 倍。</p><p><img src="../assets/elasticsearch/480452b5569d6728896e449123a90771.png" alt=""></p><p>通过 elasticsearch-head 插件查看集群情况：</p><p><img src="../assets/elasticsearch/d4f049926a603486dada7e4fb8b8d6b7.png" alt=""></p><p>当然，如果只是在相同节点数目的集群上增加更多的副本分片并不能提高性能，因为每<br>个分片从节点上获得的资源会变少。 你需要增加更多的硬件资源来提升吞吐量。</p><p>但是更多的副本分片数提高了数据冗余量：按照上面的节点配置，我们可以在失去 2 个节点<br>的情况下不丢失任何数据。</p><h3 id="38-进阶-应对故障">38-进阶-应对故障</h3><p>我们关闭第一个节点，这时集群的状态为:关闭了一个节点后的集群。</p><p><img src="../assets/elasticsearch/f7bb8a49a554ecc03416a0c7d1da5168.png" alt=""></p><p>我们关闭的节点是一个主节点。而集群必须拥有一个主节点来保证正常工作，所以发生<br>的第一件事情就是选举一个新的主节点： Node 2 。在我们关闭 Node 1 的同时也失去了主<br>分片 1 和 2 ，并且在缺失主分片的时候索引也不能正常工作。 如果此时来检查集群的状况，我们看到的状态将会为 red ：不是所有主分片都在正常工作。</p><p>幸运的是，在其它节点上存在着这两个主分片的完整副本， 所以新的主节点立即将这些分片在 Node 2 和 Node 3 上对应的副本分片提升为主分片， 此时集群的状态将会为yellow。这个提升主分片的过程是瞬间发生的，如同按下一个开关一般。</p><p><img src="../assets/elasticsearch/e0b2904f7716f05d6bb2121599985e58.png" alt=""></p><p><strong>为什么我们集群状态是 yellow 而不是 green 呢？</strong></p><p>虽然我们拥有所有的三个主分片，但是同时设置了每个主分片需要对应 2 份副本分片，而此<br>时只存在一份副本分片。 所以集群不能为 green 的状态，不过我们不必过于担心：如果我<br>们同样关闭了 Node 2 ，我们的程序 依然 可以保持在不丢任何数据的情况下运行，因为<br>Node 3 为每一个分片都保留着一份副本。</p><p>如果想回复原来的样子，要确保Node-1的配置文件有如下配置：</p><pre><code>discovery.seed_hosts: [&quot;localhost:9302&quot;, &quot;localhost:9303&quot;]</code></pre><p>集群可以将缺失的副本分片再次进行分配，那么集群的状态也将恢复成之前的状态。 如果 Node 1 依然拥有着之前的分片，它将尝试去重用它们，同时仅从主分片复制发生了修改的数据文件。和之前的集群相比，只是 Master 节点切换了。</p><p><img src="../assets/elasticsearch/515e8e655f3b7202eac3b2d4ab207e87.png" alt=""></p><h3 id="39-进阶-路由计算-分片控制">39-进阶-路由计算 &amp; 分片控制</h3><h4 id="路由计算">路由计算</h4><p>当索引一个文档的时候，文档会被存储到一个主分片中。 Elasticsearch 如何知道一个<br>文档应该存放到哪个分片中呢？当我们创建文档时，它如何决定这个文档应当被存储在分片 1 还是分片 2 中呢？首先这肯定不会是随机的，否则将来要获取文档的时候我们就不知道从何处寻找了。实际上，这个过程是根据下面这个公式决定的：</p><pre><code>shard = hash(routing) % number_of_primary_shards</code></pre><p>routing 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。 routing 通过hash 函数生成一个数字，然后这个数字再除以 number_of_primary_shards （主分片的数量）后得到余数 。这个分布在 0 到 number_of_primary_shards-1 之间的余数，就是我们所寻求的文档所在分片的位置。</p><p><img src="../assets/elasticsearch/efac1343b2f67583b0dc4ab1f4723aa1.png" alt=""></p><p>这就解释了为什么我们要在创建索引的时候就确定好主分片的数量并且永远不会改变这个数量:因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。</p><p>所有的文档API ( get . index . delete 、 bulk , update以及 mget ）都接受一个叫做routing 的路由参数，通过这个参数我们可以自定义文档到分片的映射。一个自定义的路由参数可以用来确保所有相关的文档—一例如所有属于同一个用户的文档——都被存储到同一个分片中。</p><h4 id="分片控制">分片控制</h4><p>我们可以发送请求到集群中的任一节点。每个节点都有能力处理任意请求。每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上。在下面的例子中，如果将所有的请求发送到Node 1001，我们将其称为协调节点 <strong>coordinating node</strong> 。</p><p><img src="../assets/elasticsearch/6621b76b7ab5fc48608d4220d8dd6524.png" alt=""></p><p>当发送请求的时候， 为了扩展负载，更好的做法是轮询集群中所有的节点。</p><h3 id="40-进阶-数据写流程">40-进阶-数据写流程</h3><p>新建、索引和删除请求都是写操作， 必须在主分片上面完成之后才能被复制到相关的副本分片。</p><p><img src="../assets/elasticsearch/f7d714e2ba957a44198c500ccf167965.png" alt=""></p><p>在客户端收到成功响应时，文档变更已经在主分片和所有副本分片执行完成，变更是安全的。有一些可选的 <strong>请求参数</strong> 允许您影响这个过程，可能以数据安全为代价提升性能。这些选项很少使用，因为 Elasticsearch 已经很快，但是为了完整起见， 请参考下文：</p><pre><code>1. consistency</code></pre><ul><li><p>即一致性。在默认设置下，即使仅仅是在试图执行一个写操作之前，主分片都会要求必须要有规定数量quorum（或者换种说法，也即必须要有大多数）的分片副本处于活跃可用状态，才会去执行写操作（其中分片副本 可以是主分片或者副本分片）。这是为了避免在发生网络分区故障（network partition）的时候进行写操作，进而导致数据不一致。 规定数量即： <strong>int((primary + number_of_replicas) / 2 ) + 1</strong></p></li><li><p>consistency 参数的值可以设为：</p><ul><li>one ：只要主分片状态 ok 就允许执行写操作。</li><li>all：必须要主分片和所有副本分片的状态没问题才允许执行写操作。</li><li>quorum：默认值为quorum , 即大多数的分片副本状态没问题就允许执行写操作。</li></ul></li><li><p>注意，规定数量的计算公式中number_of_replicas指的是在索引设置中的设定副本分片数，而不是指当前处理活动状态的副本分片数。如果你的索引设置中指定了当前索引拥有3个副本分片，那规定数量的计算结果即： <strong>int((1 primary + 3 replicas) / 2) + 1 = 3</strong> ，如果此时你只启动两个节点，那么处于活跃状态的分片副本数量就达不到规定数量，也因此您将无法索引和删除任何文档。</p><ol start="2"><li>timeout</li></ol><ul><li>如果没有足够的副本分片会发生什么？Elasticsearch 会等待，希望更多的分片出现。默认情况下，它最多等待 1 分钟。 如果你需要，你可以使用timeout参数使它更早终止：100是100 毫秒，30s是30秒。</li></ul></li></ul><p>新索引默认有1个副本分片，这意味着为满足规定数量应该需要两个活动的分片副本。 但是，这些默认的设置会阻止我们在单一节点上做任何事情。为了避免这个问题，要求只有当number_of_replicas 大于1的时候，规定数量才会执行。</p><h3 id="41-进阶-数据读流程">41-进阶-数据读流程</h3><p><img src="../assets/elasticsearch/23324729d68b2393ee4c97714271a179.png" alt=""></p><p>在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。 在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。 一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。</p><h3 id="42-进阶-更新流程-批量操作流程">42-进阶-更新流程 &amp; 批量操作流程</h3><h4 id="更新流程">更新流程</h4><p>部分更新一个文档结合了先前说明的读取和写入流程：</p><p><img src="../assets/elasticsearch/cf2eee0f85ea866d6618160407dfa770.png" alt=""></p><p>部分更新一个文档的步骤如下：</p><pre><code>1. 客户端向Node 1发送更新请求。2. 它将请求转发到主分片所在的Node 3 。3. Node 3从主分片检索文档，修改_source字段中的JSON，并且尝试重新索引主分片的文档。如果文档已经被另一个进程修改,它会重试步骤3 ,超过retry_on_conflict次后放弃。4. 如果 Node 3成功地更新文档，它将新版本的文档并行转发到Node 1和 Node 2上的副本分片，重新建立索引。一旦所有副本分片都返回成功，Node 3向协调节点也返回成功，协调节点向客户端返回成功。</code></pre><p>当主分片把更改转发到副本分片时， 它不会转发更新请求。 相反，它转发完整文档的新版本。请记住，这些更改将会异步转发到副本分片，并且不能保证它们以发送它们相同的顺序到达。 如果 Elasticsearch 仅转发更改请求，则可能以错误的顺序应用更改，导致得到损坏的文档。</p><h4 id="批量操作流程">批量操作流程</h4><p>**mget和 bulk API的模式类似于单文档模式。**区别在于协调节点知道每个文档存在于哪个分片中。它将整个多文档请求分解成每个分片的多文档请求，并且将这些请求并行转发到每个参与节点。</p><p>协调节点一旦收到来自每个节点的应答，就将每个节点的响应收集整理成单个响应，返回给客户端。</p><p><img src="../assets/elasticsearch/aa0dcfc87f52e03718bf040955737131.png" alt=""></p><p><strong>用单个 mget 请求取回多个文档所需的步骤顺序:</strong></p><pre><code>1. 客户端向 Node 1 发送 mget 请求。2. Node 1为每个分片构建多文档获取请求，然后并行转发这些请求到托管在每个所需的主分片或者副本分片的节点上。一旦收到所有答复，Node 1 构建响应并将其返回给客户端。</code></pre><p>可以对docs数组中每个文档设置routing参数。</p><p>bulk API， 允许在单个批量请求中执行多个创建、索引、删除和更新请求。</p><p><img src="../assets/elasticsearch/daa9804f8e3e925a79648722ce865458.png" alt=""></p><p><strong>bulk API 按如下步骤顺序执行：</strong></p><pre><code>1. 客户端向Node 1 发送 bulk请求。2. Node 1为每个节点创建一个批量请求，并将这些请求并行转发到每个包含主分片的节点主机。3. 主分片一个接一个按顺序执行每个操作。当每个操作成功时,主分片并行转发新文档（或删除）到副本分片，然后执行下一个操作。一旦所有的副本分片报告所有操作成功，该节点将向协调节点报告成功，协调节点将这些响应收集整理并返回给客户端。</code></pre><h3 id="43-进阶-倒排索引">43-进阶-倒排索引</h3><p>分片是Elasticsearch最小的工作单元。但是究竟什么是一个分片，它是如何工作的？</p><p>传统的数据库每个字段存储单个值，但这对全文检索并不够。文本字段中的每个单词需要被搜索，对数据库意味着需要单个字段有索引多值的能力。最好的支持是一个字段多个值需求的数据结构是 <strong>倒排索引</strong> 。</p><h4 id="倒排索引原理">倒排索引原理</h4><p>Elasticsearch使用一种称为倒排索引的结构，它适用于快速的全文搜索。</p><p>见其名，知其意，有倒排索引，肯定会对应有正向索引。正向索引（forward index），反向索引（inverted index）更熟悉的名字是 <strong>倒排索引</strong> 。</p><p>所谓的 <strong>正向索引</strong> ，就是搜索引擎会将待搜索的文件都对应一个文件ID，搜索时将这个ID和搜索关键字进行对应，形成K-V对，然后对关键字进行统计计数。（统计？？下文有解释）</p><p><img src="../assets/elasticsearch/c2671e403ce2a34fa970eed855c24dcc.png" alt=""></p><p>但是互联网上收录在搜索引擎中的文档的数目是个天文数字，这样的索引结构根本无法满足实时返回排名结果的要求。所以，搜索引擎会将正向索引重新构建为倒排索引，即把文件ID对应到关键词的映射转换为关键词到文件ID的映射，每个关键词都对应着一系列的文件，这些文件中都出现这个关键词。</p><p><img src="../assets/elasticsearch/e40b13dd2bfd4b94e4582c3e61e71219.png" alt=""></p><h4 id="倒排索引的例子">倒排索引的例子</h4><p>一个倒排索引由文档中所有不重复词的列表构成，对于其中每个词，有一个包含它的文档列表。例如，假设我们有两个文档，每个文档的content域包含如下内容：</p><ul><li>The quick brown fox jumped over the lazy dog</li><li>Quick brown foxes leap over lazy dogs in summer</li></ul><p>为了创建倒排索引，我们首先将每个文档的content域拆分成单独的词（我们称它为词条或tokens )，创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。结果如下所示：</p><p><img src="../assets/elasticsearch/455abdefd189d57bea9b04624299e98f.png" alt=""></p><p>现在，如果我们想搜索 <code>quick</code> <code>brown</code> ，我们只需要查找包含每个词条的文档：</p><p><img src="../assets/elasticsearch/3b20be22f6157bfc885066c444cbcf43.png" alt=""></p><p>两个文档都匹配，但是第一个文档比第二个匹配度更高。如果我们使用仅计算匹配词条数量的简单相似性算法，那么我们可以说，对于我们查询的相关性来讲，第一个文档比第二个文档更佳。</p><p>但是，我们目前的倒排索引有一些问题：</p><ul><li><p><code>Quick</code>和<code>quick</code>以独立的词条出现，然而用户可能认为它们是相同的词。</p></li><li><p><code>fox</code>和<code>foxes</code>非常相似，就像<code>dog</code>和<code>dogs</code>；他们有相同的词根。</p></li><li><p><code>jumped</code>和<code>leap</code>，尽管没有相同的词根，但他们的意思很相近。他们是同义词。</p></li></ul><p>使用前面的索引搜索<code>+Quick</code> <code>+fox</code>不会得到任何匹配文档。(记住，＋前缀表明这个词必须存在）。</p><p>只有同时出现<code>Quick</code>和<code>fox</code> 的文档才满足这个查询条件，但是第一个文档包含<code>quick</code> <code>fox</code> ，第二个文档包含<code>Quick</code> <code>foxes</code> 。</p><p>我们的用户可以合理的期望两个文档与查询匹配。我们可以做的更好。</p><p>如果我们将词条规范为标准模式，那么我们可以找到与用户搜索的词条不完全一致，但具有足够相关性的文档。例如：</p><ul><li><code>Quick</code>可以小写化为<code>quick</code>。</li><li><code>foxes</code>可以词干提取变为词根的格式为<code>fox</code>。类似的，<code>dogs</code>可以为提取为<code>dog</code>。</li><li><code>jumped</code>和<code>leap</code>是同义词，可以索引为相同的单词<code>jump</code> 。</li></ul><p>现在索引看上去像这样：</p><p><img src="../assets/elasticsearch/0ad8f1859d570282118f9a807d03c3e5.png" alt=""></p><p>这还远远不够。我们搜索<code>+Quick</code> <code>+fox</code> 仍然会失败，因为在我们的索引中，已经没有<code>Quick</code>了。但是，如果我们对搜索的字符串使用与content域相同的标准化规则，会变成查询<code>+quick</code> <code>+fox</code>，这样两个文档都会匹配！分词和标准化的过程称为 <strong>分析</strong> ，这非常重要。你只能搜索在索引中出现的词条，所以索引文本和查询字符串必须标准化为相同的格式。</p><h3 id="44-进阶-文档搜索">44-进阶-文档搜索</h3><h4 id="不可改变的倒排索引">不可改变的倒排索引</h4><p>早期的全文检索会为整个文档集合建立一个很大的倒排索引并将其写入到磁盘。 一旦新的索引就绪，旧的就会被其替换，这样最近的变化便可以被检索到。</p><p>倒排索引被写入磁盘后是不可改变的：它永远不会修改。</p><ul><li><p>不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。</p></li><li><p>一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。</p></li><li><p>其它缓存(像filter缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。</p></li><li><p>写入单个大的倒排索引允许数据被压缩，减少磁盘IO和需要被缓存到内存的索引的使用量。</p></li></ul><p>当然，一个不变的索引也有不好的地方。主要事实是它是不可变的! 你不能修改它。如果你需要让一个新的文档可被搜索，你需要重建整个索引。这要么对一个索引所能包含的数据量造成了很大的限制，要么对索引可被更新的频率造成了很大的限制。</p><h4 id="动态更新索引">动态更新索引</h4><p>如何在保留不变性的前提下实现倒排索引的更新？</p><p>答案是：用更多的索引。通过增加新的补充索引来反映新近的修改，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到,从最早的开始查询完后再对结果进行合并。</p><p>Elasticsearch基于Lucene，这个java库引入了 <strong>按段搜索</strong> 的概念。每一段本身都是一个倒排索引，但索引在 Lucene 中除表示所有段的集合外，还增加了提交点的概念—一个列出了所有已知段的文件。</p><p><img src="../assets/elasticsearch/80bad62f2ac013c4163e56efd9db67a0.png" alt=""></p><p>按段搜索会以如下流程执行：</p><p>一、新文档被收集到内存索引缓存。</p><p><img src="../assets/elasticsearch/59cdb15678e5dda127ee9bb52735ea0b.png" alt=""></p><p>二、不时地, 缓存被提交。</p><pre><code>1. 一个新的段，一个追加的倒排索引，被写入磁盘。2. 一个新的包含新段名字的提交点被写入磁盘。3. 磁盘进行同步，所有在文件系统缓存中等待的写入都刷新到磁盘，以确保它们被写入物理文件</code></pre><p>三、新的段被开启，让它包含的文档可见以被搜索。</p><p>四、内存缓存被清空，等待接收新的文档。</p><p><img src="../assets/elasticsearch/f439f014142e02f660b4983b9ae8e87c.png" alt=""></p><p>当一个查询被触发，所有已知的段按顺序被查询。词项统计会对所有段的结果进行聚合，以保证每个词和每个文档的关联都被准确计算。这种方式可以用相对较低的成本将新文档添加到索引。</p><p>段是不可改变的，所以既不能从把文档从旧的段中移除，也不能修改旧的段来进行反映文档的更新。取而代之的是，每个提交点会包含一个.del 文件，文件中会列出这些被删除文档的段信息。</p><p>当一个**文档被“删除”**时，它实际上只是在 .del 文件中被标记删除。一个被标记删除的文档仍然可以被查询匹配到，但它会在最终结果被返回前从结果集中移除。</p><p><strong>文档更新</strong> 也是类似的操作方式:当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。</p><h3 id="45-进阶-文档刷新-文档刷写-文档合并">45-进阶-文档刷新 &amp; 文档刷写 &amp; 文档合并</h3><p><img src="../assets/elasticsearch/283c27e9a163cbc50790ce57d6d4d0af.png" alt=""></p><p><img src="../assets/elasticsearch/d56e43702d341e823299dc9c520811e5.png" alt=""></p><h4 id="近实时搜索">近实时搜索</h4><p>随着按段（per-segment）搜索的发展，一个新的文档从索引到可被搜索的延迟显著降低了。新文档在几分钟之内即可被检索，但这样还是不够快。磁盘在这里成为了瓶颈。 <strong>提交（Commiting）一个新的段到磁盘需要一个fsync来确保段被物理性地写入磁盘</strong> ，这样在断电的时候就不会丢失数据。但是fsync操作代价很大；如果每次索引一个文档都去执行一次的话会造成很大的性能问题。</p><p>我们需要的是一个更轻量的方式来使一个文档可被搜索，这意味着fsync要从整个过程中被移除。在Elasticsearch和磁盘之间是 <strong>文件系统缓存</strong> 。像之前描述的一样，在内存索引缓冲区中的文档会被写入到一个新的段中。但是这里新段会被先写入到文件系统缓存—这一步代价会比较低，稍后再被刷新到磁盘—这一步代价比较高。不过只要文件已经在缓存中，就可以像其它文件一样被打开和读取了。</p><p><img src="../assets/elasticsearch/d655f874e83aabe687402f8a59774dfb.png" alt=""></p><p>Lucene允许新段被写入和打开，使其包含的文档在未进行一次完整提交时便对搜索可见。这种方式比进行一次提交代价要小得多，并且在不影响性能的前提下可以被频繁地执行。</p><p><img src="../assets/elasticsearch/797254f836dc5326dbc8d3079c081a0f.png" alt=""></p><p>在 Elasticsearch 中，写入和打开一个新段的轻量的过程叫做refresh。默认情况下每个分片会每秒自动刷新一次。这就是为什么我们说 Elasticsearch是近实时搜索：文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。</p><p>这些行为可能会对新用户造成困惑：他们索引了一个文档然后尝试搜索它，但却没有搜到。这个问题的解决办法是用refresh API执行一次手动刷新：/usersl_refresh</p><p>尽管刷新是比提交轻量很多的操作，它还是会有性能开销。当写测试的时候，手动刷新很有用，但是不要在生产环境下每次索引一个文档都去手动刷新。相反，你的应用需要意识到Elasticsearch 的近实时的性质，并接受它的不足。</p><p>并不是所有的情况都需要每秒刷新。可能你正在使用Elasticsearch索引大量的日志文件，你可能想优化索引速度而不是近实时搜索，可以通过设置refresh_interval ，降低每个索引的刷新频率</p><pre><code>&#123;    &quot;settings&quot;: &#123;    &quot;refresh_interval&quot;: &quot;30s&quot;    &#125;&#125;</code></pre><p>refresh_interval可以在既存索引上进行动态更新。在生产环境中，当你正在建立一个大的新索引时，可以先关闭自动刷新，待开始使用该索引时，再把它们调回来。</p><pre><code># 关闭自动刷新PUT /users/_settings&#123; &quot;refresh_interval&quot;: -1 &#125;# 每一秒刷新PUT /users/_settings&#123; &quot;refresh_interval&quot;: &quot;1s&quot; &#125;</code></pre><h4 id="持久化变更">持久化变更</h4><p>如果没有用fsync把数据从文件系统缓存刷（flush）到硬盘，我们不能保证数据在断电甚至是程序正常退出之后依然存在。为了保证Elasticsearch 的可靠性，需要确保数据变化被持久化到磁盘。在动态更新索引，我们说一次完整的提交会将段刷到磁盘，并写入一个包含所有段列表的提交点。Elasticsearch 在启动或重新打开一个索引的过程中使用这个提交点来判断哪些段隶属于当前分片。</p><p>即使通过每秒刷新(refresh）实现了近实时搜索，我们仍然需要经常进行完整提交来确保能从失败中恢复。但在两次提交之间发生变化的文档怎么办?我们也不希望丢失掉这些数据。Elasticsearch 增加了一个translog ，或者叫事务日志，在每一次对Elasticsearch进行操作时均进行了日志记录。</p><p>整个流程如下:</p><p>一、一个文档被索引之后，就会被添加到内存缓冲区，并且追加到了 translog</p><p><img src="../assets/elasticsearch/6f10ea0ed1bd27dcc70e51368e980b5c.png" alt=""></p><p>二、刷新（refresh）使分片每秒被刷新（refresh）一次：</p><ul><li>这些在内存缓冲区的文档被写入到一个新的段中，且没有进行fsync操作。</li><li>这个段被打开，使其可被搜索。</li><li>内存缓冲区被清空。</li></ul><p><img src="../assets/elasticsearch/7cfd12d6bac372d571bf138aeed632c2.png" alt=""></p><p>三、这个进程继续工作，更多的文档被添加到内存缓冲区和追加到事务日志。</p><p><img src="../assets/elasticsearch/b377f6da9b5516d0b6a84e1a541156ad.png" alt=""></p><p>四、每隔一段时间—例如translog变得越来越大，索引被刷新（flush）；一个新的translog被创建，并且一个全量提交被执行。</p><ul><li><p>所有在内存缓冲区的文档都被写入一个新的段。</p></li><li><p>缓冲区被清空。</p></li><li><p>一个提交点被写入硬盘。</p></li><li><p>文件系统缓存通过fsync被刷新（flush） 。</p></li><li><p>老的translog被删除。</p></li></ul><p>translog 提供所有还没有被刷到磁盘的操作的一个持久化纪录。当Elasticsearch启动的时候，它会从磁盘中使用最后一个提交点去恢复己知的段，并且会重放translog 中所有在最后一次提交后发生的变更操作。</p><p>translog 也被用来提供实时CRUD。当你试着通过ID查询、更新、删除一个文档，它会在尝试从相应的段中检索之前，首先检查 translog任何最近的变更。这意味着它总是能够实时地获取到文档的最新版本。</p><p><img src="../assets/elasticsearch/7a6af0758245a8be2b890acf14b97ce0.png" alt=""></p><p>执行一个提交并且截断translog 的行为在 Elasticsearch被称作一次flush。分片每30分钟被自动刷新（flush)，或者在 translog 太大的时候也会刷新。</p><p>你很少需要自己手动执行flush操作，通常情况下，自动刷新就足够了。这就是说，在重启节点或关闭索引之前执行 flush有益于你的索引。当Elasticsearch尝试恢复或重新打开一个索引，它需要重放translog中所有的操作，所以如果日志越短，恢复越快。</p><p>translog 的目的是保证操作不会丢失，在文件被fsync到磁盘前，被写入的文件在重启之后就会丢失。默认translog是每5秒被fsync刷新到硬盘，或者在每次写请求完成之后执行（e.g. index, delete, update, bulk）。这个过程在主分片和复制分片都会发生。最终，基本上，这意味着在整个请求被fsync到主分片和复制分片的translog之前，你的客户端不会得到一个200 OK响应。</p><p>在每次请求后都执行一个fsync会带来一些性能损失，尽管实践表明这种损失相对较小（特别是 bulk 导入，它在一次请求中平摊了大量文档的开销）。</p><p>但是对于一些大容量的偶尔丢失几秒数据问题也并不严重的集群，使用异步的 fsync还是比较有益的。比如，写入的数据被缓存到内存中，再每5秒执行一次 fsync 。如果你决定使用异步translog 的话，你需要保证在发生 crash 时，丢失掉 sync_interval时间段的数据也无所谓。请在决定前知晓这个特性。如果你不确定这个行为的后果，最好是使用默认的参数{“index.translog.durability”: “request”}来避免数据丢失。</p><h4 id="段合并">段合并</h4><p>由于自动刷新流程每秒会创建一个新的段，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。每一个段都会消耗文件句柄、内存和 cpu运行周期。更重要的是，每个搜索请求都必须轮流检查每个段；所以段越多，搜索也就越慢。</p><p>Elasticsearch通过在后台进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。</p><p>段合并的时候会将那些旧的已删除文档从文件系统中清除。被删除的文档（或被更新文档的旧版本）不会被拷贝到新的大段中。</p><p>启动段合并不需要你做任何事。进行索引和搜索时会自动进行。</p><p>一、当索引的时候，刷新（refresh）操作会创建新的段并将段打开以供搜索使用。</p><p>二、合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中。这并不会中断索引和搜索。</p><p><img src="../assets/elasticsearch/578847dd5a6c2711c2507c068e47a34a.png" alt=""></p><p>三、一旦合并结束，老的段被删除</p><ul><li>新的段被刷新(flush)到了磁盘。</li><li>写入一个包含新段且排除旧的和较小的段的新提交点。</li><li>新的段被打开用来搜索。老的段被删除。</li></ul><p><img src="../assets/elasticsearch/634e2059c793b14ab225857d0a2805e0.png" alt=""></p><p>合并大的段需要消耗大量的 I/O 和 CPU 资源，如果任其发展会影响搜索性能。 Elasticsearch在默认情况下会对合并流程进行资源限制，所以搜索仍然有足够的资源很好地执行。</p><h3 id="46-进阶-文档分析">46-进阶-文档分析</h3><p>分析包含下面的过程：</p><ul><li>将一块文本分成适合于倒排索引的独立的词条。</li><li>将这些词条统一化为标准格式以提高它们的“可搜索性”，或者recall。</li></ul><p>分析器执行上面的工作。分析器实际上是将三个功能封装到了一个包里：</p><ul><li>字符过滤器：首先，字符串按顺序通过每个 字符过滤器 。他们的任务是在分词前整理字符串。一个字符过滤器可以用来去掉 HTML，或者将 &amp; 转化成 and。</li><li>分词器：其次，字符串被分词器分为单个的词条。一个简单的分词器遇到空格和标点的时候，可能会将文本拆分成词条。</li><li>Token 过滤器：最后，词条按顺序通过每个 token 过滤器 。这个过程可能会改变词条（例如，小写化Quick ），删除词条（例如， 像 a， and， the 等无用词），或者增加词条（例如，像jump和leap这种同义词）</li></ul><h4 id="内置分析器">内置分析器</h4><p>Elasticsearch还附带了可以直接使用的预包装的分析器。接下来我们会列出最重要的分析器。为了证明它们的差异，我们看看每个分析器会从下面的字符串得到哪些词条：</p><pre><code>&quot;Set the shape to semi-transparent by calling set_trans(5)&quot;</code></pre><ul><li>标准分析器</li></ul><p>标准分析器是Elasticsearch 默认使用的分析器。它是分析各种语言文本最常用的选择。它根据Unicode 联盟定义的单词边界划分文本。删除绝大部分标点。最后，将词条小写。它会产生：</p><pre><code>set, the, shape, to, semi, transparent, by, calling, set_trans, 5</code></pre><ul><li>简单分析器</li></ul><p>简单分析器在任何不是字母的地方分隔文本，将词条小写。它会产生：</p><pre><code>set, the, shape, to, semi, transparent, by, calling, set, trans</code></pre><ul><li>空格分析器</li></ul><p>空格分析器在空格的地方划分文本。它会产生:</p><pre><code>Set, the, shape, to, semi-transparent, by, calling, set_trans(5)</code></pre><ul><li>语言分析器</li></ul><p>特定语言分析器可用于很多语言。它们可以考虑指定语言的特点。例如，英语分析器附带了一组英语无用词（常用单词，例如and或者the ,它们对相关性没有多少影响），它们会被删除。由于理解英语语法的规则，这个分词器可以提取英语单词的词干。</p><p>英语分词器会产生下面的词条：</p><pre><code>set, shape, semi, transpar, call, set_tran, 5</code></pre><p>注意看transparent、calling和 set_trans已经变为词根格式。</p><h4 id="分析器使用场景">分析器使用场景</h4><p>当我们索引一个文档，它的全文域被分析成词条以用来创建倒排索引。但是，当我们在全文域搜索的时候，我们需要将查询字符串通过相同的分析过程，以保证我们搜索的词条格式与索引中的词条格式一致。</p><p>全文查询，理解每个域是如何定义的，因此它们可以做正确的事：</p><ul><li><p>当你查询一个全文域时，会对查询字符串应用相同的分析器，以产生正确的搜索词条列表。</p></li><li><p>当你查询一个精确值域时，不会分析查询字符串，而是搜索你指定的精确值。</p></li></ul><h4 id="测试分析器">测试分析器</h4><p>有些时候很难理解分词的过程和实际被存储到索引中的词条，特别是你刚接触Elasticsearch。为了理解发生了什么，你可以使用analyze API来看文本是如何被分析的。在消息体里，指定分析器和要分析的文本。</p><pre><code>#GET http://localhost:9200/_analyze&#123;    &quot;analyzer&quot;: &quot;standard&quot;,    &quot;text&quot;: &quot;Text to analyze&quot;&#125;</code></pre><p>结果中每个元素代表一个单独的词条：</p><pre><code>&#123;    &quot;tokens&quot;: [        &#123;            &quot;token&quot;: &quot;text&quot;,             &quot;start_offset&quot;: 0,             &quot;end_offset&quot;: 4,             &quot;type&quot;: &quot;&lt;ALPHANUM&gt;&quot;,             &quot;position&quot;: 1        &#125;,         &#123;            &quot;token&quot;: &quot;to&quot;,             &quot;start_offset&quot;: 5,             &quot;end_offset&quot;: 7,             &quot;type&quot;: &quot;&lt;ALPHANUM&gt;&quot;,             &quot;position&quot;: 2        &#125;,         &#123;            &quot;token&quot;: &quot;analyze&quot;,             &quot;start_offset&quot;: 8,             &quot;end_offset&quot;: 15,             &quot;type&quot;: &quot;&lt;ALPHANUM&gt;&quot;,             &quot;position&quot;: 3        &#125;    ]&#125;</code></pre><ul><li>token是实际存储到索引中的词条。</li><li>start_ offset 和end_ offset指明字符在原始字符串中的位置。</li><li>position指明词条在原始文本中出现的位置。</li></ul><h4 id="指定分析器">指定分析器</h4><p>当Elasticsearch在你的文档中检测到一个新的字符串域，它会自动设置其为一个全文字符串域，使用 标准 分析器对它进行分析。你不希望总是这样。可能你想使用一个不同的分析器，适用于你的数据使用的语言。有时候你想要一个字符串域就是一个字符串域，不使用分析，直接索引你传入的精确值，例如用户 ID 或者一个内部的状态域或标签。要做到这一点，我们必须手动指定这些域的映射。</p><p>（细粒度指定分析器）</p><h4 id="IK分词器">IK分词器</h4><p>首先通过 Postman 发送 GET 请求查询分词效果</p><pre><code># GET http://localhost:9200/_analyze&#123;&quot;text&quot;:&quot;测试单词&quot;&#125;</code></pre><p>ES 的默认分词器无法识别中文中测试、 单词这样的词汇，而是简单的将每个字拆完分为一个词。</p><pre><code>&#123;    &quot;tokens&quot;: [        &#123;            &quot;token&quot;: &quot;测&quot;,             &quot;start_offset&quot;: 0,             &quot;end_offset&quot;: 1,             &quot;type&quot;: &quot;&lt;IDEOGRAPHIC&gt;&quot;,             &quot;position&quot;: 0        &#125;,         &#123;            &quot;token&quot;: &quot;试&quot;,             &quot;start_offset&quot;: 1,             &quot;end_offset&quot;: 2,             &quot;type&quot;: &quot;&lt;IDEOGRAPHIC&gt;&quot;,             &quot;position&quot;: 1        &#125;,         &#123;            &quot;token&quot;: &quot;单&quot;,             &quot;start_offset&quot;: 2,             &quot;end_offset&quot;: 3,             &quot;type&quot;: &quot;&lt;IDEOGRAPHIC&gt;&quot;,             &quot;position&quot;: 2        &#125;,         &#123;            &quot;token&quot;: &quot;词&quot;,             &quot;start_offset&quot;: 3,             &quot;end_offset&quot;: 4,             &quot;type&quot;: &quot;&lt;IDEOGRAPHIC&gt;&quot;,             &quot;position&quot;: 3        &#125;    ]&#125;</code></pre><p>这样的结果显然不符合我们的使用要求，所以我们需要下载 ES 对应版本的中文分词器。</p><p><a href="https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v7.8.0">IK 中文分词器下载网址</a></p><p>将解压后的后的文件夹放入 ES 根目录下的 plugins 目录下，重启 ES 即可使用。</p><p>我们这次加入新的查询参数&quot;analyzer&quot;:“ik_max_word”。</p><pre><code># GET http://localhost:9200/_analyze&#123;&quot;text&quot;:&quot;测试单词&quot;,&quot;analyzer&quot;:&quot;ik_max_word&quot;&#125;</code></pre><ul><li>ik_max_word：会将文本做最细粒度的拆分。</li><li>ik_smart：会将文本做最粗粒度的拆分。</li></ul><p>使用中文分词后的结果为：</p><pre><code>&#123;    &quot;tokens&quot;: [        &#123;            &quot;token&quot;: &quot;测试&quot;,             &quot;start_offset&quot;: 0,             &quot;end_offset&quot;: 2,             &quot;type&quot;: &quot;CN_WORD&quot;,             &quot;position&quot;: 0        &#125;,         &#123;            &quot;token&quot;: &quot;单词&quot;,             &quot;start_offset&quot;: 2,             &quot;end_offset&quot;: 4,             &quot;type&quot;: &quot;CN_WORD&quot;,             &quot;position&quot;: 1        &#125;    ]&#125;</code></pre><p>ES 中也可以进行扩展词汇，首先查询</p><pre><code>#GET http://localhost:9200/_analyze&#123;    &quot;text&quot;:&quot;弗雷尔卓德&quot;,    &quot;analyzer&quot;:&quot;ik_max_word&quot;&#125;</code></pre><p>仅仅可以得到每个字的分词结果，我们需要做的就是使分词器识别到弗雷尔卓德也是一个词语。</p><pre><code>&#123;    &quot;tokens&quot;: [        &#123;            &quot;token&quot;: &quot;弗&quot;,            &quot;start_offset&quot;: 0,            &quot;end_offset&quot;: 1,            &quot;type&quot;: &quot;CN_CHAR&quot;,            &quot;position&quot;: 0        &#125;,        &#123;            &quot;token&quot;: &quot;雷&quot;,            &quot;start_offset&quot;: 1,            &quot;end_offset&quot;: 2,            &quot;type&quot;: &quot;CN_CHAR&quot;,            &quot;position&quot;: 1        &#125;,        &#123;            &quot;token&quot;: &quot;尔&quot;,            &quot;start_offset&quot;: 2,            &quot;end_offset&quot;: 3,            &quot;type&quot;: &quot;CN_CHAR&quot;,            &quot;position&quot;: 2        &#125;,        &#123;            &quot;token&quot;: &quot;卓&quot;,            &quot;start_offset&quot;: 3,            &quot;end_offset&quot;: 4,            &quot;type&quot;: &quot;CN_CHAR&quot;,            &quot;position&quot;: 3        &#125;,        &#123;            &quot;token&quot;: &quot;德&quot;,            &quot;start_offset&quot;: 4,            &quot;end_offset&quot;: 5,            &quot;type&quot;: &quot;CN_CHAR&quot;,            &quot;position&quot;: 4        &#125;    ]&#125;1. 首先进入 ES 根目录中的 plugins 文件夹下的 ik 文件夹，进入 config 目录，创建 custom.dic文件，写入“弗雷尔卓德”。2. 同时打开 IKAnalyzer.cfg.xml 文件，将新建的 custom.dic 配置其中。3. 重启 ES 服务器 。</code></pre><p>​<br>​    <?xml version="1.0" encoding="UTF-8"?><br>​    <!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd"><br>​    <properties><br>​    <comment>IK Analyzer 扩展配置</comment><br>​    <!--用户可以在这里配置自己的扩展字典 --><br>​    <entry key="ext_dict">custom.dic</entry><br>​     <!--用户可以在这里配置自己的扩展停止词字典--><br>​    <entry key="ext_stopwords"></entry><br>​    <!--用户可以在这里配置远程扩展字典 --><br>​    <!-- <entry key="remote_ext_dict">words_location</entry> --><br>​    <!--用户可以在这里配置远程扩展停止词字典--><br>​    <!-- <entry key="remote_ext_stopwords">words_location</entry> --><br>​    </properties></p><p>扩展后再次查询</p><pre><code># GET http://localhost:9200/_analyze&#123;&quot;text&quot;:&quot;测试单词&quot;,&quot;analyzer&quot;:&quot;ik_max_word&quot;&#125;</code></pre><p>返回结果如下：</p><pre><code>&#123;    &quot;tokens&quot;: [        &#123;            &quot;token&quot;: &quot;弗雷尔卓德&quot;,            &quot;start_offset&quot;: 0,            &quot;end_offset&quot;: 5,            &quot;type&quot;: &quot;CN_WORD&quot;,            &quot;position&quot;: 0        &#125;    ]&#125;</code></pre><h4 id="自定义分析器">自定义分析器</h4><p>虽然Elasticsearch带有一些现成的分析器，然而在分析器上Elasticsearch真正的强大之处在于，你可以通过在一个适合你的特定数据的设置之中组合字符过滤器、分词器、词汇单元过滤器来创建自定义的分析器。在分析与分析器我们说过，一个分析器就是在一个包里面组合了三种函数的一个包装器，三种函数按照顺序被执行：</p><h5 id="字符过滤器">字符过滤器</h5><p>字符过滤器用来整理一个尚未被分词的字符串。例如，如果我们的文本是HTML格式的，它会包含像<code>&lt;p&gt;</code>或者<code>&lt;div&gt;</code>这样的HTML标签，这些标签是我们不想索引的。我们可以使用html清除字符过滤器来移除掉所有的HTML标签，并且像把<code>&amp;Aacute;</code>转换为相对应的Unicode字符Á 这样，转换HTML实体。一个分析器可能有0个或者多个字符过滤器。</p><h5 id="分词器">分词器</h5><p>一个分析器必须有一个唯一的分词器。分词器把字符串分解成单个词条或者词汇单元。标准分析器里使用的标准分词器把一个字符串根据单词边界分解成单个词条，并且移除掉大部分的标点符号，然而还有其他不同行为的分词器存在。</p><p>例如，关键词分词器完整地输出接收到的同样的字符串，并不做任何分词。空格分词器只根据空格分割文本。正则分词器根据匹配正则表达式来分割文本。</p><h5 id="词单元过滤器">词单元过滤器</h5><p>经过分词，作为结果的词单元流会按照指定的顺序通过指定的词单元过滤器。词单元过滤器可以修改、添加或者移除词单元。我们已经提到过lowercase和stop词过滤器，但是在Elasticsearch 里面还有很多可供选择的词单元过滤器。词干过滤器把单词遏制为词干。ascii_folding过滤器移除变音符，把一个像&quot;très”这样的词转换为“tres”。</p><p>ngram和 edge_ngram词单元过滤器可以产生适合用于部分匹配或者自动补全的词单元。</p><h5 id="自定义分析器例子">自定义分析器例子</h5><p>接下来，我们看看如何创建自定义的分析器：</p><pre><code>#PUT http://localhost:9200/my_index&#123;    &quot;settings&quot;: &#123;        &quot;analysis&quot;: &#123;            &quot;char_filter&quot;: &#123;                &quot;&amp;_to_and&quot;: &#123;                    &quot;type&quot;: &quot;mapping&quot;,                     &quot;mappings&quot;: [                        &quot;&amp;=&gt; and &quot;                    ]                &#125;            &#125;,             &quot;filter&quot;: &#123;                &quot;my_stopwords&quot;: &#123;                    &quot;type&quot;: &quot;stop&quot;,                     &quot;stopwords&quot;: [                        &quot;the&quot;,                         &quot;a&quot;                    ]                &#125;            &#125;,             &quot;analyzer&quot;: &#123;                &quot;my_analyzer&quot;: &#123;                    &quot;type&quot;: &quot;custom&quot;,                     &quot;char_filter&quot;: [                        &quot;html_strip&quot;,                         &quot;&amp;_to_and&quot;                    ],                     &quot;tokenizer&quot;: &quot;standard&quot;,                     &quot;filter&quot;: [                        &quot;lowercase&quot;,                         &quot;my_stopwords&quot;                    ]                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>索引被创建以后，使用 analyze API 来 测试这个新的分析器：</p><pre><code># GET http://127.0.0.1:9200/my_index/_analyze&#123;    &quot;text&quot;:&quot;The quick &amp; brown fox&quot;,    &quot;analyzer&quot;: &quot;my_analyzer&quot;&#125;</code></pre><p>返回结果为：</p><pre><code>&#123;    &quot;tokens&quot;: [        &#123;            &quot;token&quot;: &quot;quick&quot;,            &quot;start_offset&quot;: 4,            &quot;end_offset&quot;: 9,            &quot;type&quot;: &quot;&lt;ALPHANUM&gt;&quot;,            &quot;position&quot;: 1        &#125;,        &#123;            &quot;token&quot;: &quot;and&quot;,            &quot;start_offset&quot;: 10,            &quot;end_offset&quot;: 11,            &quot;type&quot;: &quot;&lt;ALPHANUM&gt;&quot;,            &quot;position&quot;: 2        &#125;,        &#123;            &quot;token&quot;: &quot;brown&quot;,            &quot;start_offset&quot;: 12,            &quot;end_offset&quot;: 17,            &quot;type&quot;: &quot;&lt;ALPHANUM&gt;&quot;,            &quot;position&quot;: 3        &#125;,        &#123;            &quot;token&quot;: &quot;fox&quot;,            &quot;start_offset&quot;: 18,            &quot;end_offset&quot;: 21,            &quot;type&quot;: &quot;&lt;ALPHANUM&gt;&quot;,            &quot;position&quot;: 4        &#125;    ]&#125;</code></pre><h3 id="47-进阶-文档控制">47-进阶-文档控制</h3><h4 id="文档冲突">文档冲突</h4><p>当我们使用index API更新文档，可以一次性读取原始文档，做我们的修改，然后重新索引整个文档。最近的索引请求将获胜：无论最后哪一个文档被索引，都将被唯一存储在 Elasticsearch 中。如果其他人同时更改这个文档，他们的更改将丢失。</p><p>很多时候这是没有问题的。也许我们的主数据存储是一个关系型数据库，我们只是将数据复制到Elasticsearch中并使其可被搜索。也许两个人同时更改相同的文档的几率很小。或者对于我们的业务来说偶尔丢失更改并不是很严重的问题。</p><p>但有时丢失了一个变更就是非常严重的。试想我们使用Elasticsearch 存储我们网上商城商品库存的数量，每次我们卖一个商品的时候，我们在 Elasticsearch 中将库存数量减少。有一天，管理层决定做一次促销。突然地，我们一秒要卖好几个商品。假设有两个web程序并行运行，每一个都同时处理所有商品的销售。</p><p><img src="../assets/elasticsearch/beb2dbf57cb7737fbd1b1f060233be99.png" alt=""></p><p>web_1 对stock_count所做的更改已经丢失，因为 web_2不知道它的 stock_count的拷贝已经过期。结果我们会认为有超过商品的实际数量的库存，因为卖给顾客的库存商品并不存在，我们将让他们非常失望。</p><p>变更越频繁，读数据和更新数据的间隙越长，也就越可能丢失变更。在数据库领域中，有两种方法通常被用来确保并发更新时变更不会丢失：</p><ul><li>悲观并发控制：这种方法被关系型数据库广泛使用，它假定有变更冲突可能发生，因此阻塞访问资源以防止冲突。一个典型的例子是读取一行数据之前先将其锁住，确保只有放置锁的线程能够对这行数据进行修改。</li><li>乐观并发控制：Elasticsearch 中使用的这种方法假定冲突是不可能发生的，并且不会阻塞正在尝试的操作。然而，如果源数据在读写当中被修改，更新将会失败。应用程序接下来将决定该如何解决冲突。例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。</li></ul><h4 id="乐观并发控制">乐观并发控制</h4><p>Elasticsearch是分布式的。当文档创建、更新或删除时，新版本的文档必须复制到集群中的其他节点。Elasticsearch也是异步和并发的，这意味着这些复制请求被并行发送，并且到达目的地时也许顺序是乱的。Elasticsearch需要一种方法确保文档的旧版本不会覆盖新的版本。</p><p>当我们之前讨论index , GET和DELETE请求时，我们指出每个文档都有一个_version（版本号），当文档被修改时版本号递增。Elasticsearch使用这个version号来确保变更以正确顺序得到执行。如果旧版本的文档在新版本之后到达，它可以被简单的忽略。</p><p>我们可以利用version号来确保应用中相互冲突的变更不会导致数据丢失。我们通过指定想要修改文档的 version号来达到这个目的。如果该版本不是当前版本号，我们的请求将会失败。</p><p>老的版本es使用version，但是新版本不支持了，会报下面的错误，提示我们用if_seq _no和if _primary_term</p><p>创建索引</p><pre><code>#PUT http://127.0.0.1:9200/shopping/_create/1001</code></pre><p>返回结果</p><pre><code>&#123;    &quot;_index&quot;: &quot;shopping&quot;,    &quot;_type&quot;: &quot;_doc&quot;,    &quot;_id&quot;: &quot;1001&quot;,    &quot;_version&quot;: 1,    &quot;result&quot;: &quot;created&quot;,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 2,        &quot;successful&quot;: 1,        &quot;failed&quot;: 0    &#125;,    &quot;_seq_no&quot;: 10,    &quot;_primary_term&quot;: 15&#125;</code></pre><p>更新数据</p><pre><code>#POST http://127.0.0.1:9200/shopping/_update/1001&#123;    &quot;doc&quot;:&#123;        &quot;title&quot;:&quot;华为手机&quot;    &#125;&#125;</code></pre><p>返回结果：</p><pre><code>&#123;    &quot;_index&quot;: &quot;shopping&quot;,    &quot;_type&quot;: &quot;_doc&quot;,    &quot;_id&quot;: &quot;1001&quot;,    &quot;_version&quot;: 2,    &quot;result&quot;: &quot;updated&quot;,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 2,        &quot;successful&quot;: 1,        &quot;failed&quot;: 0    &#125;,    &quot;_seq_no&quot;: 11,    &quot;_primary_term&quot;: 15&#125;</code></pre><p>旧版本使用的防止冲突更新方法：</p><pre><code>#POST http://127.0.0.1:9200/shopping/_update/1001?version=1&#123;    &quot;doc&quot;:&#123;        &quot;title&quot;:&quot;华为手机2&quot;    &#125;&#125;</code></pre><p>返回结果：</p><pre><code>&#123;    &quot;error&quot;: &#123;        &quot;root_cause&quot;: [            &#123;                &quot;type&quot;: &quot;action_request_validation_exception&quot;,                &quot;reason&quot;: &quot;Validation Failed: 1: internal versioning can not be used for optimistic concurrency control. Please use `if_seq_no` and `if_primary_term` instead;&quot;            &#125;        ],        &quot;type&quot;: &quot;action_request_validation_exception&quot;,        &quot;reason&quot;: &quot;Validation Failed: 1: internal versioning can not be used for optimistic concurrency control. Please use `if_seq_no` and `if_primary_term` instead;&quot;    &#125;,    &quot;status&quot;: 400&#125;</code></pre><p>新版本使用的防止冲突更新方法：</p><pre><code>#POST http://127.0.0.1:9200/shopping/_update/1001?if_seq_no=11&amp;if_primary_term=15&#123;    &quot;doc&quot;:&#123;        &quot;title&quot;:&quot;华为手机2&quot;    &#125;&#125;</code></pre><p>返回结果：</p><pre><code>&#123;    &quot;_index&quot;: &quot;shopping&quot;,    &quot;_type&quot;: &quot;_doc&quot;,    &quot;_id&quot;: &quot;1001&quot;,    &quot;_version&quot;: 3,    &quot;result&quot;: &quot;updated&quot;,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 2,        &quot;successful&quot;: 1,        &quot;failed&quot;: 0    &#125;,    &quot;_seq_no&quot;: 12,    &quot;_primary_term&quot;: 16&#125;</code></pre><h4 id="外部系统版本控制">外部系统版本控制</h4><p>一个常见的设置是使用其它数据库作为主要的数据存储，使用Elasticsearch做数据检索，这意味着主数据库的所有更改发生时都需要被复制到Elasticsearch，如果多个进程负责这一数据同步，你可能遇到类似于之前描述的并发问题。</p><p>如果你的主数据库已经有了版本号，或一个能作为版本号的字段值比如timestamp，那么你就可以在 Elasticsearch 中通过增加 version_type=extermal到查询字符串的方式重用这些相同的版本号，版本号必须是大于零的整数，且小于9.2E+18，一个Java中 long类型的正值。</p><p>外部版本号的处理方式和我们之前讨论的内部版本号的处理方式有些不同，Elasticsearch不是检查当前_version和请求中指定的版本号是否相同，而是检查当前_version是否小于指定的版本号。如果请求成功，外部的版本号作为文档的新_version进行存储。</p><pre><code>#POST http://127.0.0.1:9200/shopping/_doc/1001?version=300&amp;version_type=external&#123;&quot;title&quot;:&quot;华为手机2&quot;&#125;</code></pre><p>返回结果：</p><pre><code>&#123;    &quot;_index&quot;: &quot;shopping&quot;,    &quot;_type&quot;: &quot;_doc&quot;,    &quot;_id&quot;: &quot;1001&quot;,    &quot;_version&quot;: 300,    &quot;result&quot;: &quot;updated&quot;,    &quot;_shards&quot;: &#123;        &quot;total&quot;: 2,        &quot;successful&quot;: 1,        &quot;failed&quot;: 0    &#125;,    &quot;_seq_no&quot;: 13,    &quot;_primary_term&quot;: 16&#125;</code></pre><h3 id="48-进阶-文档展示-Kibana">48-进阶-文档展示-Kibana</h3><p>Kibana是一个免费且开放的用户界面，能够让你对Elasticsearch 数据进行可视化，并让你在Elastic Stack 中进行导航。你可以进行各种操作，从跟踪查询负载，到理解请求如何流经你的整个应用，都能轻松完成。</p><p><a href="https://artifacts.elastic.co/downloads/kibana/kibana-7.8.0-windows-x86_64.zip">Kibana下载网址</a></p><p>一、解压缩下载的 zip 文件。</p><p>二、修改 config/kibana.yml 文件。</p><pre><code># 默认端口server.port: 5601# ES 服务器的地址elasticsearch.hosts: [&quot;http://localhost:9200&quot;]# 索引名kibana.index: &quot;.kibana&quot;# 支持中文i18n.locale: &quot;zh-CN&quot;</code></pre><p>三、Windows 环境下执行 bin/kibana.bat 文件。（首次启动有点耗时）</p><p>四、通过浏览器访问：<a href="http://localhost:5601">http://localhost:5601</a>。</p><p><img src="../assets/elasticsearch/22c3a6491a72d63deaad80abce01ce05.png" alt=""></p><h2 id="第5章-Elasticsearch集成">第5章 Elasticsearch集成</h2><h3 id="49-框架集成-SpringData-整体介绍">49-框架集成-SpringData-整体介绍</h3><p>Spring Data是一个用于简化数据库、非关系型数据库、索引库访问，并支持云服务的开源框架。其主要目标是使得对数据的访问变得方便快捷，并支持 map-reduce框架和云计算数据服务。Spring Data可以极大的简化JPA(Elasticsearch…)的写法，可以在几乎不用写实现的情况下，实现对数据的访问和操作。除了CRUD 外，还包括如分页、排序等一些常用的功能。</p><p><a href="https://spring.io/projects/spring-data">Spring Data 的官网</a></p><p>Spring Data 常用的功能模块如下：</p><ul><li>Spring Data JDBC</li><li>Spring Data JPA</li><li>Spring Data LDAP</li><li>Spring Data MongoDB</li><li>Spring Data Redis</li><li>Spring Data R2DBC</li><li>Spring Data REST</li><li>Spring Data for Apache Cassandra</li><li>Spring Data for Apache Geode</li><li>Spring Data for Apache Solr</li><li>Spring Data for Pivotal GemFire</li><li>Spring Data Couchbase</li><li>Spring Data Elasticsearch</li><li>Spring Data Envers</li><li>Spring Data Neo4j</li><li>Spring Data JDBC Extensions</li><li>Spring for Apache Hadoop</li></ul><h4 id="Spring-Data-Elasticsearch-介绍">Spring Data Elasticsearch 介绍</h4><p>Spring Data Elasticsearch基于Spring Data API简化 Elasticsearch 操作，将原始操作Elasticsearch 的客户端API进行封装。Spring Data为Elasticsearch 项目提供集成搜索引擎。Spring Data Elasticsearch POJO的关键功能区域为中心的模型与Elastichsearch交互文档和轻松地编写一个存储索引库数据访问层。</p><p><a href="https://spring.io/projects/spring-data-elasticsearch">Spring Data Elasticsearch 官网</a></p><h3 id="50-框架集成-SpringData-代码功能集成">50-框架集成-SpringData-代码功能集成</h3><p>一、创建Maven项目。</p><p>二、修改pom文件，增加依赖关系。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SpringDataWithES<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>三、增加配置文件。</p><p>在 resources 目录中增加application.properties文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># es 服务地址</span></span><br><span class="line"><span class="string">elasticsearch.host=127.0.0.1</span></span><br><span class="line"><span class="comment"># es 服务端口</span></span><br><span class="line"><span class="string">elasticsearch.port=9200</span></span><br><span class="line"><span class="comment"># 配置日志级别,开启 debug 日志</span></span><br><span class="line"><span class="string">logging.level.com.atguigu.es=debug</span></span><br></pre></td></tr></table></figure><p>四、Spring Boot 主程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>五、数据实体类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.Document;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.Field;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.annotations.FieldType;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Document(indexName = &quot;shopping&quot;, shards = 3, replicas = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="comment">//必须有 id,这里的 id 是全局唯一的标识，等同于 es 中的&quot;_id&quot;</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;<span class="comment">//商品唯一标识</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * type : 字段数据类型</span></span><br><span class="line"><span class="comment">     * analyzer : 分词器类型</span></span><br><span class="line"><span class="comment">     * index : 是否索引(默认:true)</span></span><br><span class="line"><span class="comment">     * Keyword : 短语,不进行分词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Text, analyzer = &quot;ik_max_word&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String title;<span class="comment">//商品名称</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Keyword)</span></span><br><span class="line">    <span class="keyword">private</span> String category;<span class="comment">//分类名称</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Double)</span></span><br><span class="line">    <span class="keyword">private</span> Double price;<span class="comment">//商品价格</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Field(type = FieldType.Keyword, index = false)</span></span><br><span class="line">    <span class="keyword">private</span> String images;<span class="comment">//图片地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>六、配置类</p><ul><li>ElasticsearchRestTemplate是spring-data-elasticsearch项目中的一个类,和其他spring项目中的 template类似。</li><li>在新版的spring-data-elasticsearch 中，ElasticsearchRestTemplate 代替了原来的ElasticsearchTemplate。</li><li>原因是ElasticsearchTemplate基于TransportClient，TransportClient即将在8.x 以后的版本中移除。所以，我们推荐使用ElasticsearchRestTemplate。</li><li>ElasticsearchRestTemplate基于RestHighLevelClient客户端的。需要自定义配置类，继承AbstractElasticsearchConfiguration，并实现elasticsearchClient()抽象方法，创建RestHighLevelClient对象。</li></ul><p>AbstractElasticsearchConfiguration源码：</p><pre><code>package org.springframework.data.elasticsearch.config;import org.elasticsearch.client.RestHighLevelClient;import org.springframework.context.annotation.Bean;import org.springframework.data.elasticsearch.core.ElasticsearchOperations;import org.springframework.data.elasticsearch.core.ElasticsearchRestTemplate;import org.springframework.data.elasticsearch.core.convert.ElasticsearchConverter;/** * @author Christoph Strobl * @author Peter-Josef Meisch * @since 3.2 * @see ElasticsearchConfigurationSupport */public abstract class AbstractElasticsearchConfiguration extends ElasticsearchConfigurationSupport &#123;//需重写本方法public abstract RestHighLevelClient elasticsearchClient();@Bean(name = &#123; &quot;elasticsearchOperations&quot;, &quot;elasticsearchTemplate&quot; &#125;)public ElasticsearchOperations elasticsearchOperations(ElasticsearchConverter elasticsearchConverter) &#123;return new ElasticsearchRestTemplate(elasticsearchClient(), elasticsearchConverter);&#125;&#125;</code></pre><p>需要自定义配置类，继承AbstractElasticsearchConfiguration，并实现elasticsearchClient()抽象方法，创建RestHighLevelClient对象。</p><pre><code>import lombok.Data;import org.apache.http.HttpHost;import org.elasticsearch.client.RestClient;import org.elasticsearch.client.RestClientBuilder;import org.elasticsearch.client.RestHighLevelClient;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;import org.springframework.data.elasticsearch.config.AbstractElasticsearchConfiguration;@ConfigurationProperties(prefix = &quot;elasticsearch&quot;)@Configuration@Datapublic class ElasticsearchConfig extends AbstractElasticsearchConfiguration&#123;    private String host ;    private Integer port ;    //重写父类方法    @Override    public RestHighLevelClient elasticsearchClient() &#123;        RestClientBuilder builder = RestClient.builder(new HttpHost(host, port));        RestHighLevelClient restHighLevelClient = new                RestHighLevelClient(builder);        return restHighLevelClient;    &#125;&#125;</code></pre><p>七、DAO 数据访问对象</p><pre><code>import com.lun.model.Product;import org.springframework.data.elasticsearch.repository.ElasticsearchRepository;import org.springframework.stereotype.Repository;@Repositorypublic interface ProductDao extends ElasticsearchRepository&lt;Product, Long&gt;&#123;&#125;</code></pre><h3 id="51-框架集成-SpringData-集成测试-索引操作">51-框架集成-SpringData-集成测试-索引操作</h3><pre><code>import com.lun.model.Product;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.elasticsearch.core.ElasticsearchRestTemplate;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringDataESIndexTest &#123;    //注入 ElasticsearchRestTemplate    @Autowired    private ElasticsearchRestTemplate elasticsearchRestTemplate;    //创建索引并增加映射配置    @Test    public void createIndex()&#123;        //创建索引，系统初始化会自动创建索引        System.out.println(&quot;创建索引&quot;);    &#125;    @Test    public void deleteIndex()&#123;        //创建索引，系统初始化会自动创建索引        boolean flg = elasticsearchRestTemplate.deleteIndex(Product.class);        System.out.println(&quot;删除索引 = &quot; + flg);    &#125;&#125;</code></pre><p>用Postman 检测有没有创建和删除。</p><pre><code>#GET http://localhost:9200/_cat/indices?v </code></pre><h3 id="52-框架集成-SpringData-集成测试-文档操作">52-框架集成-SpringData-集成测试-文档操作</h3><pre><code>import com.lun.dao.ProductDao;import com.lun.model.Product;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Sort;import org.springframework.test.context.junit4.SpringRunner;import java.util.ArrayList;import java.util.List;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringDataESProductDaoTest &#123;    @Autowired    private ProductDao productDao;    /**     * 新增     */    @Test    public void save()&#123;        Product product = new Product();        product.setId(2L);        product.setTitle(&quot;华为手机&quot;);        product.setCategory(&quot;手机&quot;);        product.setPrice(2999.0);        product.setImages(&quot;http://www.atguigu/hw.jpg&quot;);        productDao.save(product);    &#125;    //POSTMAN, GET http://localhost:9200/product/_doc/2    //修改    @Test    public void update()&#123;        Product product = new Product();        product.setId(2L);        product.setTitle(&quot;小米 2 手机&quot;);        product.setCategory(&quot;手机&quot;);        product.setPrice(9999.0);        product.setImages(&quot;http://www.atguigu/xm.jpg&quot;);        productDao.save(product);    &#125;    //POSTMAN, GET http://localhost:9200/product/_doc/2</code></pre><p>​<br>​        //根据 id 查询<br>​        @Test<br>​        public void findById(){<br>​            Product product = productDao.findById(2L).get();<br>​            System.out.println(product);<br>​        }<br>​<br>@Test<br>public void findAll(){<br>Iterable<Product> products = productDao.findAll();<br>for (Product product : products) {<br>System.out.println(product);<br>}<br>}</p><pre><code>    //删除    @Test    public void delete()&#123;        Product product = new Product();        product.setId(2L);        productDao.delete(product);    &#125;    //POSTMAN, GET http://localhost:9200/product/_doc/2    //批量新增    @Test    public void saveAll()&#123;        List&lt;Product&gt; productList = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 10; i++) &#123;            Product product = new Product();            product.setId(Long.valueOf(i));            product.setTitle(&quot;[&quot;+i+&quot;]小米手机&quot;);            product.setCategory(&quot;手机&quot;);            product.setPrice(1999.0 + i);            product.setImages(&quot;http://www.atguigu/xm.jpg&quot;);            productList.add(product);        &#125;        productDao.saveAll(productList);    &#125;    //分页查询    @Test    public void findByPageable()&#123;        //设置排序(排序方式，正序还是倒序，排序的 id)        Sort sort = Sort.by(Sort.Direction.DESC,&quot;id&quot;);        int currentPage=0;//当前页，第一页从 0 开始， 1 表示第二页        int pageSize = 5;//每页显示多少条        //设置查询分页        PageRequest pageRequest = PageRequest.of(currentPage, pageSize,sort);        //分页查询        Page&lt;Product&gt; productPage = productDao.findAll(pageRequest);        for (Product Product : productPage.getContent()) &#123;            System.out.println(Product);        &#125;    &#125;&#125;</code></pre><h3 id="53-框架集成-SpringData-集成测试-文档搜索">53-框架集成-SpringData-集成测试-文档搜索</h3><pre><code>import com.lun.dao.ProductDao;import com.lun.model.Product;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.index.query.TermQueryBuilder;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.domain.PageRequest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringDataESSearchTest &#123;    @Autowired    private ProductDao productDao;    /**     * term 查询     * search(termQueryBuilder) 调用搜索方法，参数查询构建器对象     */    @Test    public void termQuery()&#123;        TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(&quot;title&quot;, &quot;小米&quot;);                Iterable&lt;Product&gt; products = productDao.search(termQueryBuilder);        for (Product product : products) &#123;            System.out.println(product);        &#125;    &#125;    /**     * term 查询加分页     */    @Test    public void termQueryByPage()&#123;        int currentPage= 0 ;        int pageSize = 5;        //设置查询分页        PageRequest pageRequest = PageRequest.of(currentPage, pageSize);        TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(&quot;title&quot;, &quot;小米&quot;);                Iterable&lt;Product&gt; products =                        productDao.search(termQueryBuilder,pageRequest);        for (Product product : products) &#123;            System.out.println(product);        &#125;    &#125;&#125;</code></pre><h3 id="54-框架集成-SparkStreaming-集成">54-框架集成-SparkStreaming-集成</h3><p>Spark Streaming 是Spark core API的扩展，支持实时数据流的处理，并且具有可扩展，高吞吐量，容错的特点。数据可以从许多来源获取,如Kafka， Flume，Kinesis或TCP sockets，并且可以使用复杂的算法进行处理，这些算法使用诸如 map，reduce，join和 window等高级函数表示。最后，处理后的数据可以推送到文件系统，数据库等。实际上，您可以将Spark的机器学习和图形处理算法应用于数据流。</p><p>一、创建Maven项目。</p><p>二、修改 pom 文件，增加依赖关系。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;project    xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.lun.es&lt;/groupId&gt;    &lt;artifactId&gt;sparkstreaming-elasticsearch&lt;/artifactId&gt;    &lt;version&gt;1.0&lt;/version&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;            &lt;artifactId&gt;spark-core_2.12&lt;/artifactId&gt;            &lt;version&gt;3.0.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;            &lt;artifactId&gt;spark-streaming_2.12&lt;/artifactId&gt;            &lt;version&gt;3.0.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt;            &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt;            &lt;version&gt;7.8.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- elasticsearch 的客户端 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;            &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;            &lt;version&gt;7.8.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- elasticsearch 依赖 2.x 的 log4j --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;            &lt;version&gt;2.8.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;            &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;            &lt;version&gt;2.8.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- &lt;dependency&gt;--&gt;        &lt;!-- &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;--&gt;        &lt;!-- &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;--&gt;        &lt;!-- &lt;version&gt;2.11.1&lt;/version&gt;--&gt;        &lt;!-- &lt;/dependency&gt;--&gt;        &lt;!-- &amp;lt;!&amp;ndash; junit 单元测试 &amp;ndash;&amp;gt;--&gt;        &lt;!-- &lt;dependency&gt;--&gt;        &lt;!-- &lt;groupId&gt;junit&lt;/groupId&gt;--&gt;        &lt;!-- &lt;artifactId&gt;junit&lt;/artifactId&gt;--&gt;        &lt;!-- &lt;version&gt;4.12&lt;/version&gt;--&gt;        &lt;!-- &lt;/dependency&gt;--&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p>三、功能实现</p><pre><code>import org.apache.http.HttpHostimport org.apache.spark.SparkConfimport org.apache.spark.streaming.dstream.ReceiverInputDStreamimport org.apache.spark.streaming.&#123;Seconds, StreamingContext&#125;import org.elasticsearch.action.index.IndexRequestimport org.elasticsearch.client.indices.CreateIndexRequestimport org.elasticsearch.client.&#123;RequestOptions, RestClient, RestHighLevelClient&#125;import org.elasticsearch.common.xcontent.XContentTypeimport java.util.Dateobject SparkStreamingESTest &#123;    def main(args: Array[String]): Unit = &#123;        val sparkConf = new SparkConf().setMaster(&quot;local[*]&quot;).setAppName(&quot;ESTest&quot;)        val ssc = new StreamingContext(sparkConf, Seconds(3))        val ds: ReceiverInputDStream[String] = ssc.socketTextStream(&quot;localhost&quot;, 9999)        ds.foreachRDD(            rdd =&gt; &#123;                println(&quot;*************** &quot; + new Date())                rdd.foreach(                    data =&gt; &#123;                        val client = new RestHighLevelClient(RestClient.builder(new HttpHost(&quot;localhost&quot;, 9200, &quot;http&quot;)));                        // 新增文档 - 请求对象                        val request = new IndexRequest();                                                // 设置索引及唯一性标识                        val ss = data.split(&quot; &quot;)                        println(&quot;ss = &quot; + ss.mkString(&quot;,&quot;))                        request.index(&quot;sparkstreaming&quot;).id(ss(0));                                                val productJson =                            s&quot;&quot;&quot;                            | &#123; &quot;data&quot;:&quot;$&#123;ss(1)&#125;&quot; &#125;                            |&quot;&quot;&quot;.stripMargin;                                                // 添加文档数据，数据格式为 JSON 格式                        request.source(productJson,XContentType.JSON);                                                // 客户端发送请求，获取响应对象                        val response = client.index(request,                        RequestOptions.DEFAULT);                        System.out.println(&quot;_index:&quot; + response.getIndex());                        System.out.println(&quot;_id:&quot; + response.getId());                        System.out.println(&quot;_result:&quot; + response.getResult());                        client.close()                    &#125;                )            &#125;        )        ssc.start()        ssc.awaitTermination()    &#125;&#125;</code></pre><h3 id="55-框架集成-Flink-集成">55-框架集成-Flink-集成</h3><p>Apache Spark是一-种基于内存的快速、通用、可扩展的大数据分析计算引擎。Apache Spark掀开了内存计算的先河，以内存作为赌注，贏得了内存计算的飞速发展。但是在其火热的同时，开发人员发现，在Spark中，计算框架普遍存在的缺点和不足依然没有完全解决，而这些问题随着5G时代的来临以及决策者对实时数据分析结果的迫切需要而凸显的更加明显：</p><ul><li>乱序数据，迟到数据</li><li>低延迟，高吞吐，准确性</li><li>容错性</li><li>数据精准一次性处理（Exactly-Once）</li></ul><p>Apache Flink是一个框架和分布式处理引擎，用于对无界和有界数据流进行有状态计算。在Spark火热的同时，也默默地发展自己，并尝试着解决其他计算框架的问题。慢慢地，随着这些问题的解决，Flink 慢慢被绝大数程序员所熟知并进行大力推广，阿里公司在2015年改进Flink，并创建了内部分支Blink，目前服务于阿里集团内部搜索、推荐、广告和蚂蚁等大量核心实时业务。</p><p>一、创建Maven项目。</p><p>二、修改 pom 文件，增加相关依赖类库。</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project    xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.lun.es&lt;/groupId&gt;    &lt;artifactId&gt;flink-elasticsearch&lt;/artifactId&gt;    &lt;version&gt;1.0&lt;/version&gt;    &lt;properties&gt;        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;            &lt;artifactId&gt;flink-scala_2.12&lt;/artifactId&gt;            &lt;version&gt;1.12.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;            &lt;artifactId&gt;flink-streaming-scala_2.12&lt;/artifactId&gt;            &lt;version&gt;1.12.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;            &lt;artifactId&gt;flink-clients_2.12&lt;/artifactId&gt;            &lt;version&gt;1.12.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.flink&lt;/groupId&gt;            &lt;artifactId&gt;flink-connector-elasticsearch7_2.11&lt;/artifactId&gt;            &lt;version&gt;1.12.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- jackson --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;            &lt;version&gt;2.11.1&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p>三、功能实现</p><pre><code>import org.apache.flink.api.common.functions.RuntimeContext;import org.apache.flink.streaming.api.datastream.DataStreamSource;import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;import org.apache.flink.streaming.connectors.elasticsearch.ElasticsearchSinkFunction;import org.apache.flink.streaming.connectors.elasticsearch.RequestIndexer;import org.apache.flink.streaming.connectors.elasticsearch7.ElasticsearchSink;import org.apache.http.HttpHost;import org.elasticsearch.action.index.IndexRequest;import org.elasticsearch.client.Requests;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class FlinkElasticsearchSinkTest &#123;public static void main(String[] args) throws Exception &#123;StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();DataStreamSource&lt;String&gt; source = env.socketTextStream(&quot;localhost&quot;, 9999);List&lt;HttpHost&gt; httpHosts = new ArrayList&lt;&gt;();httpHosts.add(new HttpHost(&quot;127.0.0.1&quot;, 9200, &quot;http&quot;));//httpHosts.add(new HttpHost(&quot;10.2.3.1&quot;, 9200, &quot;http&quot;));// use a ElasticsearchSink.Builder to create an ElasticsearchSinkElasticsearchSink.Builder&lt;String&gt; esSinkBuilder = new ElasticsearchSink.Builder&lt;&gt;(httpHosts, new ElasticsearchSinkFunction&lt;String&gt;() &#123;public IndexRequest createIndexRequest(String element) &#123;Map&lt;String, String&gt; json = new HashMap&lt;&gt;();json.put(&quot;data&quot;, element);return Requests.indexRequest().index(&quot;my-index&quot;)//.type(&quot;my-type&quot;).source(json);&#125;@Overridepublic void process(String element, RuntimeContext ctx, RequestIndexer indexer) &#123;indexer.add(createIndexRequest(element));&#125;&#125;);// configuration for the bulk requests; this instructs the sink to emit after every element, otherwise they would be bufferedesSinkBuilder.setBulkFlushMaxActions(1);// provide a RestClientFactory for custom configuration on the internally createdREST client// esSinkBuilder.setRestClientFactory(// restClientBuilder -&gt; &#123;// restClientBuilder.setDefaultHeaders(...)// restClientBuilder.setMaxRetryTimeoutMillis(...)// restClientBuilder.setPathPrefix(...)// restClientBuilder.setHttpClientConfigCallback(...)// &#125;// );source.addSink(esSinkBuilder.build());env.execute(&quot;flink-es&quot;);&#125;&#125;</code></pre><h2 id="第6章-Elasticsearch优化">第6章 Elasticsearch优化</h2><h3 id="56-优化-硬件选择">56-优化-硬件选择</h3><p>Elasticsearch 的基础是 Lucene，所有的索引和文档数据是存储在本地的磁盘中，具体的路径可在 ES 的配置文件…/config/elasticsearch.yml中配置，如下：</p><pre><code>## Path to directory where to store the data (separate multiple locations by comma):#path.data: /path/to/data## Path to log files:#path.logs: /path/to/logs</code></pre><p>磁盘在现代服务器上通常都是瓶颈。Elasticsearch重度使用磁盘，你的磁盘能处理的吞吐量越大，你的节点就越稳定。这里有一些优化磁盘I/O的技巧：</p><ul><li>使用SSD就像其他地方提过的，他们比机械磁盘优秀多了。</li><li>使用RAID0。条带化RAID会提高磁盘IO，代价显然就是当一块硬盘故障时整个就故障了。不要使用镜像或者奇偶校验RAID，因为副本已经提供了这个功能。</li><li>另外，使用多块硬盘，并允许Elasticsearch 通过多个path data目录配置把数据条带化分配到它们上面。</li><li>不要使用远程挂载的存储，比如NFS或者SMB/CIFS。这个引入的延迟对性能来说完全是背道而驰的。</li></ul><h3 id="57-优化-分片策略">57-优化-分片策略</h3><h4 id="合理设置分片数">合理设置分片数</h4><p>分片和副本的设计为 ES 提供了支持分布式和故障转移的特性，但并不意味着分片和副本是可以无限分配的。而且索引的分片完成分配后由于索引的路由机制，我们是不能重新修改分片数的。</p><p>可能有人会说，我不知道这个索引将来会变得多大，并且过后我也不能更改索引的大小，所以为了保险起见，还是给它设为 1000 个分片吧。但是需要知道的是，一个分片并不是没有代价的。需要了解：</p><ul><li><p>一个分片的底层即为一个 Lucene 索引，会消耗一定文件句柄、内存、以及 CPU运转。</p></li><li><p>每一个搜索请求都需要命中索引中的每一个分片，如果每一个分片都处于不同的节点还好， 但如果多个分片都需要在同一个节点上竞争使用相同的资源就有些糟糕了。</p></li><li><p>用于计算相关度的词项统计信息是基于分片的。如果有许多分片，每一个都只有很少的数据会导致很低的相关度。</p></li></ul><p>一个业务索引具体需要分配多少分片可能需要架构师和技术人员对业务的增长有个预先的判断，横向扩展应当分阶段进行。为下一阶段准备好足够的资源。 只有当你进入到下一个阶段，你才有时间思考需要作出哪些改变来达到这个阶段。一般来说，我们遵循一些原则：</p><ul><li>控制每个分片占用的硬盘容量不超过 ES 的最大 JVM 的堆空间设置（一般设置不超过 32G，参考下文的 JVM 设置原则），因此，如果索引的总容量在 500G 左右，那分片大小在 16 个左右即可；当然，最好同时考虑原则 2。</li><li>考虑一下 node 数量，一般一个节点有时候就是一台物理机，如果分片数过多，大大超过了节点数，很可能会导致一个节点上存在多个分片，一旦该节点故障，即使保持了 1 个以上的副本，同样有可能会导致数据丢失，集群无法恢复。所以， 一般都设置分片数不超过节点数的 3 倍。</li><li>主分片，副本和节点最大数之间数量，我们分配的时候可以参考以下关系：<br><code>节点数&lt;=主分片数 *（副本数+1）</code></li></ul><h4 id="推迟分片分配">推迟分片分配</h4><p>对于节点瞬时中断的问题，默认情况，集群会等待一分钟来查看节点是否会重新加入，如果这个节点在此期间重新加入，重新加入的节点会保持其现有的分片数据，不会触发新的分片分配。这样就可以减少 ES 在自动再平衡可用分片时所带来的极大开销。</p><p>通过修改参数 delayed_timeout ，可以延长再均衡的时间，可以全局设置也可以在索引级别进行修改：</p><pre><code>#PUT /_all/_settings&#123;&quot;settings&quot;: &#123;&quot;index.unassigned.node_left.delayed_timeout&quot;: &quot;5m&quot;&#125;&#125;</code></pre><h3 id="58-优化-路由选择">58-优化-路由选择</h3><p>当我们查询文档的时候， Elasticsearch 如何知道一个文档应该存放到哪个分片中呢？它其实是通过下面这个公式来计算出来：</p><pre><code>shard = hash(routing) % number_of_primary_shards</code></pre><p>routing 默认值是文档的 id，也可以采用自定义值，比如用户 id。</p><h4 id="不带routing查询">不带routing查询</h4><p>在查询的时候因为不知道要查询的数据具体在哪个分片上，所以整个过程分为2个步骤</p><ul><li>分发：请求到达协调节点后，协调节点将查询请求分发到每个分片上。</li><li>聚合：协调节点搜集到每个分片上查询结果，在将查询的结果进行排序，之后给用户返回结果。</li></ul><h4 id="带routing查询">带routing查询</h4><p>查询的时候，可以直接根据routing 信息定位到某个分配查询，不需要查询所有的分配，经过协调节点排序。向上面自定义的用户查询，如果routing 设置为userid 的话，就可以直接查询出数据来，效率提升很多。</p><h3 id="59-优化-写入速度优化">59-优化-写入速度优化</h3><p>ES 的默认配置，是综合了数据可靠性、写入速度、搜索实时性等因素。实际使用时，我们需要根据公司要求，进行偏向性的优化。</p><p>针对于搜索性能要求不高，但是对写入要求较高的场景，我们需要尽可能的选择恰当写优化策略。综合来说，可以考虑以下几个方面来提升写索引的性能：</p><ul><li>加大Translog Flush，目的是降低Iops、Writeblock。</li><li>增加Index Refesh间隔，目的是减少Segment Merge的次数。</li><li>调整Bulk 线程池和队列。</li><li>优化节点间的任务分布。</li><li>优化Lucene层的索引建立，目的是降低CPU及IO。</li></ul><h4 id="优化存储设备">优化存储设备</h4><p>ES 是一种密集使用磁盘的应用，在段合并的时候会频繁操作磁盘，所以对磁盘要求较高，当磁盘速度提升之后，集群的整体性能会大幅度提高。</p><h4 id="合理使用合并">合理使用合并</h4><p>Lucene 以段的形式存储数据。当有新的数据写入索引时， Lucene 就会自动创建一个新的段。</p><p>随着数据量的变化，段的数量会越来越多，消耗的多文件句柄数及 CPU 就越多，查询效率就会下降。</p><p>由于 Lucene 段合并的计算量庞大，会消耗大量的 I/O，所以 ES 默认采用较保守的策略，让后台定期进行段合并。</p><h4 id="减少-Refresh-的次数">减少 Refresh 的次数</h4><p>Lucene 在新增数据时，采用了延迟写入的策略，默认情况下索引的refresh_interval 为1 秒。</p><p>Lucene 将待写入的数据先写到内存中，超过 1 秒（默认）时就会触发一次 Refresh，然后 Refresh 会把内存中的的数据刷新到操作系统的文件缓存系统中。</p><p>如果我们对搜索的实效性要求不高，可以将 Refresh 周期延长，例如 30 秒。</p><p>这样还可以有效地减少段刷新次数，但这同时意味着需要消耗更多的 Heap 内存。</p><h4 id="加大-Flush-设置">加大 Flush 设置</h4><p>Flush 的主要目的是把文件缓存系统中的段持久化到硬盘，当 Translog 的数据量达到 512MB 或者 30 分钟时，会触发一次 Flush。</p><p>index.translog.flush_threshold_size 参数的默认值是 512MB，我们进行修改。</p><p>增加参数值意味着文件缓存系统中可能需要存储更多的数据，所以我们需要为操作系统的文件缓存系统留下足够的空间。</p><h4 id="减少副本的数量">减少副本的数量</h4><p>ES 为了保证集群的可用性，提供了 Replicas（副本）支持，然而每个副本也会执行分析、索引及可能的合并过程，所以 Replicas 的数量会严重影响写索引的效率。</p><p>当写索引时，需要把写入的数据都同步到副本节点，副本节点越多，写索引的效率就越慢。</p><p>如果我们需要大批量进行写入操作，可以先禁止Replica复制，设置<br>index.number_of_replicas: 0 关闭副本。在写入完成后， Replica 修改回正常的状态。</p><h3 id="60-优化-内存设置">60-优化-内存设置</h3><p>ES 默认安装后设置的内存是 1GB，对于任何一个现实业务来说，这个设置都太小了。如果是通过解压安装的 ES，则在 ES 安装文件中包含一个 jvm.option 文件，添加如下命令来设置 ES 的堆大小， Xms 表示堆的初始大小， Xmx 表示可分配的最大内存，都是 1GB。</p><p>确保 Xmx 和 Xms 的大小是相同的，其目的是为了能够在 Java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源，可以减轻伸缩堆大小带来的压力。</p><p>假设你有一个 64G 内存的机器，按照正常思维思考，你可能会认为把 64G 内存都给ES 比较好，但现实是这样吗， 越大越好？虽然内存对 ES 来说是非常重要的，但是答案是否定的！</p><p>因为 ES 堆内存的分配需要满足以下两个原则：</p><ul><li><p>不要超过物理内存的 50%： Lucene 的设计目的是把底层 OS 里的数据缓存到内存中。Lucene 的段是分别存储到单个文件中的，这些文件都是不会变化的，所以很利于缓存，同时操作系统也会把这些段文件缓存起来，以便更快的访问。如果我们设置的堆内存过大， Lucene 可用的内存将会减少，就会严重影响降低 Lucene 的全文本查询性能。</p></li><li><p>堆内存的大小最好不要超过 32GB：在 Java 中，所有对象都分配在堆上，然后有一个 Klass Pointer 指针指向它的类元数据。这个指针在 64 位的操作系统上为 64 位， 64 位的操作系统可以使用更多的内存（2^64）。在 32 位<br>的系统上为 32 位， 32 位的操作系统的最大寻址空间为 4GB（2^32）。<br>但是 64 位的指针意味着更大的浪费，因为你的指针本身大了。浪费内存不算，更糟糕的是，更大的指针在主内存和缓存器（例如 LLC, L1 等）之间移动数据的时候，会占用更多的带宽。</p></li></ul><p>最终我们都会采用 31 G 设置</p><ul><li>-Xms 31g</li><li>-Xmx 31g</li></ul><p>假设你有个机器有 128 GB 的内存，你可以创建两个节点，每个节点内存分配不超过 32 GB。也就是说不超过 64 GB 内存给 ES 的堆内存，剩下的超过 64 GB 的内存给 Lucene。</p><h3 id="61-优化-重要配置">61-优化-重要配置</h3><table><thead><tr><th>参数名</th><th>参数值</th><th>说明</th></tr></thead><tbody><tr><td><a href="http://cluster.name">cluster.name</a></td><td>elasticsearch</td><td>配置 ES 的集群名称，默认值是 ES，建议改成与所存数据相关的名称， ES 会自动发现在同一网段下的 集群名称相同的节点。</td></tr><tr><td><a href="http://node.name">node.name</a></td><td>node-1</td><td>集群中的节点名，在同一个集群中不能重复。节点 的名称一旦设置，就不能再改变了。当然，也可以 设 置 成 服 务 器 的 主 机 名 称 ， 例 如 <a href="http://node.name">node.name</a>:${HOSTNAME}。</td></tr><tr><td>node.master</td><td>true</td><td>指定该节点是否有资格被选举成为 Master 节点，默 认是 True，如果被设置为 True，则只是有资格成为 Master 节点，具体能否成为 Master 节点，需要通 过选举产生。</td></tr><tr><td>node.data</td><td>true</td><td>指定该节点是否存储索引数据，默认为 True。数据 的增、删、改、查都是在 Data 节点完成的。</td></tr><tr><td>index.number_of_shards</td><td>1</td><td>设置都索引分片个数，默认是 1 片。也可以在创建 索引时设置该值，具体设置为多大都值要根据数据 量的大小来定。如果数据量不大，则设置成 1 时效 率最高</td></tr><tr><td>index.number_of_replicas</td><td>1</td><td>设置默认的索引副本个数，默认为 1 个。副本数越 多，集群的可用性越好，但是写索引时需要同步的 数据越多。</td></tr><tr><td>transport.tcp.compress</td><td>true</td><td>设置在节点间传输数据时是否压缩，默认为 False， 不压缩</td></tr><tr><td>discovery.zen.minimum_master_nodes</td><td>1</td><td>设置在选举 Master 节点时需要参与的最少的候选 主节点数，默认为 1。如果使用默认值，则当网络 不稳定时有可能会出现脑裂。 合 理 的 数 值 为 (master_eligible_nodes/2)+1 ， 其 中 master_eligible_nodes 表示集群中的候选主节点数</td></tr><tr><td>discovery.zen.ping.timeout</td><td>3s</td><td>设置在集群中自动发现其他节点时 Ping 连接的超 时时间，默认为 3 秒。 在较差的网络环境下需要设置得大一点，防止因误 判该节点的存活状态而导致分片的转移</td></tr></tbody></table><h2 id="第7章-Elasticsearch面试题">第7章 Elasticsearch面试题</h2><h3 id="62-面试题">62-面试题</h3><h4 id="为什么要使用-Elasticsearch？">为什么要使用 Elasticsearch？</h4><p>系统中的数据， 随着业务的发展，时间的推移， 将会非常多， 而业务中往往采用模糊查询进行数据的搜索， 而模糊查询会导致查询引擎放弃索引，导致系统查询数据时都是全表扫描，在百万级别的数据库中，查询效率是非常低下的，而我们使用 ES 做一个全文索引，将经常查询的系统功能的某些字段，比如说电商系统的商品表中商品名，描述、价格还有 id 这些字段我们放入 ES 索引库里，可以提高查询速度。</p><h4 id="Elasticsearch-的-master-选举流程？">Elasticsearch 的 master 选举流程？</h4><ul><li>Elasticsearch的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）<br>和Unicast（单播模块包含-一个主机列表以控制哪些节点需要ping通）这两部分。</li><li>对所有可以成为master的节点（node master: true）根据nodeId字典排序，每次选举每个节点都把自<br>己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。</li><li>如果对某个节点的投票数达到一定的值（可以成为master节点数n/2+1）并且该节点自己也选举自己，<br>那这个节点就是master。否则重新选举一直到满足上述条件。</li><li>master节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data节点可以关闭http<br>功能。</li></ul><h4 id="Elasticsearch-集群脑裂问题？">Elasticsearch 集群脑裂问题？</h4><p>“脑裂”问题可能的成因：</p><ul><li>网络问题：集群间的网络延迟导致一些节点访问不到master, 认为master 挂掉了从而选举出新的master,并对master上的分片和副本标红，分配新的主分片。</li><li>节点负载：主节点的角色既为master又为data,访问量较大时可能会导致ES停止响应造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点。</li><li>内存回收：data 节点上的ES进程占用的内存较大，引发JVM的大规模内存回收，造成ES进程失去响应。</li></ul><p>脑裂问题解决方案：</p><ul><li><p>减少误判：discovery.zen ping_ timeout 节点状态的响应时间，默认为3s，可以适当调大，如果master在该响应时间的范围内没有做出响应应答，判断该节点已经挂掉了。调大参数（如6s，discovery.zen.ping_timeout:6），可适当减少误判。</p></li><li><p>选举触发：discovery.zen.minimum. <em>master</em> nodes:1，该参數是用于控制选举行为发生的最小集群主节点数量。当备选主节点的个數大于等于该参数的值，且备选主节点中有该参数个节点认为主节点挂了，进行选举。官方建议为(n / 2) +1, n为主节点个数（即有资格成为主节点的节点个数）。</p></li><li><p>角色分离：即master节点与data节点分离，限制角色</p><ul><li>主节点配置为：node master: true，node data: false</li><li>从节点配置为：node master: false，node data: true</li></ul></li></ul><h4 id="Elasticsearch-索引文档的流程？">Elasticsearch 索引文档的流程？</h4><p><img src="../assets/elasticsearch/94707716cb1c7a5ab3dcf8b9e9288a10.png" alt=""></p><ul><li>协调节点默认使用文档 ID 参与计算（也支持通过 routing），以便为路由提供合适的分片：shard = hash(document_id) % (num_of_primary_shards)</li><li>当分片所在的节点接收到来自协调节点的请求后，会将请求写入到 Memory Buffer，然后定时（默认是每隔 1 秒）写入到 Filesystem Cache，这个从 Memory Buffer 到 Filesystem Cache 的过程就叫做 refresh；</li><li>当然在某些情况下，存在 Momery Buffer 和 Filesystem Cache 的数据可能会丢失， ES 是通过 translog的机制来保证数据的可靠性的。其实现机制是接收到请求后，同时也会写入到 translog 中，当 Filesystemcache 中的数据写入到磁盘中时，才会清除掉，这个过程叫做 flush；</li><li>在 flush 过程中，内存中的缓冲将被清除，内容被写入一个新段，段的 fsync 将创建一个新的提交点，并将内容刷新到磁盘，旧的 translog 将被删除并开始一个新的 translog。</li><li>flush 触发的时机是定时触发（默认 30 分钟）或者 translog 变得太大（默认为 512M）时；</li></ul><h4 id="Elasticsearch-更新和删除文档的流程？">Elasticsearch 更新和删除文档的流程？</h4><ul><li>删除和更新也都是写操作，但是 Elasticsearch 中的文档是不可变的，因此不能被删除或者改动以展示其变更；</li><li>磁盘上的每个段都有一个相应的.del 文件。当删除请求发送后，文档并没有真的被删除，而是在.del文件中被标记为删除。该文档依然能匹配查询，但是会在结果中被过滤掉。当段合并时，在.del 文件中被标记为删除的文档将不会被写入新段。</li><li>在新的文档被创建时， Elasticsearch 会为该文档指定一个版本号，当执行更新时，旧版本的文档在.del文件中被标记为删除，新版本的文档被索引到一个新段。旧版本的文档依然能匹配查询，但是会在结果中被过滤掉。</li></ul><h4 id="Elasticsearch-搜索的流程？">Elasticsearch 搜索的流程？</h4><p><img src="../assets/elasticsearch/e00c7b1b4f4af50ded147384bd07519c.png" alt=""></p><ul><li>搜索被执行成一个两阶段过程，我们称之为 Query Then Fetch；</li><li>在初始查询阶段时，查询会广播到索引中每一个分片拷贝（主分片或者副本分片）。 每个分片在本地执行搜索并构建一个匹配文档的大小为 from + size 的优先队列。 PS：在搜索的时候是会查询Filesystem Cache 的，但是有部分数据还在 Memory Buffer，所以搜索是近实时的。</li><li>每个分片返回各自优先队列中 所有文档的 ID 和排序值 给协调节点，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。</li><li>接下来就是取回阶段， 协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。每个分片加载并丰富文档，如果有需要的话，接着返回文档给协调节点。一旦所有的文档都被取回了，协调节点返回结果给客户端。</li><li>Query Then Fetch 的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少的时候可能不够准确， DFS Query Then Fetch 增加了一个预查询的处理，询问 Term 和 Document frequency，这个评分更准确，但是性能会变差。</li></ul><h4 id="Elasticsearch-在部署时，对-Linux-的设置有哪些优化方法？">Elasticsearch 在部署时，对 Linux 的设置有哪些优化方法？</h4><ul><li><p>64 GB 内存的机器是非常理想的， 但是 32 GB 和 16 GB 机器也是很常见的。少于 8 GB 会适得其反。</p></li><li><p>如果你要在更快的 CPUs 和更多的核心之间选择，选择更多的核心更好。多个内核提供的额外并发远胜过稍微快一点点的时钟频率。</p></li><li><p>如果你负担得起 SSD，它将远远超出任何旋转介质。 基于 SSD 的节点，查询和索引性能都有提升。如果你负担得起， SSD 是一个好的选择。</p></li><li><p>即使数据中心们近在咫尺，也要避免集群跨越多个数据中心。绝对要避免集群跨越大的地理距离。</p></li><li><p>请确保运行你应用程序的 JVM 和服务器的 JVM 是完全一样的。 在 Elasticsearch 的几个地方，使用 Java 的本地序列化。</p></li><li><p>通过设置 gateway.recover_after_nodes、 gateway.expected_nodes、 gateway.recover_after_time 可以在集群重启的时候避免过多的分片交换，这可能会让数据恢复从数个小时缩短为几秒钟。</p></li><li><p>Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。最好使用单播代替组播。</p></li><li><p>不要随意修改垃圾回收器（CMS）和各个线程池的大小。</p></li><li><p>把你的内存的（少于）一半给 Lucene（但不要超过 32 GB！），通过 ES_HEAP_SIZE 环境变量设置。</p></li><li><p>内存交换到磁盘对服务器性能来说是致命的。如果内存交换到磁盘上，一个 100 微秒的操作可能变成 10 毫秒。 再想想那么多 10 微秒的操作时延累加起来。 不难看出 swapping 对于性能是多么可怕。</p></li><li><p>Lucene 使用了大量的文件。同时， Elasticsearch 在节点和 HTTP 客户端之间进行通信也使用了大量的套接字。 所有这一切都需要足够的文件描述符。你应该增加你的文件描述符，设置一个很大的值，如 64,000。</p></li></ul><h4 id="GC-方面，在使用-Elasticsearch-时要注意什么？">GC 方面，在使用 Elasticsearch 时要注意什么？</h4><p>倒排词典的索引需要常驻内存，无法 GC，需要监控 data node 上 segment memory 增长趋势。</p><p>各类缓存， field cache, filter cache, indexing cache, bulk queue 等等，要设置合理的大小，并且要应该根据最坏的情况来看 heap 是否够用，也就是各类缓存全部占满的时候，还有 heap 空间可以分配给其他任务吗？避免采用 clear cache 等“自欺欺人”的方式来释放内存。</p><p>避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用 scan &amp; scroll api 来实现。</p><p>cluster stats 驻留内存并无法水平扩展，超大规模集群可以考虑分拆成多个集群通过 tribe node 连接。</p><p>想知道 heap 够不够，必须结合实际应用场景，并对集群的 heap 使用情况做持续的监控。</p><h4 id="Elasticsearch-对于大数据量（上亿量级）的聚合如何实现？">Elasticsearch 对于大数据量（上亿量级）的聚合如何实现？</h4><p>Elasticsearch 提供的首个近似聚合是 cardinality 度量。它提供一个字段的基数，即该字段的 distinct或者 unique 值的数目。它是基于 HLL 算法的。 HLL 会先对我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。</p><h4 id="在并发情况下，-Elasticsearch-如果保证读写一致？">在并发情况下， Elasticsearch 如果保证读写一致？</h4><ul><li><p>可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；</p></li><li><p>另外对于写操作，一致性级别支持 quorum/one/all，默认为 quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。</p></li><li><p>对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置 replication 为 async 时，也可以通过设置搜索请求参数_preference 为 primary 来查询主分片，确保文档是最新版本。</p></li></ul><h4 id="如何监控-Elasticsearch-集群状态？">如何监控 Elasticsearch 集群状态？</h4><pre><code>1. elasticsearch-head 插件。2. 通过 Kibana 监控 Elasticsearch。你可以实时查看你的集群健康状态和性能，也可以分析过去的集群、索引和节点指标</code></pre><h4 id="是否了解字典树？">是否了解字典树？</h4><p>字典树又称单词查找树， Trie 树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p><p>Trie 的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。它有 3 个基本性质：</p><ul><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符。</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。</li><li>每个节点的所有子节点包含的字符都不相同。</li></ul><p>对于中文的字典树，每个节点的子节点用一个哈希表存储，这样就不用浪费太大的空间，而且查询速度上可以保留哈希的复杂度 O(1)。</p><h4 id="Elasticsearch-中的集群、节点、索引、文档、类型是什么？">Elasticsearch 中的集群、节点、索引、文档、类型是什么？</h4><ul><li>集群是一个或多个节点（服务器）的集合，它们共同保存您的整个数据，并提供跨所有节点的联合索引和搜索功能。群集由唯一名 称标识，默认情况下为&quot;elasticsearch&quot;。此名称很重要，因为如果节点设置为按名称加入群集，则该节点只能是群集的一部分。</li><li>节点是属于集群一部分的单个服务器。它存储数据并参与群集索引和搜索功能。</li><li>索引就像关系数据库中的“数据库”。它有一个定义多种类型的映射。索引是逻辑名称空间，映射到一个或多个主分片，并且可以有零个或多个副本分片。MySQL =&gt;数据库，Elasticsearch=&gt;索引。</li><li>文档类似于关系数据库中的一行。不同之处在于索引中的每个文档可以具有不同的结构(字段)，但是对于通用字段应该具有相同的数据类型。MySQL =&gt; Databases =&gt; Tables =&gt; Columns / Rows，Elasticsearch=&gt; Indices =&gt; Types =&gt;具有属性的文档Doc。</li><li>类型是索引的逻辑类别/分区，其语义完全取决于用户。</li></ul><h4 id="Elasticsearch-中的倒排索引是什么？">Elasticsearch 中的倒排索引是什么？</h4><p>倒排索引是搜索引擎的核心。搜索引擎的主要目标是在查找发生搜索条件的文档时提供快速搜索。ES中的倒排索引其实就是 lucene 的倒排索引，区别于传统的正向索引， 倒排索引会再存储数据时将关键词和数据进行关联，保存到倒排表中，然后查询时，将查询内容进行分词后在倒排表中进行查询，最后匹配数据即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法与外挂标签写法汇总</title>
      <link href="/posts/2013454d.html"/>
      <url>/posts/2013454d.html</url>
      
        <content type="html"><![CDATA[<h1>1.Markdown语法自带格式</h1><div class="note info flat"><p>参考：<a href="https://blog.csdn.net/u014061630/article/details/81359144">Markdown语法图文全面详解(10分钟学会)</a></p></div><div class="note warning flat"><p>注意：此页面偶尔会存在CSS冲突问题!</p></div><h2 id="1-1-代码块">1.1 代码块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br><span class="line">\```</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-2-多级标题">1.2 多级标题</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>见本文章标题!</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-3-文字样式">1.3 文字样式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><u>下划线演示</u></p><p>文字<strong>加粗</strong>演示</p><p>文字<em>斜体</em>演示</p><p>文本<code>高亮</code>演示</p><p>文本<s>删除</s>线演示</p><p><font size = 5>5号字</font><br><font face="黑体">黑体</font><br><font color=blue>蓝色</font></p><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRosen，此处输入任意想输入的内容</td></tr></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note info flat"><p>上述要点可参考:<a href="https://blog.csdn.net/qq_43732429/article/details/108034518">【Markdown语法】字体颜色大小及文字底色设置</a></p></div><h2 id="1-4-引用">1.4 引用</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><blockquote><p>Java<br>二级引用演示<br>MySQL</p><blockquote><p>外键</p><p>事务</p><p><strong>行级锁</strong>(引用内部一样可以用格式)</p></blockquote><p>…</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-5-分割线">1.5 分割线</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><hr><hr><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-6-列表-跟空格都可以">1.6 列表(*,+,-跟空格都可以)</h2><h3 id="1-6-1-无序列表">1.6.1 无序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> Java</span><br><span class="line"><span class="bullet">*</span> Python</span><br><span class="line"><span class="bullet">*</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> Java</span><br><span class="line"><span class="bullet">+</span> Python</span><br><span class="line"><span class="bullet">+</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Java</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> ...</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-6-2-有序列表">1.6.2 有序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 注意后面有空格</span></span><br><span class="line"><span class="bullet">1.</span> </span><br><span class="line"><span class="bullet">2.</span> </span><br><span class="line"><span class="bullet">3.</span> </span><br><span class="line"><span class="bullet">4.</span> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li></li><li></li><li></li><li></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-7-图片">1.7 图片</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>本地图片:<br><img src="/assets/pusheencode.webp" alt="示例图片" style="zoom:50%;" /><br>在线图片:<br><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png" alt="code"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-8-表格">1.8 表格</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th>项目标号</th><th>资金</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>100，000</td><td>无</td></tr><tr><td>2</td><td>200，000</td><td>无</td></tr><tr><td>3</td><td>300,600</td><td>重要</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-9-公式">1.9 公式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>$$<br>\Gamma(z)=\int_0^\infty t^{z-1}e^{-t}dt.<br>$$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1>2.Butterfly外挂标签</h1><div class="note info flat"><p>这部分参考安知鱼:<a href="https://anzhiy.cn/posts/7d58.html">基于Butterfly的外挂标签引入</a></p></div><h2 id="2-1-行内文本样式-text">2.1 行内文本样式 text</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-2-行内文本-span">2.2 行内文本 span</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<br><span class='p center logo large'>Volantis</span><br><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-3-段落文本-p">2.3 段落文本 p</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。</li></ul><p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-4-引用note">2.4 引用note</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">通用配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">语法格式</button></li><li class="tab"><button type="button" data-href="#分栏-3">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-4">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-5">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border<span class="emphasis">_radius: 3</span></span><br><span class="line"><span class="emphasis">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line"><span class="emphasis">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line"><span class="emphasis">  light_</span>bg<span class="emphasis">_offset: 0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 自带icon</span></span><br><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="section"># 外部icon</span></span><br><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.自带icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / primary / success / info / warning / danger ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】不显示 icon</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><p>2.外部icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / blue / pink / red / purple / orange / green ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div>2.`modern`样式<div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><p>3.<code>flat</code>样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p>4.<code>disabled</code>样式</p><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>2.<code>modern</code>样式</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>3.<code>flat</code>样式</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>4.<code>disabled</code>样式</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon flat"><p>2021年快到了…</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon flat"><p>剪刀石头布</p></div><div class="note green no-icon flat"><p>前端最讨厌的浏览器</p></div>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-5-上标标签-tip">2.5 上标标签 tip</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: success,error,warning,bolt,ban,home,sync,cogs,key,bell</li><li><code>自定义图标</code>: 支持fontawesome。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义font awesome图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><div class="tip error"><p>error</p></div><div class="tip warning"><p>warning</p></div><div class="tip bolt"><p>bolt</p></div><div class="tip ban"><p>ban</p></div><div class="tip home"><p>home</p></div><div class="tip sync"><p>sync</p></div><div class="tip cogs"><p>cogs</p></div><div class="tip key"><p>key</p></div><div class="tip bell"><p>bell</p></div><div class="tip fa-atom"><p>自定义font awesome图标</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-6-动态标签-anima">2.6 动态标签 anima</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><div class="note info flat"><ol><li>将所需的CSS类添加到图标（或DOM中的任何元素）。</li><li>对于父级悬停样式，需要给目标元素添加指定CSS类，同时还要给目标元素的父级元素添加CSS类<code>faa-parent animated-hover</code>。（详情见示例及示例源码）<br>You can regulate the speed of the animation by adding the CSS class or . faa-fastfaa-slow</li><li>可以通过给目标元素添加CSS类<code>faa-fast</code>或<code>faa-slow</code>来控制动画快慢。</li></ol></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.On DOM load（当页面加载时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>2.调整动画速度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated faa-fast %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated faa-slow %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>3.On hover（当鼠标悬停时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated-hover %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated-hover %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>4.On parent hover（当鼠标悬停在父级元素时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-horizontal&quot;</span>&gt;</span></span>warning<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-flash&quot;</span>&gt;</span></span>ban<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.On DOM load（当页面加载时显示动画）</p><div class="tip warning faa-horizontal animated"><p>warning</p></div><div class="tip ban faa-flash animated"><p>ban</p></div>2.调整动画速度<div class="tip warning faa-horizontal animated faa-fast"><p>warning</p></div><div class="tip ban faa-flash animated faa-slow"><p>ban</p></div>3.On hover（当鼠标悬停时显示动画）<div class="tip warning faa-horizontal animated-hover"><p>warning</p></div><div class="tip ban faa-flash animated-hover"><p>ban</p></div>4.On parent hover（当鼠标悬停在父级元素时显示动画）<div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">warning</p></div><div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-7-复选列表-checkbox">2.7 复选列表 checkbox</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: plus, minus, times</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-8-单选列表-radio">2.8 单选列表 radio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-9-时间轴-timeline">2.9 时间轴 timeline</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选）[,color] %&#125;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>title</code>:标题/时间线</li><li><code>color</code>:<code>timeline</code>颜色:default(留空) / blue / pink / red / purple / orange / green</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间轴样式,blue %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-07-24 [<span class="string">2.6.6 -&gt; 3.0</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果有 <span class="code">`hexo-lazyload-image`</span> 插件，需要删除并重新安装最新版本，设置 <span class="code">`lazyload.isSPA: true`</span>。</span><br><span class="line"><span class="bullet">2.</span> 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <span class="code">`use_cdn: true`</span> 则需要删除。</span><br><span class="line"><span class="bullet">3.</span> 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line"><span class="bullet">4.</span> 2.x 版本的置顶 <span class="code">`top: true`</span> 改为了 <span class="code">`pin: true`</span>，并且同样适用于 <span class="code">`layout: page`</span> 的页面。</span><br><span class="line"><span class="bullet">5.</span> 如果使用了 <span class="code">`hexo-offline`</span> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-05-15 [<span class="string">2.6.3 -&gt; 2.6.6</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6</span>) --&gt;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-04-20 [<span class="string">2.6.2 -&gt; 2.6.3</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 全局搜索 <span class="code">`seotitle`</span> 并替换为 <span class="code">`seo_title`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的索引规则有变，使用 group 组件的文章内，<span class="code">`group: group_name`</span> 对应的组件名必须是 <span class="code">`group_name`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的列表名优先显示文章的 <span class="code">`short_title`</span> 其次是 <span class="code">`title`</span>。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-10-链接卡片-link">2.10 链接卡片 link</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https://akilar.top/posts/615e2dec/, https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-11-按钮-btns">2.11 按钮 btns</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>圆角样式：rounded, circle</li><li>增加文字样式：可以在容器内增加 <code>&lt;b&gt;</code>标题<code>&lt;/b&gt;</code>和<code>&lt;p&gt;</code>描述文字<code>&lt;/p&gt;</code></li><li>布局方式：<br>默认为自动宽度，适合视野内只有一两个的情况。</li></ol><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>wide</td><td>宽一点的按钮</td></tr><tr><td>fill</td><td>填充布局，自动铺满至少一行，多了会换行</td></tr><tr><td>center</td><td>居中，按钮之间是固定间距</td></tr><tr><td>around</td><td>居中分散</td></tr><tr><td>grid2</td><td>等宽最多2列，屏幕变窄会适当减少列数</td></tr><tr><td>grid3</td><td>等宽最多3列，屏幕变窄会适当减少列数</td></tr><tr><td>grid4</td><td>等宽最多4列，屏幕变窄会适当减少列数</td></tr><tr><td>grid5</td><td>等宽最多5列，屏幕变窄会适当减少列数</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>2.或者含有图标的按钮</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns rounded grid5 %&#125;</span><br><span class="line">&#123;% cell 下载源码, /, fas fa-download %&#125;</span><br><span class="line">&#123;% cell 查看文档, /, fas fa-book-open %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle center grid5 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p red, 专业版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p green, 免费版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><div class="btns circle grid5">            <a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>          </div>2.或者含有图标的按钮<div class="btns rounded grid5">            <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a><a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>          </div>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中<div class="btns circle center grid5">            <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p red'>专业版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png'></a><a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p green'>免费版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png'></a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-12-github卡片-ghcard">2.12 github卡片 ghcard</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ghcard 用户名, 其它参数（可选） %&#125;</span><br><span class="line">&#123;% ghcard 用户名/仓库, 其它参数（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>使用<code>,</code>分割各个参数。写法为：<code>参数名=参数值</code><br>以下只写几个常用参数值。</p><table><thead><tr><th><strong>参数名</strong></th><th>取值</th><th>释义</th></tr></thead><tbody><tr><td>hide</td><td>stars,commits,prs,issues,contribs</td><td>隐藏指定统计</td></tr><tr><td>count_private</td><td>true</td><td>将私人项目贡献添加到总提交计数中</td></tr><tr><td>show_icons</td><td>true</td><td>显示图标</td></tr><tr><td>theme</td><td>查阅:<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/themes/README.md">Available Themes</a></td><td>主题</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.用户信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard fomalhaut1998 %&#125; | &#123;% ghcard fomalhaut1998, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=buefy %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=onedark %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=algolia %&#125; | &#123;% ghcard fomalhaut1998, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><p>2.仓库信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=buefy %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=onedark %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=algolia %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.用户信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=calm&show_owner=true"/></a></td></tr></tbody></table><p>2.仓库信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-13-github徽标-ghbdage">2.13 github徽标 ghbdage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage [right],[left],[logo]||[color],[link],[title]||[option] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>left</code>：徽标左边的信息，必选参数。</li><li><code>right</code>: 徽标右边的信息，必选参数，</li><li><code>logo</code>：徽标图标，图标名称详见<a href="https://simpleicons.org/">simpleicons</a>，可选参数。</li><li><code>color</code>：徽标右边的颜色，可选参数。</li><li><code>link</code>：指向的链接，可选参数。</li><li><code>title</code>：徽标的额外信息，可选参数。主要用于优化SEO，但<code>object</code>标签不会像<code>a</code>标签一样在鼠标悬停显示<code>title</code>信息。</li><li><code>option</code>：自定义参数，支持<a href="https://shields.io/">shields.io</a>的全部API参数支持，具体参数可以参看上文中的拓展写法示例。形式为<code>name1=value2&amp;name2=value2</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.基本参数,定义徽标左右文字和图标</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Theme,Butterfly %&#125;</span><br><span class="line">&#123;% bdage Frame,Hexo,hexo %&#125;</span><br></pre></td></tr></table></figure><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage CDN,JsDelivr,jsDelivr||abcdef,https://metroui.org.ua/index.html,本站使用JsDelivr为静态资源提供CDN加速 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割</span><br><span class="line">&#123;% bdage Source,GitHub,GitHub||,https://github.com/ %&#125;</span><br></pre></td></tr></table></figure><p>3.拓展参数，支持shields的API的全部参数内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Hosted,Vercel,Vercel||brightgreen,https://vercel.com/,本站采用双线部署，默认线路托管于Vercel||style=social&amp;logoWidth=20 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割</span><br><span class="line">&#123;% bdage Hosted,Vercel,Vercel||||style=social&amp;logoWidth=20&amp;logoColor=violet %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.基本参数,定义徽标左右文字和图标</p><p><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object></p><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><p><object class="ghbdage" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速" standby="loading..." data="https://img.shields.io/badge/JsDelivr-CDN-orange?logo=jsDelivr&color=abcdef&link=https://metroui.org.ua/index.html&"></object><br>//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/GitHub-Source-orange?logo=GitHub&color=orange&link=https://github.com/&"></object></p><p>3.拓展参数，支持shields的API的全部参数内容</p><p><object class="ghbdage" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=brightgreen&link=https://vercel.com/&style=social&logoWidth=20"></object><br>//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=orange&link=&style=social&logoWidth=20&logoColor=violet"></object></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-14-网站卡片-sites">2.14 网站卡片 sites</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site xaoxuu, url=https://xaoxuu.com, screenshot=https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg, avatar=https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png, description=简约风格 %&#125;</span><br><span class="line">&#123;% site inkss, url=https://inkss.cn, screenshot=https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg, avatar=https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site MHuiG, url=https://blog.mhuig.top, screenshot=https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png, avatar=https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Colsrch, url=https://colsrch.top, screenshot=https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png, avatar=https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Linhk1606, url=https://linhk1606.github.io, screenshot=https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png, avatar=https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="site-card-group"><a class="site-card" href="https://fomalhaut1998.com"><div class="img"><img src="https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png"/><span class="title">fomalhaut1998</span><span class="desc">简约风格</span></div></a><a class="site-card" href="https://inkss.cn"><div class="img"><img src="https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg"/><span class="title">inkss</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://blog.mhuig.top"><div class="img"><img src="https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png"/><span class="title">MHuiG</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://colsrch.top"><div class="img"><img src="https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg"/><span class="title">Colsrch</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://linhk1606.github.io"><div class="img"><img src="https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png"/></div><div class="info"><img src="https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png"/><span class="title">Linhk1606</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-15-行内图片-inlineimage">2.15 行内图片 inlineimage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% inlineimage 图片链接, height=高度（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>高度</code>：height=20px</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif %&#125; 一段话。</span><br><span class="line"></span><br><span class="line">这又是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif, height=40px %&#125; 一段话。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>这是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif" style="height:1.5em"/> 一段话。</p><p>这又是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif" style="height:40px;"/> 一段话。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-16-单张图片-image">2.16 单张图片 image</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>图片宽度高度：width=300px, height=32px</li><li>图片描述：alt=图片描述（butterfly需要在主题配置文件中开启图片描述）</li><li>占位背景色：bg=#f2f2f2</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>2.指定宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px %&#125;</span><br></pre></td></tr></table></figure><p>3.指定宽度并添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>4.设置占位背景色：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, bg=#1D0C04, alt=优化不同宽度浏览的观感 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.添加描述：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>2..指定宽度<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" style="width:400px;"/></div></div>3.指定宽度并添加描述：<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。" style="width:400px;"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>4.设置占位背景色：<div class="img-wrap"><div class="img-bg" style="background:#1D0C04"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="优化不同宽度浏览的观感" style="width:400px;"/></div><span class="image-caption">优化不同宽度浏览的观感</span></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-17-音频-audio">2.17 音频 audio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="audio"><audio controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-18-视频-video">2.18 视频 video</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video 视频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>对齐方向</code>：left, center, right</li><li><code>列数</code>：逗号后面直接写列数，支持 1 ～ 4 列。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.100%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br></pre></td></tr></table></figure><p>2.50%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 2 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><p>3.25%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 4 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.100%宽度</p><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>2.50%宽度<div class="videos" col='2'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div>3.25%宽度<div class="videos" col='4'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-19-相册-gallery">2.19 相册 gallery</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 圖片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>gallerygroup 相册图库</li></ul><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>name</td><td>图库名字</td></tr><tr><td>description</td><td>图库描述</td></tr><tr><td>link</td><td>链接到对应相册的地址</td></tr><tr><td>img-url</td><td>图库封面</td></tr></tbody></table><ul><li><p>gallery 相册</p><p>区别于旧版的Gallery相册,新的Gallery相册会自动根据图片长度进行排版，书写也更加方便，与markdown格式一样。可根据需要插入到相应的md。无需再自己配置长宽。<strong>建议在粘贴时故意使用长短、大小、横竖不一的图片</strong>，会有更好的效果。（尺寸完全相同的图片只会平铺输出，效果很糟糕）</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup MC 在Rikkaの六花服务器里留下的足迹 &#x27;/gallery/MC/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup Gundam 哦咧哇gundam哒！ &#x27;/gallery/Gundam/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png %&#125;</span><br><span class="line">&#123;% galleryGroup I-am-Akilar 某种意义上也算自拍吧 &#x27;/gallery/I-am-Akilar/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg</span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.gallerygroup 相册图库</p><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">MC</div>  <p>在Rikkaの六花服务器里留下的足迹</p>  <a href='/gallery/MC/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Gundam</div>  <p>哦咧哇gundam哒！</p>  <a href='/gallery/Gundam/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">I-am-Akilar</div>  <p>某种意义上也算自拍吧</p>  <a href='/gallery/I-am-Akilar/'></a>  </figcaption>  </figure></div>2.gallery 相册<div class="fj-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg" alt=""></p>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-20-折叠框-folding">2.20 折叠框 folding</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><!-- tab 参数配置 --><ol><li><p><code>颜色</code>：blue, cyan, green, yellow, red</p></li><li><p><code>状态</code>：状态填写 open 代表默认打开。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> haha</span><br><span class="line"><span class="bullet">-</span> hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;height:24px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt=""></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <p>假装这里有代码块（代码块没法嵌套代码块）</p>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-21-分栏-tab">2.21 分栏 tab</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>Unique name :</p><ul><li><p>选项卡块标签的唯一名称，不带逗号。</p></li><li><p>将在#id中用作每个标签及其索引号的前缀。</p></li><li><p>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</p></li><li><p>仅当前帖子/页面的URL必须是唯一的！</p></li></ul></li><li><p>[index]:</p><ul><li><p>活动选项卡的索引号。</p></li><li><p>如果未指定，将选择第一个标签（1）。</p></li><li><p>如果index为-1，则不会选择任何选项卡。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[Tab caption]:</p><ul><li><p>当前选项卡的标题。</p></li><li><p>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</p></li><li><p>如果未指定标题，但指定了图标，则标题将为空。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[@icon]:</p><ul><li><p>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</p></li><li><p>可以指定带空格或不带空格；</p></li><li><p>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</p></li><li><p>可选参数。</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>2.Demo 2 - 预设选择tabs</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>3.Demo 3 - 没有预设值</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.Demo 1 - 预设选择第一个【默认】</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>2.Demo 2 - 预设选择tabs</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>3.Demo 3 - 没有预设值</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-22-诗词标签-poem">2.22 诗词标签 poem</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><ol><li><code>title</code>：诗词标题</li><li><code>author</code>：作者，可以不写</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% poem 水调歌头,苏轼 %&#125;</span><br><span class="line">丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</span><br><span class="line">明月几时有？把酒问青天。</span><br><span class="line">不知天上宫阙，今夕是何年？</span><br><span class="line">我欲乘风归去，又恐琼楼玉宇，高处不胜寒。</span><br><span class="line">起舞弄清影，何似在人间？</span><br><span class="line"></span><br><span class="line">转朱阁，低绮户，照无眠。</span><br><span class="line">不应有恨，何事长向别时圆？</span><br><span class="line">人有悲欢离合，月有阴晴圆缺，此事古难全。</span><br><span class="line">但愿人长久，千里共婵娟。</span><br><span class="line">&#123;% endpoem %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br>明月几时有？把酒问青天。<br>不知天上宫阙，今夕是何年？<br>我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br>起舞弄清影，何似在人间？</p><p>转朱阁，低绮户，照无眠。<br>不应有恨，何事长向别时圆？<br>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-23-阿里图标-icon">2.23 阿里图标 icon</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon [icon-xxxx],[font-size] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>icon-xxxx</code>：表示图标<code>font-class</code>,可以在自己的阿里矢量图标库项目的<code>font-class</code>引用方案内查询并复制。</li><li><code>font-size</code>：表示图标大小，直接填写数字即可，单位为<code>em</code>。图标大小默认值为<code>1em</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon icon-rat<span class="emphasis">_zi %&#125;&#123;% icon icon-rat,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-ox_</span>chou,3 %&#125;&#123;% icon icon-ox,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-tiger<span class="emphasis">_yin,5 %&#125;&#123;% icon icon-tiger,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rabbit_</span>mao,1 %&#125;&#123;% icon icon-rabbit,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dragon<span class="emphasis">_chen,3 %&#125;&#123;% icon icon-dragon,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-snake_</span>si,5 %&#125;&#123;% icon icon-snake,6 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-horse<span class="emphasis">_wu %&#125;&#123;% icon icon-horse,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-goat_</span>wei,3 %&#125;&#123;% icon icon-goat,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-monkey<span class="emphasis">_shen,5 %&#125;&#123;% icon icon-monkey,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rooster_</span>you %&#125;&#123;% icon icon-rooster,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dog<span class="emphasis">_xu,3 %&#125;&#123;% icon icon-dog,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-boar_</span>hai,5 %&#125;&#123;% icon icon-boar,6 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-snake_si"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-snake"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-horse_wu"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-horse"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-goat_wei"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-goat"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-monkey_shen"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-monkey"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rooster_you"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rooster"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dog_xu"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dog"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-boar_hai"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-boar"></use></svg></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-24-特效标签wow">2.24 特效标签wow</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow [animete],[duration],[delay],[offset],[iteration] %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endwow %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>animate</code>: 动画样式，效果详见<a href="https://animate.style/">animate.css参考文档</a></li><li><code>duration</code>: 选填项，动画持续时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>delay</code>: 选填项，动画开始的延迟时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>offset</code>: 选填项，开始动画的距离（相对浏览器底部）</li><li><code>iteration</code>: 选填项，动画重复的次数</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.flip动画效果。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>3.slideInRight动画效果，持续5s，延时5s</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__slideInRight,5s,5s %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note orange &#x27;fas fa-car&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`slideInRight`动画效果，持续`5s`，延时`5s`。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__heartBeat,,5s,,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note red &#x27;fas fa-battery-half&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`heartBeat`动画效果，延时`5s`，重复`10`次。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.flip动画效果。</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>3.slideInRight动画效果，持续5s，延时5s</p><div class='wow animate__slideInRight' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='' ><div class="note orange icon-padding modern"><i class="note-icon fas fa-car"></i><p><code>slideInRight</code>动画效果，持续<code>5s</code>，延时<code>5s</code>。</p></div></div><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><div class='wow animate__heartBeat' data-wow-duration='' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='10' ><div class="note red icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p><code>heartBeat</code>动画效果，延时<code>5s</code>，重复<code>10</code>次。</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-25-进度条-progress">2.25  进度条 progress</h2><div class="note info flat"><p>进度条标签参考<a href="https://rongbuqiu.com/jdt.html">沂佰孜猫-给HEXO文章添加彩色进度条</a>。<br>源样式提取自<a href="https://zwying0814.gitbook.io/cuteen/">Cuteen</a>主题。</p></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress [width] [color] [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>width</code>: 0到100的阿拉伯数字</li><li><code>color</code>: 颜色，取值有red,yellow,green,cyan,blue,gray</li><li><code>text</code>:进度条上的文字内容</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress 10 red 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 30 yellow 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 50 green 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 70 cyan 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 90 blue 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 100 gray 进度条样式预览 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-red"  style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-yellow"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-cyan"  style="width: 70%" aria-valuenow="70" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-gray"  style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-26-注释-notation">2.26 注释 notation</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota [label] , [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p><code>label</code>: 注释词汇</p></li><li><p><code>text</code>: 悬停显示的注解内容</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota 把鼠标移动到我上面试试 ,可以看到注解内容出现在顶栏 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><span class='nota' data-nota='可以看到注解内容出现在顶栏'>把鼠标移动到我上面试试</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-27-气泡注释-bubble">2.27 气泡注释 bubble</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bubble [content] , [notation] ,[background-color] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>content</code>: 注释词汇</li><li><code>notation</code>: 悬停显示的注解内容</li><li><code>background-color</code>: 可选，气泡背景色。默认为“#71a4e3”</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的&#123;% bubble 兄弟相邻选择器,&quot;例如 h1 + p &#123;margin-top:50px;&#125;&quot; %&#125;，&#123;% bubble flex布局,&quot;Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;,&quot;#ec5830&quot; %&#125;，&#123;% bubble transform变换,&quot;transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。&quot;,&quot;#1db675&quot; %&#125;，animation的&#123;% bubble 贝塞尔速度曲线,&quot;贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋&quot;,&quot;#de4489&quot; %&#125;写法，还有今天刚看到的&#123;% bubble clip-path,&quot;clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。&quot;,&quot;#868fd7&quot; %&#125;属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的<span class="bubble-content">兄弟相邻选择器</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#71a4e3;">例如 h1 + p {margin-top:50px;}</span></span>，<span class="bubble-content">flex布局</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#ec5830;">Flex 是 Flexible Box 的缩写，意为弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;</span></span>，<span class="bubble-content">transform变换</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#1db675;">transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</span></span>，animation的<span class="bubble-content">贝塞尔速度曲线</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#de4489;">贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋</span></span>写法，还有今天刚看到的<span class="bubble-content">clip-path</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#868fd7;">clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</span></span>属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-28-引用文献-reference">2.28 引用文献 reference</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% referto [id] , [literature] %&#125;</span><br><span class="line">&#123;% referfrom [id] , [literature] , [url] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>referto 引用上标</p><ul><li><p><code>id</code>: 上标序号内容，需与referfrom标签的id对应才能实现跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li></ul></li><li><p>referfrom 引用出处</p><ul><li><p><code>id</code>: 序号内容，需与referto标签的id对应才能实现 跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li><li><p><code>url</code>: 引用的参考文献链接，可省略</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Akilarの糖果屋(akilar.top)是一个私人性质的博客&#123;% referto &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27; %&#125;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架&#123;% referto &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27; %&#125;，Butterfly主题&#123;% referto &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">本项目参考了Volantis&#123;% referto &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27; %&#125;的标签样式。引入<span class="code">`[tag].js`</span>，并针对<span class="code">`butterfly`</span>主题修改了相应的<span class="code">`[tag].styl`</span>。在此鸣谢<span class="code">`Volantis`</span>主题众开发者。</span><br><span class="line">主要参考内容包括各个volantis的内置标签插件文档&#123;% referto &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27; %&#125;</span><br><span class="line">Butterfly主题的各个衍生魔改&#123;% referto &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27; %&#125;&#123;% referto &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27; %&#125;&#123;% referto &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27; %&#125;&#123;% referto &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% referfrom &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27;,&#x27;https://jq.qq.com/?<span class="emphasis">_wv=1027&amp;k=pGLB2C0N&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27;,&#x27;https://hexo.io/zh-cn/docs/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27;,&#x27;https://butterfly.js.org/posts/21cfbf15/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27;,&#x27;https://volantis.js.org/v5/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27;,&#x27;https://volantis.js.org/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27;,&#x27;https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27;,&#x27;https://lovelijunyi.gitee.io/posts/c898.html&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27;,&#x27;https://github.com/l-lin/font-awesome-animation&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27;,&#x27;https://www.antmoe.com/posts/3b43914f/&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>Akilarの糖果屋(akilar.top)是一个私人性质的博客<span class="hidden-anchor" id="referto_[1]"></span><sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Akilarの糖果屋群聊简介</span><span class="reference-title">参考资料</span></span></span>，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架<span class="hidden-anchor" id="referto_[2]"></span><sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Hexo中文文档</span><span class="reference-title">参考资料</span></span></span>，Butterfly主题<span class="hidden-anchor" id="referto_[3]"></span><sup class="reference"><a href="#referfrom_[3]">[3]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档(一) 快速开始</span><span class="reference-title">参考资料</span></span></span></p><p>本项目参考了Volantis<span class="hidden-anchor" id="referto_[4]"></span><sup class="reference"><a href="#referfrom_[4]">[4]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">hexo-theme-volantis 标签插件</span><span class="reference-title">参考资料</span></span></span>的标签样式。引入<code>[tag].js</code>，并针对<code>butterfly</code>主题修改了相应的<code>[tag].styl</code>。在此鸣谢<code>Volantis</code>主题众开发者。<br>主要参考内容包括各个volantis的内置标签插件文档<span class="hidden-anchor" id="referto_[5]"></span><sup class="reference"><a href="#referfrom_[5]">[5]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Volantis文档:内置标签插件</span><span class="reference-title">参考资料</span></span></span><br>Butterfly主题的各个衍生魔改<span class="hidden-anchor" id="referto_[6]"></span><sup class="reference"><a href="#referfrom_[6]">[6]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档:标签外挂（Tag Plugins</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[7]"></span><sup class="reference"><a href="#referfrom_[7]">[7]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小弋の生活馆全样式预览</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[8]"></span><sup class="reference"><a href="#referfrom_[8]">[8]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">l-lin-font-awesome-animation</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[9]"></span><sup class="reference"><a href="#referfrom_[9]">[9]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小康的butterfly主题使用文档</span><span class="reference-title">参考资料</span></span></span></p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://jq.qq.com/?_wv=1027&k=pGLB2C0N">Akilarの糖果屋群聊简介</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档(一) 快速开始</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[4]"></span><a class="reference-anchor" href="#referto_[4]">[4]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/v5/tag-plugins/">hexo-theme-volantis 标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[5]"></span><a class="reference-anchor" href="#referto_[5]">[5]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/tag-plugins/">Volantis文档:内置标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[6]"></span><a class="reference-anchor" href="#referto_[6]">[6]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly 安装文档:标签外挂（Tag Plugins</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[7]"></span><a class="reference-anchor" href="#referto_[7]">[7]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://lovelijunyi.gitee.io/posts/c898.html">小弋の生活馆全样式预览</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[8]"></span><a class="reference-anchor" href="#referto_[8]">[8]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/l-lin/font-awesome-animation">l-lin-font-awesome-animation</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[9]"></span><a class="reference-anchor" href="#referto_[9]">[9]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.antmoe.com/posts/3b43914f/">小康的butterfly主题使用文档</a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-29-PDF展示">2.29 PDF展示</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf 文件路径 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>文件路径</code>: 可以是相对路径或者是在线链接</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.本地文件:在md文件路径下创建一个同名文件夹，其内放pdf文件名为xxx.pdf的文件</span></span><br><span class="line">&#123;% pdf xxx.pdf %&#125;</span><br><span class="line"><span class="section"># 2.在线链接</span></span><br><span class="line">&#123;% pdf https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>2.在线链接(要放到最外层才能起作用)</p><pre><code>&lt;div class=&quot;row&quot;&gt;&lt;embed src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;&lt;/div&gt;</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-30-Hexo-tag-map-插件">2.30 Hexo-tag-map 插件</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% + 标签值 + 经度 + 纬度 + 文本 + 缩放等级 + 宽 + 高 + 默认图层 + %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th style="text-align:center">地图名</th><th style="text-align:center">标签值 &lt;必填&gt;</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">缩放等级 (默认 14)</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">默认图层 (默认 1)</th></tr></thead><tbody><tr><td style="text-align:center">混合地图</td><td style="text-align:center">map</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~7</td></tr><tr><td style="text-align:center">谷歌地图</td><td style="text-align:center">googleMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~20</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">高德地图</td><td style="text-align:center">gaodeMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">百度地图</td><td style="text-align:center">baiduMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 4~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~2</td></tr><tr><td style="text-align:center">Geoq 地图</td><td style="text-align:center">geoqMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~5</td></tr><tr><td style="text-align:center">openstreet 地图</td><td style="text-align:center">openstreetMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">不支持此参数</td></tr></tbody></table><ol><li>参数之间，用英文逗号相隔</li><li>参数必须按上述事例顺序输入，不得为空</li><li>同一个页面，同一组经纬度值，只能插入一个相同标签值的地图 (若有需要，可以将第二个地图上，经度或纬度末尾删除一两个数)</li><li>参数取值必须在上述范围内</li><li>默认图层：即地图叠加层的值，默认常规地图还是卫星地图，可按地图显示顺序取值</li><li>缩放等级，数字越大，地图比例尺越小，显示的越精细</li><li>除标签值外，其他参数选填，但 每个参数的左边的参数必填</li><li>谷歌地图需要外网才能加载查看</li></ol><p>坐标获取：<a href="https://lbs.amap.com/tools/picker">高德地图坐标拾取系统</a> 、<a href="https://api.map.baidu.com/lbsapi/getpoint/index.html">百度地图坐标拾取系统</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% map 120.101101,30.239119 %&#125;</span><br><span class="line">&#123;% googleMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！ %&#125;</span><br><span class="line">&#123;% geoqMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！, 13, 90%, 320px, 3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="map-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-120.101101-30.239119',{center:[30.239119,120.101101],zoom:14,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="googleMap-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:22,minZoom:1,attribution:'Google Maps'});var baseLayers={"谷歌地图":normalMap,"谷歌卫星图":satelliteMap,"谷歌卫星标注": routeMap};var overlayLayers={};var mymap=L.map("googleMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:14,layers:[normalMap],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="geoqMap-120.101101-30.239119" style="max-width:90%; height:320px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm2=L.tileLayer.chinaProvider('Geoq.Normal.PurplishBlue',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm3=L.tileLayer.chinaProvider('Geoq.Normal.Gray',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm4=L.tileLayer.chinaProvider('Geoq.Normal.Warm',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm5=L.tileLayer.chinaProvider('Geoq.Theme.Hydro',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm1,normalm2,normalm3,normalm4,normalm5]);var baseLayers={"智图地图":normalm1,"午夜蓝":normalm2,"灰色":normalm3,"暖色":normalm4,"水系":normalm5};var mymap=L.map("geoqMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:13,layers:[normalm3],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-31-隐藏块">2.31 隐藏块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>content：要隐藏的内容</li><li>display：展示前按钮显示的文字（可选）</li><li>bg：按钮的背景颜色（可选）</li><li>color：按钮显示的文字的颜色（可选）</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock 点我预览, blue %&#125;</span><br><span class="line">这里有张图片：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image (1)&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:67%;&quot;</span> /&gt;</span></span></span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb" alt="image (1)" style="zoom:67%;" /></p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 外挂标签 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
